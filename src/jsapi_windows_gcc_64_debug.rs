/* automatically generated by rust-bindgen */

#[derive(Copy, Debug)]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
pub const JSVAL_INT_BITS: ::std::os::raw::c_uint = 32;
pub const JSVAL_TAG_SHIFT: ::std::os::raw::c_uint = 47;
pub const JSID_TYPE_STRING: ::std::os::raw::c_uint = 0;
pub const JSID_TYPE_INT: ::std::os::raw::c_uint = 1;
pub const JSID_TYPE_VOID: ::std::os::raw::c_uint = 2;
pub const JSID_TYPE_SYMBOL: ::std::os::raw::c_uint = 4;
pub const JSID_TYPE_MASK: ::std::os::raw::c_uint = 7;
pub const JSID_INT_MIN: ::std::os::raw::c_uint = 0;
pub const JSCLASS_RESERVED_SLOTS_SHIFT: ::std::os::raw::c_uint = 8;
pub const JSCLASS_RESERVED_SLOTS_WIDTH: ::std::os::raw::c_uint = 8;
pub const JSCLASS_GLOBAL_APPLICATION_SLOTS: ::std::os::raw::c_uint = 5;
pub const JSCLASS_NO_OPTIONAL_MEMBERS: ::std::os::raw::c_uint = 0;
pub const JS_STRUCTURED_CLONE_VERSION: ::std::os::raw::c_uint = 6;
pub const JS_SCERR_RECURSION: ::std::os::raw::c_uint = 0;
pub const JS_SCERR_TRANSFERABLE: ::std::os::raw::c_uint = 1;
pub const JS_SCERR_DUP_TRANSFERABLE: ::std::os::raw::c_uint = 2;
pub const JS_SCERR_UNSUPPORTED_TYPE: ::std::os::raw::c_uint = 3;
pub const JSPROP_ENUMERATE: ::std::os::raw::c_uint = 1;
pub const JSPROP_READONLY: ::std::os::raw::c_uint = 2;
pub const JSPROP_PERMANENT: ::std::os::raw::c_uint = 4;
pub const JSPROP_PROPOP_ACCESSORS: ::std::os::raw::c_uint = 8;
pub const JSPROP_GETTER: ::std::os::raw::c_uint = 16;
pub const JSPROP_SETTER: ::std::os::raw::c_uint = 32;
pub const JSPROP_SHARED: ::std::os::raw::c_uint = 64;
pub const JSPROP_INTERNAL_USE_BIT: ::std::os::raw::c_uint = 128;
pub const JSFUN_STUB_GSOPS: ::std::os::raw::c_uint = 512;
pub const JSFUN_CONSTRUCTOR: ::std::os::raw::c_uint = 1024;
pub const JSFUN_HAS_REST: ::std::os::raw::c_uint = 4096;
pub const JSFUN_FLAGS_MASK: ::std::os::raw::c_uint = 7680;
pub const JSPROP_REDEFINE_NONCONFIGURABLE: ::std::os::raw::c_uint = 4096;
pub const JSPROP_RESOLVING: ::std::os::raw::c_uint = 8192;
pub const JSPROP_IGNORE_ENUMERATE: ::std::os::raw::c_uint = 16384;
pub const JSPROP_IGNORE_READONLY: ::std::os::raw::c_uint = 32768;
pub const JSPROP_IGNORE_PERMANENT: ::std::os::raw::c_uint = 65536;
pub const JSPROP_IGNORE_VALUE: ::std::os::raw::c_uint = 131072;
pub const JSREPORT_ERROR: ::std::os::raw::c_uint = 0;
pub const JSREPORT_WARNING: ::std::os::raw::c_uint = 1;
pub const JSREPORT_EXCEPTION: ::std::os::raw::c_uint = 2;
pub const JSREPORT_STRICT: ::std::os::raw::c_uint = 4;
pub const JSREPORT_STRICT_MODE_ERROR: ::std::os::raw::c_uint = 8;
pub const JS_DEFAULT_ZEAL_FREQ: ::std::os::raw::c_uint = 100;
pub const JSITER_ENUMERATE: ::std::os::raw::c_uint = 1;
pub const JSITER_FOREACH: ::std::os::raw::c_uint = 2;
pub const JSITER_KEYVALUE: ::std::os::raw::c_uint = 4;
pub const JSITER_OWNONLY: ::std::os::raw::c_uint = 8;
pub const JSITER_HIDDEN: ::std::os::raw::c_uint = 16;
pub const JSITER_SYMBOLS: ::std::os::raw::c_uint = 32;
pub const JSITER_SYMBOLSONLY: ::std::os::raw::c_uint = 64;
pub const JITINFO_OP_TYPE_BITS: ::std::os::raw::c_uint = 4;
pub const JITINFO_ALIAS_SET_BITS: ::std::os::raw::c_uint = 4;
pub const JITINFO_RETURN_TYPE_BITS: ::std::os::raw::c_uint = 8;
pub const JITINFO_SLOT_INDEX_BITS: ::std::os::raw::c_uint = 10;
pub type HashNumber = u32;
pub type MallocSizeOf =
    ::std::option::Option<unsafe extern "C" fn(p:
                                                   *const ::std::os::raw::c_void)
                              -> usize>;
pub type MozMallocSizeOf =
    ::std::option::Option<unsafe extern "C" fn(p:
                                                   *const ::std::os::raw::c_void)
                              -> usize>;
#[repr(C)]
pub struct EnumeratedArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangedPtr<T> {
    pub mPtr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Range<T> {
    pub mStart: RangedPtr<T>,
    pub mEnd: RangedPtr<T>,
}
pub enum JSContext { }
pub enum JSFunction { }
pub enum JSObject { }
pub enum JSScript { }
pub enum JSString { }
pub enum JSAddonId { }
pub type Latin1Char = ::std::os::raw::c_uchar;
pub enum Symbol { }
pub type HandleFunction = Handle<*mut JSFunction>;
pub type HandleId = Handle<jsid>;
pub type HandleObject = Handle<*mut JSObject>;
pub type HandleScript = Handle<*mut JSScript>;
pub type HandleString = Handle<*mut JSString>;
pub type HandleSymbol = Handle<*mut Symbol>;
pub type HandleValue = Handle<Value>;
pub type MutableHandleFunction = MutableHandle<*mut JSFunction>;
pub type MutableHandleId = MutableHandle<jsid>;
pub type MutableHandleObject = MutableHandle<*mut JSObject>;
pub type MutableHandleScript = MutableHandle<*mut JSScript>;
pub type MutableHandleString = MutableHandle<*mut JSString>;
pub type MutableHandleSymbol = MutableHandle<*mut Symbol>;
pub type MutableHandleValue = MutableHandle<Value>;
pub type RootedObject = Rooted<*mut JSObject>;
pub type RootedFunction = Rooted<*mut JSFunction>;
pub type RootedScript = Rooted<*mut JSScript>;
pub type RootedString = Rooted<*mut JSString>;
pub type RootedSymbol = Rooted<*mut Symbol>;
pub type RootedId = Rooted<jsid>;
pub type RootedValue = Rooted<Value>;
pub type PersistentRootedFunction = PersistentRooted<*mut JSFunction>;
pub type PersistentRootedId = PersistentRooted<jsid>;
pub type PersistentRootedObject = PersistentRooted<*mut JSObject>;
pub type PersistentRootedScript = PersistentRooted<*mut JSScript>;
pub type PersistentRootedString = PersistentRooted<*mut JSString>;
pub type PersistentRootedSymbol = PersistentRooted<*mut Symbol>;
pub type PersistentRootedValue = PersistentRooted<Value>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AllocFunction { Malloc = 0, Calloc = 1, Realloc = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SystemAllocPolicy;
impl ::std::clone::Clone for SystemAllocPolicy {
    fn clone(&self) -> Self { *self }
}
pub enum ExclusiveContext { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TempAllocPolicy {
    pub cx_: *mut ContextFriendFields,
}
impl ::std::clone::Clone for TempAllocPolicy {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TempAllocPolicy() {
    assert_eq!(::std::mem::size_of::<TempAllocPolicy>() , 8usize);
    assert_eq!(::std::mem::align_of::<TempAllocPolicy>() , 8usize);
}
extern "C" {
    fn _ZNK2js15TempAllocPolicy19reportAllocOverflowEv(this:
                                                           *mut TempAllocPolicy);
}
impl TempAllocPolicy {
    #[inline]
    pub unsafe fn reportAllocOverflow(&mut self) {
        _ZNK2js15TempAllocPolicy19reportAllocOverflowEv(&mut *self)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct LinkedListElement<T> {
    pub mNext: *mut LinkedListElement<T>,
    pub mPrev: *mut LinkedListElement<T>,
    pub mIsSentinel: bool,
}
pub const NODE_KIND_SENTINEL: LinkedListElement_NodeKind =
    LinkedListElement_NodeKind::NODE_KIND_NORMAL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum LinkedListElement_NodeKind { NODE_KIND_NORMAL = 0, }
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct LinkedList<T> {
    pub sentinel: LinkedListElement<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedList_Iterator<T> {
    pub mCurrent: *mut T,
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCleanLinkedList<T> {
    pub _base: LinkedList<T>,
}
pub enum LazyScript { }
pub enum JitCode { }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TraceKind {
    Object = 0,
    String = 1,
    Symbol = 2,
    Script = 3,
    Shape = 4,
    ObjectGroup = 5,
    Null = 6,
    BaseShape = 15,
    JitCode = 31,
    LazyScript = 47,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapTypeToTraceKind<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum RootKind {
    BaseShape = 0,
    JitCode = 1,
    LazyScript = 2,
    Object = 3,
    ObjectGroup = 4,
    Script = 5,
    Shape = 6,
    String = 7,
    Symbol = 8,
    Id = 9,
    Value = 10,
    Traceable = 11,
    Limit = 12,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapTypeToRootKind<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
pub type AutoIdVector = AutoVectorRooter<jsid>;
pub const JSVERSION_LATEST: JSVersion = JSVersion::JSVERSION_ECMA_5;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSVersion {
    JSVERSION_ECMA_3 = 148,
    JSVERSION_1_6 = 160,
    JSVERSION_1_7 = 170,
    JSVERSION_1_8 = 180,
    JSVERSION_ECMA_5 = 185,
    JSVERSION_DEFAULT = 0,
    JSVERSION_UNKNOWN = -1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSType {
    JSTYPE_VOID = 0,
    JSTYPE_OBJECT = 1,
    JSTYPE_FUNCTION = 2,
    JSTYPE_STRING = 3,
    JSTYPE_NUMBER = 4,
    JSTYPE_BOOLEAN = 5,
    JSTYPE_NULL = 6,
    JSTYPE_SYMBOL = 7,
    JSTYPE_LIMIT = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSProtoKey {
    JSProto_Null = 0,
    JSProto_Object = 1,
    JSProto_Function = 2,
    JSProto_Array = 3,
    JSProto_Boolean = 4,
    JSProto_JSON = 5,
    JSProto_Date = 6,
    JSProto_Math = 7,
    JSProto_Number = 8,
    JSProto_String = 9,
    JSProto_RegExp = 10,
    JSProto_Error = 11,
    JSProto_InternalError = 12,
    JSProto_EvalError = 13,
    JSProto_RangeError = 14,
    JSProto_ReferenceError = 15,
    JSProto_SyntaxError = 16,
    JSProto_TypeError = 17,
    JSProto_URIError = 18,
    JSProto_DebuggeeWouldRun = 19,
    JSProto_Iterator = 20,
    JSProto_StopIteration = 21,
    JSProto_ArrayBuffer = 22,
    JSProto_Int8Array = 23,
    JSProto_Uint8Array = 24,
    JSProto_Int16Array = 25,
    JSProto_Uint16Array = 26,
    JSProto_Int32Array = 27,
    JSProto_Uint32Array = 28,
    JSProto_Float32Array = 29,
    JSProto_Float64Array = 30,
    JSProto_Uint8ClampedArray = 31,
    JSProto_Proxy = 32,
    JSProto_WeakMap = 33,
    JSProto_Map = 34,
    JSProto_Set = 35,
    JSProto_DataView = 36,
    JSProto_Symbol = 37,
    JSProto_SharedArrayBuffer = 38,
    JSProto_Intl = 39,
    JSProto_TypedObject = 40,
    JSProto_Reflect = 41,
    JSProto_SIMD = 42,
    JSProto_WeakSet = 43,
    JSProto_TypedArray = 44,
    JSProto_Atomics = 45,
    JSProto_SavedFrame = 46,
    JSProto_Wasm = 47,
    JSProto_Promise = 48,
    JSProto_LIMIT = 49,
}
pub enum JSCompartment { }
pub enum JSCrossCompartmentCall { }
pub enum JSExceptionState { }
pub enum JSObjectMap { }
pub enum JSPropertyName { }
pub enum JSRuntime { }
pub enum JSStructuredCloneReader { }
pub enum JSStructuredCloneWriter { }
pub enum JSFlatString { }
pub enum PRCallOnceType { }
pub type JSCallOnceType = PRCallOnceType;
pub type JSInitCallback =
    ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type JSConstDoubleSpec = JSConstScalarSpec<f64>;
pub type JSConstIntegerSpec = JSConstScalarSpec<::std::os::raw::c_int>;
pub type JSTraceDataOp =
    ::std::option::Option<unsafe extern "C" fn(trc: *mut JSTracer,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub enum AutoTraceSession { }
pub enum StoreBuffer { }
pub type OffThreadCompileCallback =
    ::std::option::Option<unsafe extern "C" fn(token:
                                                   *mut ::std::os::raw::c_void,
                                               callbackData:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum HeapState {
    Idle = 0,
    Tracing = 1,
    MajorCollecting = 2,
    MinorCollecting = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Runtime {
    pub heapState_: HeapState,
    pub gcStoreBufferPtr_: *mut StoreBuffer,
}
impl ::std::clone::Clone for Runtime {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Runtime() {
    assert_eq!(::std::mem::size_of::<Runtime>() , 16usize);
    assert_eq!(::std::mem::align_of::<Runtime>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoGCRooter {
    pub down: *mut AutoGCRooter,
    pub tag_: isize,
    pub stackTop: *mut *mut AutoGCRooter,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AutoGCRooter_jspubtd_h_unnamed_1 {
    VALARRAY = -2,
    PARSER = -3,
    VALVECTOR = -10,
    IDVECTOR = -11,
    OBJVECTOR = -14,
    IONMASM = -19,
    WRAPVECTOR = -20,
    WRAPPER = -21,
    CUSTOM = -26,
}
#[test]
fn bindgen_test_layout_AutoGCRooter() {
    assert_eq!(::std::mem::size_of::<AutoGCRooter>() , 24usize);
    assert_eq!(::std::mem::align_of::<AutoGCRooter>() , 8usize);
}
extern "C" {
    fn _ZN2JS12AutoGCRooter8traceAllEP8JSTracer(trc: *mut JSTracer);
    fn _ZN2JS12AutoGCRooter16traceAllWrappersEP8JSTracer(trc: *mut JSTracer);
}
impl AutoGCRooter {
    #[inline]
    pub unsafe fn traceAll(trc: *mut JSTracer) {
        _ZN2JS12AutoGCRooter8traceAllEP8JSTracer(trc)
    }
    #[inline]
    pub unsafe fn traceAllWrappers(trc: *mut JSTracer) {
        _ZN2JS12AutoGCRooter16traceAllWrappersEP8JSTracer(trc)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum StackKind {
    StackForSystemCode = 0,
    StackForTrustedScript = 1,
    StackForUntrustedScript = 2,
    StackKindCount = 3,
}
pub type RootedListHeads = ::std::os::raw::c_void;
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct RootLists {
    pub stackRoots_: [u64; 12usize],
    pub autoGCRooters_: *mut AutoGCRooter,
    pub heapRoots_: [u64; 36usize],
}
#[test]
fn bindgen_test_layout_RootLists() {
    assert_eq!(::std::mem::size_of::<RootLists>() , 392usize);
    assert_eq!(::std::mem::align_of::<RootLists>() , 8usize);
}
extern "C" {
    fn _ZN2js9RootLists15traceStackRootsEP8JSTracer(this: *mut RootLists,
                                                    trc: *mut JSTracer);
    fn _ZN2js9RootLists16checkNoGCRootersEv(this: *mut RootLists);
    fn _ZN2js9RootLists20tracePersistentRootsEP8JSTracer(this: *mut RootLists,
                                                         trc: *mut JSTracer);
    fn _ZN2js9RootLists21finishPersistentRootsEv(this: *mut RootLists);
}
impl RootLists {
    #[inline]
    pub unsafe fn traceStackRoots(&mut self, trc: *mut JSTracer) {
        _ZN2js9RootLists15traceStackRootsEP8JSTracer(&mut *self, trc)
    }
    #[inline]
    pub unsafe fn checkNoGCRooters(&mut self) {
        _ZN2js9RootLists16checkNoGCRootersEv(&mut *self)
    }
    #[inline]
    pub unsafe fn tracePersistentRoots(&mut self, trc: *mut JSTracer) {
        _ZN2js9RootLists20tracePersistentRootsEP8JSTracer(&mut *self, trc)
    }
    #[inline]
    pub unsafe fn finishPersistentRoots(&mut self) {
        _ZN2js9RootLists21finishPersistentRootsEv(&mut *self)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ContextFriendFields {
    pub runtime_: *mut JSRuntime,
    pub compartment_: *mut JSCompartment,
    pub zone_: *mut Zone,
    pub roots: RootLists,
}
#[test]
fn bindgen_test_layout_ContextFriendFields() {
    assert_eq!(::std::mem::size_of::<ContextFriendFields>() , 416usize);
    assert_eq!(::std::mem::align_of::<ContextFriendFields>() , 8usize);
}
pub enum PerThreadData { }
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct PerThreadDataFriendFields {
    pub roots: RootLists,
    pub nativeStackLimit: [usize; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PerThreadDataFriendFields_RuntimeDummy {
    pub _base: Runtime,
    pub mainThread: PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy {
    pub field1: *mut ::std::os::raw::c_void,
    pub field2: usize,
    pub field3: u64,
}
impl ::std::clone::Clone for
 PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy() {
    assert_eq!(::std::mem::size_of::<PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy>()
               , 24usize);
    assert_eq!(::std::mem::align_of::<PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy>()
               , 8usize);
}
impl ::std::clone::Clone for PerThreadDataFriendFields_RuntimeDummy {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PerThreadDataFriendFields_RuntimeDummy() {
    assert_eq!(::std::mem::size_of::<PerThreadDataFriendFields_RuntimeDummy>()
               , 40usize);
    assert_eq!(::std::mem::align_of::<PerThreadDataFriendFields_RuntimeDummy>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_PerThreadDataFriendFields() {
    assert_eq!(::std::mem::size_of::<PerThreadDataFriendFields>() , 416usize);
    assert_eq!(::std::mem::align_of::<PerThreadDataFriendFields>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MallocAllocPolicy;
impl ::std::clone::Clone for MallocAllocPolicy {
    fn clone(&self) -> Self { *self }
}
pub enum VectorTesting { }
pub enum Cell { }
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct Zone {
    pub runtime_: *mut JSRuntime,
    pub barrierTracer_: *mut JSTracer,
    pub stackRoots_: [u64; 12usize],
    pub needsIncrementalBarrier_: bool,
}
#[test]
fn bindgen_test_layout_Zone() {
    assert_eq!(::std::mem::size_of::<Zone>() , 120usize);
    assert_eq!(::std::mem::align_of::<Zone>() , 8usize);
}
/**
 * A GC pointer, tagged with the trace kind.
 *
 * In general, a GC pointer should be stored with an exact type. This class
 * is for use when that is not possible because a single pointer must point
 * to several kinds of GC thing.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GCCellPtr {
    pub ptr: usize,
}
impl ::std::clone::Clone for GCCellPtr {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GCCellPtr() {
    assert_eq!(::std::mem::size_of::<GCCellPtr>() , 8usize);
    assert_eq!(::std::mem::align_of::<GCCellPtr>() , 8usize);
}
extern "C" {
    fn _ZNK2JS9GCCellPtr24mayBeOwnedByOtherRuntimeEv(this: *mut GCCellPtr)
     -> bool;
}
impl GCCellPtr {
    #[inline]
    pub unsafe fn mayBeOwnedByOtherRuntime(&mut self) -> bool {
        _ZNK2JS9GCCellPtr24mayBeOwnedByOtherRuntimeEv(&mut *self)
    }
}
pub enum GCRuntime { }
pub enum Statistics { }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCMode {
    JSGC_MODE_GLOBAL = 0,
    JSGC_MODE_COMPARTMENT = 1,
    JSGC_MODE_INCREMENTAL = 2,
}
/**
 * Kinds of js_GC invocation.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCInvocationKind { GC_NORMAL = 0, GC_SHRINK = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Reason {
    API = 0,
    EAGER_ALLOC_TRIGGER = 1,
    DESTROY_RUNTIME = 2,
    UNUSED0 = 3,
    LAST_DITCH = 4,
    TOO_MUCH_MALLOC = 5,
    ALLOC_TRIGGER = 6,
    DEBUG_GC = 7,
    COMPARTMENT_REVIVED = 8,
    RESET = 9,
    OUT_OF_NURSERY = 10,
    EVICT_NURSERY = 11,
    FULL_STORE_BUFFER = 12,
    SHARED_MEMORY_LIMIT = 13,
    PERIODIC_FULL_GC = 14,
    INCREMENTAL_TOO_SLOW = 15,
    ABORT_GC = 16,
    RESERVED0 = 17,
    RESERVED1 = 18,
    RESERVED2 = 19,
    RESERVED3 = 20,
    RESERVED4 = 21,
    RESERVED5 = 22,
    RESERVED6 = 23,
    RESERVED7 = 24,
    RESERVED8 = 25,
    RESERVED9 = 26,
    RESERVED10 = 27,
    RESERVED11 = 28,
    RESERVED12 = 29,
    RESERVED13 = 30,
    RESERVED14 = 31,
    RESERVED15 = 32,
    DOM_WINDOW_UTILS = 33,
    COMPONENT_UTILS = 34,
    MEM_PRESSURE = 35,
    CC_WAITING = 36,
    CC_FORCED = 37,
    LOAD_END = 38,
    POST_COMPARTMENT = 39,
    PAGE_HIDE = 40,
    NSJSCONTEXT_DESTROY = 41,
    SET_NEW_DOCUMENT = 42,
    SET_DOC_SHELL = 43,
    DOM_UTILS = 44,
    DOM_IPC = 45,
    DOM_WORKER = 46,
    INTER_SLICE_GC = 47,
    REFRESH_FRAME = 48,
    FULL_GC_TIMER = 49,
    SHUTDOWN_CC = 50,
    FINISH_LARGE_EVALUATE = 51,
    USER_INACTIVE = 52,
    XPCONNECT_SHUTDOWN = 53,
    NO_REASON = 54,
    NUM_REASONS = 55,
    NUM_TELEMETRY_REASONS = 100,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum GCProgress {
    GC_CYCLE_BEGIN = 0,
    GC_SLICE_BEGIN = 1,
    GC_SLICE_END = 2,
    GC_CYCLE_END = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GCDescription {
    pub isCompartment_: bool,
    pub invocationKind_: JSGCInvocationKind,
    pub reason_: Reason,
}
impl ::std::clone::Clone for GCDescription {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GCDescription() {
    assert_eq!(::std::mem::size_of::<GCDescription>() , 12usize);
    assert_eq!(::std::mem::align_of::<GCDescription>() , 4usize);
}
extern "C" {
    fn _ZNK2JS13GCDescription18formatSliceMessageEP9JSRuntime(this:
                                                                  *mut GCDescription,
                                                              rt:
                                                                  *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort;
    fn _ZNK2JS13GCDescription20formatSummaryMessageEP9JSRuntime(this:
                                                                    *mut GCDescription,
                                                                rt:
                                                                    *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort;
    fn _ZNK2JS13GCDescription10formatJSONEP9JSRuntimey(this:
                                                           *mut GCDescription,
                                                       rt: *mut JSRuntime,
                                                       timestamp: u64)
     -> *mut ::std::os::raw::c_ushort;
}
impl GCDescription {
    #[inline]
    pub unsafe fn formatSliceMessage(&mut self, rt: *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort {
        _ZNK2JS13GCDescription18formatSliceMessageEP9JSRuntime(&mut *self, rt)
    }
    #[inline]
    pub unsafe fn formatSummaryMessage(&mut self, rt: *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort {
        _ZNK2JS13GCDescription20formatSummaryMessageEP9JSRuntime(&mut *self,
                                                                 rt)
    }
    #[inline]
    pub unsafe fn formatJSON(&mut self, rt: *mut JSRuntime, timestamp: u64)
     -> *mut ::std::os::raw::c_ushort {
        _ZNK2JS13GCDescription10formatJSONEP9JSRuntimey(&mut *self, rt,
                                                        timestamp)
    }
}
pub type GCSliceCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               progress: GCProgress,
                                               desc: *const GCDescription)>;
/**
 * Describes the progress of an observed nursery collection.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum GCNurseryProgress {
    GC_NURSERY_COLLECTION_START = 0,
    GC_NURSERY_COLLECTION_END = 1,
}
/**
 * A nursery collection callback receives the progress of the nursery collection
 * and the reason for the collection.
 */
pub type GCNurseryCollectionCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               progress: GCNurseryProgress,
                                               reason: Reason)>;
/** Ensure that generational GC is disabled within some scope. */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoDisableGenerationalGC {
    pub gc: *mut GCRuntime,
}
#[test]
fn bindgen_test_layout_AutoDisableGenerationalGC() {
    assert_eq!(::std::mem::size_of::<AutoDisableGenerationalGC>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoDisableGenerationalGC>() , 8usize);
}
/**
 * Assert if a GC occurs while this class is live. This class does not disable
 * the static rooting hazard analysis.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoAssertOnGC;
/**
 * Assert if an allocation of a GC thing occurs while this class is live. This
 * class does not disable the static rooting hazard analysis.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoAssertNoAlloc {
    pub gc: *mut GCRuntime,
}
#[test]
fn bindgen_test_layout_AutoAssertNoAlloc() {
    assert_eq!(::std::mem::size_of::<AutoAssertNoAlloc>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoAssertNoAlloc>() , 8usize);
}
extern "C" {
    fn _ZN2JS17AutoAssertNoAlloc13disallowAllocEP9JSRuntime(this:
                                                                *mut AutoAssertNoAlloc,
                                                            rt:
                                                                *mut JSRuntime);
}
impl AutoAssertNoAlloc {
    #[inline]
    pub unsafe fn disallowAlloc(&mut self, rt: *mut JSRuntime) {
        _ZN2JS17AutoAssertNoAlloc13disallowAllocEP9JSRuntime(&mut *self, rt)
    }
}
/**
 * Disable the static rooting hazard analysis in the live region and assert if
 * any allocation that could potentially trigger a GC occurs while this guard
 * object is live. This is most useful to help the exact rooting hazard analysis
 * in complex regions, since it cannot understand dataflow.
 *
 * Note: GC behavior is unpredictable even when deterministic and is generally
 *       non-deterministic in practice. The fact that this guard has not
 *       asserted is not a guarantee that a GC cannot happen in the guarded
 *       region. As a rule, anyone performing a GC unsafe action should
 *       understand the GC properties of all code in that region and ensure
 *       that the hazard analysis is correct for that code, rather than relying
 *       on this class.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSuppressGCAnalysis {
    pub _base: AutoAssertNoAlloc,
}
#[test]
fn bindgen_test_layout_AutoSuppressGCAnalysis() {
    assert_eq!(::std::mem::size_of::<AutoSuppressGCAnalysis>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoSuppressGCAnalysis>() , 8usize);
}
#[repr(C)]
pub struct AutoAssertGCCallback {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_AutoAssertGCCallback() {
    assert_eq!(::std::mem::size_of::<AutoAssertGCCallback>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoAssertGCCallback>() , 8usize);
}
/**
 * Place AutoCheckCannotGC in scopes that you believe can never GC. These
 * annotations will be verified both dynamically via AutoAssertOnGC, and
 * statically with the rooting hazard analysis (implemented by making the
 * analysis consider AutoCheckCannotGC to be a GC pointer, and therefore
 * complain if it is live across a GC call.) It is useful when dealing with
 * internal pointers to GC things where the GC thing itself may not be present
 * for the static analysis: e.g. acquiring inline chars from a JSString* on the
 * heap.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCheckCannotGC {
    pub _base: AutoAssertOnGC,
}
/**
 * Opaque<T> is a replacement for integral T in cases where only comparisons
 * must be supported, and it's desirable to prevent accidental dependency on
 * exact values.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Opaque<T> {
    pub mValue: T,
}
/*****************************************************************************/
pub type Generation = Opaque<::std::os::raw::c_ulonglong>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CStringHasher;
impl ::std::clone::Clone for CStringHasher {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashMapEntry<Key, Value> {
    pub key_: Key,
    pub value_: Value,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum WeakMapTraceKind {
    DoNotTraceWeakMaps = 0,
    ExpandWeakMaps = 1,
    TraceWeakMapValues = 2,
    TraceWeakMapKeysValues = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSTracer {
    pub runtime_: *mut JSRuntime,
    pub weakMapAction_: WeakMapTraceKind,
    pub tag_: JSTracer_TracerKindTag,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSTracer_TracerKindTag {
    Marking = 0,
    WeakMarking = 1,
    Tenuring = 2,
    Callback = 3,
}
impl ::std::clone::Clone for JSTracer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSTracer() {
    assert_eq!(::std::mem::size_of::<JSTracer>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSTracer>() , 8usize);
}
pub enum AutoTracingCallback { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallbackTracer {
    pub _vftable: *const _vftable_CallbackTracer,
    pub _base: JSTracer,
    pub contextName_: *const ::std::os::raw::c_char,
    pub contextIndex_: usize,
    pub contextFunctor_: *mut CallbackTracer_ContextFunctor,
}
#[repr(C)]
pub struct _vftable_CallbackTracer {
    pub onChild: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                      thing: *const GCCellPtr),
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallbackTracer_ContextFunctor {
    pub _vftable: *const _vftable_CallbackTracer_ContextFunctor,
}
#[repr(C)]
pub struct _vftable_CallbackTracer_ContextFunctor {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for CallbackTracer_ContextFunctor {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CallbackTracer_ContextFunctor() {
    assert_eq!(::std::mem::size_of::<CallbackTracer_ContextFunctor>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<CallbackTracer_ContextFunctor>() ,
               8usize);
}
impl ::std::clone::Clone for CallbackTracer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CallbackTracer() {
    assert_eq!(::std::mem::size_of::<CallbackTracer>() , 48usize);
    assert_eq!(::std::mem::align_of::<CallbackTracer>() , 8usize);
}
extern "C" {
    fn _ZN2JS14CallbackTracer18getTracingEdgeNameEPcy(this:
                                                          *mut CallbackTracer,
                                                      buffer:
                                                          *mut ::std::os::raw::c_char,
                                                      bufferSize: usize);
}
impl CallbackTracer {
    #[inline]
    pub unsafe fn getTracingEdgeName(&mut self,
                                     buffer: *mut ::std::os::raw::c_char,
                                     bufferSize: usize) {
        _ZN2JS14CallbackTracer18getTracingEdgeNameEPcy(&mut *self, buffer,
                                                       bufferSize)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoTracingName {
    pub trc_: *mut CallbackTracer,
    pub prior_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AutoTracingName() {
    assert_eq!(::std::mem::size_of::<AutoTracingName>() , 16usize);
    assert_eq!(::std::mem::align_of::<AutoTracingName>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoTracingIndex {
    pub trc_: *mut CallbackTracer,
}
#[test]
fn bindgen_test_layout_AutoTracingIndex() {
    assert_eq!(::std::mem::size_of::<AutoTracingIndex>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoTracingIndex>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoTracingDetails {
    pub trc_: *mut CallbackTracer,
}
#[test]
fn bindgen_test_layout_AutoTracingDetails() {
    assert_eq!(::std::mem::size_of::<AutoTracingDetails>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoTracingDetails>() , 8usize);
}
pub enum JSAtom { }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StructGCPolicy<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GCPolicy<T> {
    pub _base: StructGCPolicy<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IgnoreGCPolicy<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GCPointerPolicy<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BarrierMethods<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootedBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HandleBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutableHandleBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PersistentRootedBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PersistentRootedMarker<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
/**
 * The TenuredHeap<T> class is similar to the Heap<T> class above in that it
 * encapsulates the GC concerns of an on-heap reference to a JS object. However,
 * it has two important differences:
 *
 *  1) Pointers which are statically known to only reference "tenured" objects
 *     can avoid the extra overhead of SpiderMonkey's write barriers.
 *
 *  2) Objects in the "tenured" heap have stronger alignment restrictions than
 *     those in the "nursery", so it is possible to store flags in the lower
 *     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
 *     pointer with a nice API for accessing the flag bits and adds various
 *     assertions to ensure that it is not mis-used.
 *
 * GC things are said to be "tenured" when they are located in the long-lived
 * heap: e.g. they have gained tenure as an object by surviving past at least
 * one GC. For performance, SpiderMonkey allocates some things which are known
 * to normally be long lived directly into the tenured generation; for example,
 * global objects. Additionally, SpiderMonkey does not visit individual objects
 * when deleting non-tenured objects, so object with finalizers are also always
 * tenured; for instance, this includes most DOM objects.
 *
 * The considerations to keep in mind when using a TenuredHeap<T> vs a normal
 * Heap<T> are:
 *
 *  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
 *  - It is however valid for a Heap<T> to refer to a tenured thing.
 *  - It is not possible to store flag bits in a Heap<T>.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TenuredHeap<T> {
    pub _base: HeapBase<T>,
    pub bits: usize,
}
pub const flagsMask: TenuredHeap_RootingAPI_h_unnamed_4 =
    TenuredHeap_RootingAPI_h_unnamed_4::maskBits;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TenuredHeap_RootingAPI_h_unnamed_4 { maskBits = 0, }
/**
 * Reference to a T that has been rooted elsewhere. This is most useful
 * as a parameter type, which guarantees that the T lvalue is properly
 * rooted. See "Move GC Stack Rooting" above.
 *
 * If you want to add additional methods to Handle for a specific
 * specialization, define a HandleBase<T> specialization containing them.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Handle<T> {
    pub _base: HandleBase<T>,
    pub ptr: *const T,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Handle_Disambiguator { DeliberatelyChoosingThisOverload = 0, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Handle_CallerIdentity {
    ImUsingThisOnlyInFromFromMarkedLocation = 0,
}
/**
 * Similar to a handle, but the underlying storage can be changed. This is
 * useful for outparams.
 *
 * If you want to add additional methods to MutableHandle for a specific
 * specialization, define a MutableHandleBase<T> specialization containing
 * them.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutableHandle<T> {
    pub _base: MutableHandleBase<T>,
    pub ptr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MovableCellHasher<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DispatchWrapper<T> {
    pub tracer: ::std::option::Option<unsafe extern "C" fn()>,
    pub storage: T,
}
/**
 * Local variable of type T whose value is always rooted. This is typically
 * used for local variables, or for non-rooted values being passed to a
 * function that requires a handle, e.g. Foo(Root<T>(cx, x)).
 *
 * If you want to add additional methods to Rooted for a specific
 * specialization, define a RootedBase<T> specialization containing them.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct Rooted<T> {
    pub _base: RootedBase<T>,
    pub stack: *mut *mut Rooted<*mut ::std::os::raw::c_void>,
    pub prev: *mut Rooted<*mut ::std::os::raw::c_void>,
    pub ptr: T,
}
/** Interface substitute for Rooted<T> which does not root the variable's memory. */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FakeRooted<T> {
    pub _base: RootedBase<T>,
    pub ptr: T,
}
/** Interface substitute for MutableHandle<T> which is not required to point to rooted memory. */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FakeMutableHandle<T> {
    pub _base: MutableHandleBase<T>,
    pub ptr: *mut T,
}
/**
 * Types for a variable that either should or shouldn't be rooted, depending on
 * the template parameter allowGC. Used for implementing functions that can
 * operate on either rooted or unrooted data.
 *
 * The toHandle() and toMutableHandle() functions are for calling functions
 * which require handle types and are only called in the CanGC case. These
 * allow the calling code to type check.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AllowGC { NoGC = 0, CanGC = 1, }
/**
 * A copyable, assignable global GC root type with arbitrary lifetime, an
 * infallible constructor, and automatic unrooting on destruction.
 *
 * These roots can be used in heap-allocated data structures, so they are not
 * associated with any particular JSContext or stack. They are registered with
 * the JSRuntime itself, without locking, so they require a full JSContext to be
 * initialized, not one of its more restricted superclasses. Initialization may
 * take place on construction, or in two phases if the no-argument constructor
 * is called followed by init().
 *
 * Note that you must not use an PersistentRooted in an object owned by a JS
 * object:
 *
 * Whenever one object whose lifetime is decided by the GC refers to another
 * such object, that edge must be traced only if the owning JS object is traced.
 * This applies not only to JS objects (which obviously are managed by the GC)
 * but also to C++ objects owned by JS objects.
 *
 * If you put a PersistentRooted in such a C++ object, that is almost certainly
 * a leak. When a GC begins, the referent of the PersistentRooted is treated as
 * live, unconditionally (because a PersistentRooted is a *root*), even if the
 * JS object that owns it is unreachable. If there is any path from that
 * referent back to the JS object, then the C++ object containing the
 * PersistentRooted will not be destructed, and the whole blob of objects will
 * not be freed, even if there are no references to them from the outside.
 *
 * In the context of Firefox, this is a severe restriction: almost everything in
 * Firefox is owned by some JS object or another, so using PersistentRooted in
 * such objects would introduce leaks. For these kinds of edges, Heap<T> or
 * TenuredHeap<T> would be better types. It's up to the implementor of the type
 * containing Heap<T> or TenuredHeap<T> members to make sure their referents get
 * marked when the object itself is marked.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct PersistentRooted<T> {
    pub _base: PersistentRootedBase<T>,
    pub _base1: LinkedListElement<T>,
    pub ptr: T,
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ObjectPtr {
    pub value: Heap<*mut JSObject>,
}
#[test]
fn bindgen_test_layout_ObjectPtr() {
    assert_eq!(::std::mem::size_of::<ObjectPtr>() , 8usize);
    assert_eq!(::std::mem::align_of::<ObjectPtr>() , 8usize);
}
extern "C" {
    fn _ZN2JS9ObjectPtr24updateWeakPointerAfterGCEv(this: *mut ObjectPtr);
    fn _ZN2JS9ObjectPtr5traceEP8JSTracerPKc(this: *mut ObjectPtr,
                                            trc: *mut JSTracer,
                                            name:
                                                *const ::std::os::raw::c_char);
}
impl ObjectPtr {
    #[inline]
    pub unsafe fn updateWeakPointerAfterGC(&mut self) {
        _ZN2JS9ObjectPtr24updateWeakPointerAfterGCEv(&mut *self)
    }
    #[inline]
    pub unsafe fn trace(&mut self, trc: *mut JSTracer,
                        name: *const ::std::os::raw::c_char) {
        _ZN2JS9ObjectPtr5traceEP8JSTracerPKc(&mut *self, trc, name)
    }
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSValueType {
    JSVAL_TYPE_DOUBLE = 0,
    JSVAL_TYPE_INT32 = 1,
    JSVAL_TYPE_UNDEFINED = 2,
    JSVAL_TYPE_BOOLEAN = 3,
    JSVAL_TYPE_MAGIC = 4,
    JSVAL_TYPE_STRING = 5,
    JSVAL_TYPE_SYMBOL = 6,
    JSVAL_TYPE_PRIVATE_GCTHING = 7,
    JSVAL_TYPE_NULL = 8,
    JSVAL_TYPE_OBJECT = 12,
    JSVAL_TYPE_UNKNOWN = 32,
    JSVAL_TYPE_MISSING = 33,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSValueTag {
    JSVAL_TAG_MAX_DOUBLE = 131056,
    JSVAL_TAG_INT32 = 131057,
    JSVAL_TAG_UNDEFINED = 131058,
    JSVAL_TAG_STRING = 131061,
    JSVAL_TAG_SYMBOL = 131062,
    JSVAL_TAG_BOOLEAN = 131059,
    JSVAL_TAG_MAGIC = 131060,
    JSVAL_TAG_NULL = 131064,
    JSVAL_TAG_OBJECT = 131068,
    JSVAL_TAG_PRIVATE_GCTHING = 131063,
}
#[repr(u64)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSValueShiftedTag {
    JSVAL_SHIFTED_TAG_MAX_DOUBLE = 18444492278190833663,
    JSVAL_SHIFTED_TAG_INT32 = 18444633011384221696,
    JSVAL_SHIFTED_TAG_UNDEFINED = 18444773748872577024,
    JSVAL_SHIFTED_TAG_STRING = 18445195961337643008,
    JSVAL_SHIFTED_TAG_SYMBOL = 18445336698825998336,
    JSVAL_SHIFTED_TAG_BOOLEAN = 18444914486360932352,
    JSVAL_SHIFTED_TAG_MAGIC = 18445055223849287680,
    JSVAL_SHIFTED_TAG_NULL = 18445618173802708992,
    JSVAL_SHIFTED_TAG_OBJECT = 18446181123756130304,
    JSVAL_SHIFTED_TAG_PRIVATE_GCTHING = 18445477436314353664,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSWhyMagic {
    JS_ELEMENTS_HOLE = 0,
    JS_NO_ITER_VALUE = 1,
    JS_GENERATOR_CLOSING = 2,
    JS_NO_CONSTANT = 3,
    JS_THIS_POISON = 4,
    JS_ARG_POISON = 5,
    JS_SERIALIZE_NO_NODE = 6,
    JS_LAZY_ARGUMENTS = 7,
    JS_OPTIMIZED_ARGUMENTS = 8,
    JS_IS_CONSTRUCTING = 9,
    JS_BLOCK_NEEDS_CLONE = 10,
    JS_HASH_KEY_EMPTY = 11,
    JS_ION_ERROR = 12,
    JS_ION_BAILOUT = 13,
    JS_OPTIMIZED_OUT = 14,
    JS_UNINITIALIZED_LEXICAL = 15,
    JS_GENERIC_MAGIC = 16,
    JS_WHY_MAGIC_COUNT = 17,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout {
    pub asBits: __BindgenUnionField<u64>,
    pub s: __BindgenUnionField<jsval_layout_Value_h_unnamed_5>,
    pub asDouble: __BindgenUnionField<f64>,
    pub asPtr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub _bindgen_data_: u64,
}
impl jsval_layout {
    pub unsafe fn asBits(&mut self) -> *mut u64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s(&mut self) -> *mut jsval_layout_Value_h_unnamed_5 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asDouble(&mut self) -> *mut f64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asPtr(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for jsval_layout {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout() {
    assert_eq!(::std::mem::size_of::<jsval_layout>() , 8usize);
    assert_eq!(::std::mem::align_of::<jsval_layout>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_Value_h_unnamed_5 {
    pub payload: jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6 {
    pub i32: __BindgenUnionField<i32>,
    pub u32: __BindgenUnionField<u32>,
    pub why: __BindgenUnionField<JSWhyMagic>,
    pub _bindgen_data_: u32,
}
impl jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6 {
    pub unsafe fn i32(&mut self) -> *mut i32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn u32(&mut self) -> *mut u32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn why(&mut self) -> *mut JSWhyMagic {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6() {
    assert_eq!(::std::mem::size_of::<jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6>()
               , 4usize);
}
impl ::std::clone::Clone for jsval_layout_Value_h_unnamed_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_Value_h_unnamed_5() {
    assert_eq!(::std::mem::size_of::<jsval_layout_Value_h_unnamed_5>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_Value_h_unnamed_5>() ,
               4usize);
}
/**
 * JS::Value is the interface for a single JavaScript Engine value.  A few
 * general notes on JS::Value:
 *
 * - JS::Value has setX() and isX() members for X in
 *
 *     { Int32, Double, String, Symbol, Boolean, Undefined, Null, Object, Magic }
 *
 *   JS::Value also contains toX() for each of the non-singleton types.
 *
 * - Magic is a singleton type whose payload contains either a JSWhyMagic "reason" for
 *   the magic value or a uint32_t value. By providing JSWhyMagic values when
 *   creating and checking for magic values, it is possible to assert, at
 *   runtime, that only magic values with the expected reason flow through a
 *   particular value. For example, if cx->exception has a magic value, the
 *   reason must be JS_GENERATOR_CLOSING.
 *
 * - The JS::Value operations are preferred.  The JSVAL_* operations remain for
 *   compatibility; they may be removed at some point.  These operations mostly
 *   provide similar functionality.  But there are a few key differences.  One
 *   is that JS::Value gives null a separate type.
 *   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
 *   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
 *   JSObject&.)  A convenience member Value::setObjectOrNull is provided.
 *
 * - JSVAL_VOID is the same as the singleton value of the Undefined type.
 *
 * - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
 *   32-bit user code should avoid copying jsval/JS::Value as much as possible,
 *   preferring to pass by const Value&.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Value {
    pub data: jsval_layout,
}
impl ::std::clone::Clone for Value {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(::std::mem::size_of::<Value>() , 8usize);
    assert_eq!(::std::mem::align_of::<Value>() , 8usize);
}
/**
 * A class designed for CRTP use in implementing the non-mutating parts of the
 * Value interface in Value-like classes.  Outer must be a class inheriting
 * ValueOperations<Outer> with a visible get() method returning a const
 * reference to the Value abstracted by Outer.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueOperations<Outer> {
    pub _phantom0: ::std::marker::PhantomData<Outer>,
}
/**
 * A class designed for CRTP use in implementing all the mutating parts of the
 * Value interface in Value-like classes.  Outer must be a class inheriting
 * MutableValueOperations<Outer> with visible get() methods returning const and
 * non-const references to the Value abstracted by Outer.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutableValueOperations<Outer> {
    pub _base: ValueOperations<Outer>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoidDefaultAdaptor<S> {
    pub _phantom0: ::std::marker::PhantomData<S>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IdentityDefaultAdaptor<S> {
    pub _phantom0: ::std::marker::PhantomData<S>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ValueAlignmentTester {
    pub c: ::std::os::raw::c_char,
    pub v: Value,
}
impl ::std::clone::Clone for ValueAlignmentTester {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ValueAlignmentTester() {
    assert_eq!(::std::mem::size_of::<ValueAlignmentTester>() , 16usize);
    assert_eq!(::std::mem::align_of::<ValueAlignmentTester>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LayoutAlignmentTester {
    pub c: ::std::os::raw::c_char,
    pub l: jsval_layout,
}
impl ::std::clone::Clone for LayoutAlignmentTester {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_LayoutAlignmentTester() {
    assert_eq!(::std::mem::size_of::<LayoutAlignmentTester>() , 16usize);
    assert_eq!(::std::mem::align_of::<LayoutAlignmentTester>() , 8usize);
}
pub type JSNative =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               argc: ::std::os::raw::c_uint,
                                               vp: *mut Value) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IncludeUsedRval {
    pub usedRval_: bool,
}
impl ::std::clone::Clone for IncludeUsedRval {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_IncludeUsedRval() {
    assert_eq!(::std::mem::size_of::<IncludeUsedRval>() , 1usize);
    assert_eq!(::std::mem::align_of::<IncludeUsedRval>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NoUsedRval;
impl ::std::clone::Clone for NoUsedRval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallArgsBase<WantUsedRval> {
    pub _base: WantUsedRval,
    pub argv_: *mut Value,
    pub argc_: ::std::os::raw::c_uint,
    pub constructing_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallArgs {
    pub _base: CallArgsBase<IncludeUsedRval>,
}
impl ::std::clone::Clone for CallArgs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    fn _ZNK2JS8CallArgs14requireAtLeastEP9JSContextPKcj(this: *mut CallArgs,
                                                        cx: *mut JSContext,
                                                        fnname:
                                                            *const ::std::os::raw::c_char,
                                                        required:
                                                            ::std::os::raw::c_uint)
     -> bool;
}
impl CallArgs {
    #[inline]
    pub unsafe fn requireAtLeast(&mut self, cx: *mut JSContext,
                                 fnname: *const ::std::os::raw::c_char,
                                 required: ::std::os::raw::c_uint) -> bool {
        _ZNK2JS8CallArgs14requireAtLeastEP9JSContextPKcj(&mut *self, cx,
                                                         fnname, required)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsid {
    pub asBits: usize,
}
impl ::std::clone::Clone for jsid {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsid() {
    assert_eq!(::std::mem::size_of::<jsid>() , 8usize);
    assert_eq!(::std::mem::align_of::<jsid>() , 8usize);
}
pub enum JSAtomState { }
pub enum FreeOp { }
/**
 * The answer to a successful query as to whether an object is an Array per
 * ES6's internal |IsArray| operation (as exposed by |Array.isArray|).
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum IsArrayAnswer { Array = 0, NotArray = 1, RevokedProxy = 2, }
/**
 * Per ES6, the [[DefineOwnProperty]] internal method has three different
 * possible outcomes:
 *
 * -   It can throw an exception (which we indicate by returning false).
 *
 * -   It can return true, indicating unvarnished success.
 *
 * -   It can return false, indicating "strict failure". The property could
 *     not be defined. It's an error, but no exception was thrown.
 *
 * It's not just [[DefineOwnProperty]]: all the mutating internal methods have
 * the same three outcomes. (The other affected internal methods are [[Set]],
 * [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)
 *
 * If you think this design is awful, you're not alone.  But as it's the
 * standard, we must represent these boolean "success" values somehow.
 * ObjectOpSuccess is the class for this. It's like a bool, but when it's false
 * it also stores an error code.
 *
 * Typical usage:
 *
 *     ObjectOpResult result;
 *     if (!DefineProperty(cx, obj, id, ..., result))
 *         return false;
 *     if (!result)
 *         return result.reportError(cx, obj, id);
 *
 * Users don't have to call `result.report()`; another possible ending is:
 *
 *     argv.rval().setBoolean(bool(result));
 *     return true;
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectOpResult {
    /**
     * code_ is either one of the special codes OkCode or Uninitialized, or
     * an error code. For now the error codes are private to the JS engine;
     * they're defined in js/src/js.msg.
     *
     * code_ is uintptr_t (rather than uint32_t) for the convenience of the
     * JITs, which would otherwise have to deal with either padding or stack
     * alignment on 64-bit platforms.
     */
    pub code_: usize,
}
#[repr(i64)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ObjectOpResult_SpecialCodes { OkCode = 0, Uninitialized = -1, }
impl ::std::clone::Clone for ObjectOpResult {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectOpResult() {
    assert_eq!(::std::mem::size_of::<ObjectOpResult>() , 8usize);
    assert_eq!(::std::mem::align_of::<ObjectOpResult>() , 8usize);
}
extern "C" {
    fn _ZN2JS14ObjectOpResult20failCantRedefinePropEv(this:
                                                          *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult12failReadOnlyEv(this: *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult14failGetterOnlyEv(this: *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult14failCantDeleteEv(this: *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult21failCantSetInterposedEv(this:
                                                           *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult27failCantDefineWindowElementEv(this:
                                                                 *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult27failCantDeleteWindowElementEv(this:
                                                                 *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult33failCantDeleteWindowNamedPropertyEv(this:
                                                                       *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult25failCantPreventExtensionsEv(this:
                                                               *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult16failCantSetProtoEv(this: *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult17failNoNamedSetterEv(this: *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult19failNoIndexedSetterEv(this:
                                                         *mut ObjectOpResult)
     -> bool;
    fn _ZN2JS14ObjectOpResult26reportStrictErrorOrWarningEP9JSContextNS_6HandleIP8JSObjectEENS3_I4jsidEEb(this:
                                                                                                              *mut ObjectOpResult,
                                                                                                          cx:
                                                                                                              *mut JSContext,
                                                                                                          obj:
                                                                                                              HandleObject,
                                                                                                          id:
                                                                                                              HandleId,
                                                                                                          strict:
                                                                                                              bool)
     -> bool;
    fn _ZN2JS14ObjectOpResult26reportStrictErrorOrWarningEP9JSContextNS_6HandleIP8JSObjectEEb(this:
                                                                                                  *mut ObjectOpResult,
                                                                                              cx:
                                                                                                  *mut JSContext,
                                                                                              obj:
                                                                                                  HandleObject,
                                                                                              strict:
                                                                                                  bool)
     -> bool;
}
impl ObjectOpResult {
    #[inline]
    pub unsafe fn failCantRedefineProp(&mut self) -> bool {
        _ZN2JS14ObjectOpResult20failCantRedefinePropEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failReadOnly(&mut self) -> bool {
        _ZN2JS14ObjectOpResult12failReadOnlyEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failGetterOnly(&mut self) -> bool {
        _ZN2JS14ObjectOpResult14failGetterOnlyEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDelete(&mut self) -> bool {
        _ZN2JS14ObjectOpResult14failCantDeleteEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantSetInterposed(&mut self) -> bool {
        _ZN2JS14ObjectOpResult21failCantSetInterposedEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDefineWindowElement(&mut self) -> bool {
        _ZN2JS14ObjectOpResult27failCantDefineWindowElementEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDeleteWindowElement(&mut self) -> bool {
        _ZN2JS14ObjectOpResult27failCantDeleteWindowElementEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDeleteWindowNamedProperty(&mut self) -> bool {
        _ZN2JS14ObjectOpResult33failCantDeleteWindowNamedPropertyEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantPreventExtensions(&mut self) -> bool {
        _ZN2JS14ObjectOpResult25failCantPreventExtensionsEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantSetProto(&mut self) -> bool {
        _ZN2JS14ObjectOpResult16failCantSetProtoEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failNoNamedSetter(&mut self) -> bool {
        _ZN2JS14ObjectOpResult17failNoNamedSetterEv(&mut *self)
    }
    #[inline]
    pub unsafe fn failNoIndexedSetter(&mut self) -> bool {
        _ZN2JS14ObjectOpResult19failNoIndexedSetterEv(&mut *self)
    }
    #[inline]
    pub unsafe fn reportStrictErrorOrWarning(&mut self, cx: *mut JSContext,
                                             obj: HandleObject, id: HandleId,
                                             strict: bool) -> bool {
        _ZN2JS14ObjectOpResult26reportStrictErrorOrWarningEP9JSContextNS_6HandleIP8JSObjectEENS3_I4jsidEEb(&mut *self,
                                                                                                           cx,
                                                                                                           obj,
                                                                                                           id,
                                                                                                           strict)
    }
    #[inline]
    pub unsafe fn reportStrictErrorOrWarning1(&mut self, cx: *mut JSContext,
                                              obj: HandleObject, strict: bool)
     -> bool {
        _ZN2JS14ObjectOpResult26reportStrictErrorOrWarningEP9JSContextNS_6HandleIP8JSObjectEEb(&mut *self,
                                                                                               cx,
                                                                                               obj,
                                                                                               strict)
    }
}
/**
 * Get a property named by id in obj.  Note the jsid id type -- id may
 * be a string (Unicode property identifier) or an int (element index).  The
 * *vp out parameter, on success, is the new property value after the action.
 */
pub type JSGetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               vp: MutableHandleValue)
                              -> bool>;
/** Add a property named by id to obj. */
pub type JSAddPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId, v: HandleValue)
                              -> bool>;
/**
 * Set a property named by id in obj, treating the assignment as strict
 * mode code if strict is true. Note the jsid id type -- id may be a string
 * (Unicode property identifier) or an int (element index). The *vp out
 * parameter, on success, is the new property value after the
 * set.
 */
pub type JSSetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               vp: MutableHandleValue,
                                               result: *mut ObjectOpResult)
                              -> bool>;
/**
 * Delete a property named by id in obj.
 *
 * If an error occurred, return false as per normal JSAPI error practice.
 *
 * If no error occurred, but the deletion attempt wasn't allowed (perhaps
 * because the property was non-configurable), call result.fail() and
 * return true.  This will cause |delete obj[id]| to evaluate to false in
 * non-strict mode code, and to throw a TypeError in strict mode code.
 *
 * If no error occurred and the deletion wasn't disallowed (this is *not* the
 * same as saying that a deletion actually occurred -- deleting a non-existent
 * property, or an inherited property, is allowed -- it's just pointless),
 * call result.succeed() and return true.
 */
pub type JSDeletePropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               result: *mut ObjectOpResult)
                              -> bool>;
/**
 * The type of ObjectOps::enumerate. This callback overrides a portion of
 * SpiderMonkey's default [[Enumerate]] internal method. When an ordinary object
 * is enumerated, that object and each object on its prototype chain is tested
 * for an enumerate op, and those ops are called in order. The properties each
 * op adds to the 'properties' vector are added to the set of values the for-in
 * loop will iterate over. All of this is nonstandard.
 *
 * An object is "enumerated" when it's the target of a for-in loop or
 * JS_Enumerate(). The callback's job is to populate 'properties' with the
 * object's property keys. If `enumerableOnly` is true, the callback should only
 * add enumerable properties.
 */
pub type JSNewEnumerateOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               properties: *mut AutoIdVector,
                                               enumerableOnly: bool) -> bool>;
/**
 * The old-style JSClass.enumerate op should define all lazy properties not
 * yet reflected in obj.
 */
pub type JSEnumerateOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject) -> bool>;
/**
 * The type of ObjectOps::funToString.  This callback allows an object to
 * provide a custom string to use when Function.prototype.toString is invoked on
 * that object.  A null return value means OOM.
 */
pub type JSFunToStringOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               indent: ::std::os::raw::c_uint)
                              -> *mut JSString>;
/**
 * Resolve a lazy property named by id in obj by defining it directly in obj.
 * Lazy properties are those reflected from some peer native property space
 * (e.g., the DOM attributes for a given node reflected as obj) on demand.
 *
 * JS looks for a property in an object, and if not found, tries to resolve
 * the given id. *resolvedp should be set to true iff the property was defined
 * on |obj|.
 */
pub type JSResolveOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               resolvedp: *mut bool) -> bool>;
/**
 * A class with a resolve hook can optionally have a mayResolve hook. This hook
 * must have no side effects and must return true for a given id if the resolve
 * hook may resolve this id. This is useful when we're doing a "pure" lookup: if
 * mayResolve returns false, we know we don't have to call the effectful resolve
 * hook.
 *
 * maybeObj, if non-null, is the object on which we're doing the lookup. This
 * can be nullptr: during JIT compilation we sometimes know the Class but not
 * the object.
 */
pub type JSMayResolveOp =
    ::std::option::Option<unsafe extern "C" fn(names: *const JSAtomState,
                                               id: jsid,
                                               maybeObj: *mut JSObject)
                              -> bool>;
/**
 * Finalize obj, which the garbage collector has determined to be unreachable
 * from other live objects or from GC roots.  Obviously, finalizers must never
 * store a reference to obj.
 */
pub type JSFinalizeOp =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut JSFreeOp,
                                               obj: *mut JSObject)>;
/** Finalizes external strings created by JS_NewExternalString. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSStringFinalizer {
    pub finalize: ::std::option::Option<unsafe extern "C" fn(fin:
                                                                 *const JSStringFinalizer,
                                                             chars:
                                                                 *mut ::std::os::raw::c_ushort)>,
}
impl ::std::clone::Clone for JSStringFinalizer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSStringFinalizer() {
    assert_eq!(::std::mem::size_of::<JSStringFinalizer>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSStringFinalizer>() , 8usize);
}
/**
 * Check whether v is an instance of obj.  Return false on error or exception,
 * true on success with true in *bp if v is an instance of obj, false in
 * *bp otherwise.
 */
pub type JSHasInstanceOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               vp: MutableHandleValue,
                                               bp: *mut bool) -> bool>;
/**
 * Function type for trace operation of the class called to enumerate all
 * traceable things reachable from obj's private data structure. For each such
 * thing, a trace implementation must call one of the JS_Call*Tracer variants
 * on the thing.
 *
 * JSTraceOp implementation can assume that no other threads mutates object
 * state. It must not change state of the object or corresponding native
 * structures. The only exception for this rule is the case when the embedding
 * needs a tight integration with GC. In that case the embedding can check if
 * the traversal is a part of the marking phase through calling
 * JS_IsGCMarkingTracer and apply a special code like emptying caches or
 * marking its native structures.
 */
pub type JSTraceOp =
    ::std::option::Option<unsafe extern "C" fn(trc: *mut JSTracer,
                                               obj: *mut JSObject)>;
pub type JSWeakmapKeyDelegateOp =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut JSObject)
                              -> *mut JSObject>;
pub type JSObjectMovedOp =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut JSObject,
                                               old: *const JSObject)>;
pub type LookupPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               objp: MutableHandleObject,
                                               propp:
                                                   MutableHandle<*mut Shape>)
                              -> bool>;
pub type DefinePropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               desc:
                                                   Handle<PropertyDescriptor>,
                                               result: *mut ObjectOpResult)
                              -> bool>;
pub type HasPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               foundp: *mut bool) -> bool>;
pub type GetPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               receiver: HandleValue,
                                               id: HandleId,
                                               vp: MutableHandleValue)
                              -> bool>;
pub type SetPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId, v: HandleValue,
                                               receiver: HandleValue,
                                               result: *mut ObjectOpResult)
                              -> bool>;
pub type GetOwnPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               desc:
                                                   MutableHandle<PropertyDescriptor>)
                              -> bool>;
pub type DeletePropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               result: *mut ObjectOpResult)
                              -> bool>;
pub type WatchOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               callable: HandleObject)
                              -> bool>;
pub type UnwatchOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId) -> bool>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct ElementAdder {
    pub resObj_: RootedObject,
    pub vp_: *mut Value,
    pub index_: u32,
    pub getBehavior_: ElementAdder_GetBehavior,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ElementAdder_GetBehavior {
    CheckHasElemPreserveHoles = 0,
    GetElement = 1,
}
#[test]
fn bindgen_test_layout_ElementAdder() {
    assert_eq!(::std::mem::size_of::<ElementAdder>() , 40usize);
    assert_eq!(::std::mem::align_of::<ElementAdder>() , 8usize);
}
extern "C" {
    fn _ZN2js12ElementAdder6appendEP9JSContextN2JS6HandleINS3_5ValueEEE(this:
                                                                            *mut ElementAdder,
                                                                        cx:
                                                                            *mut JSContext,
                                                                        v:
                                                                            HandleValue)
     -> bool;
    fn _ZN2js12ElementAdder10appendHoleEv(this: *mut ElementAdder);
}
impl ElementAdder {
    #[inline]
    pub unsafe fn append(&mut self, cx: *mut JSContext, v: HandleValue)
     -> bool {
        _ZN2js12ElementAdder6appendEP9JSContextN2JS6HandleINS3_5ValueEEE(&mut *self,
                                                                         cx,
                                                                         v)
    }
    #[inline]
    pub unsafe fn appendHole(&mut self) {
        _ZN2js12ElementAdder10appendHoleEv(&mut *self)
    }
}
pub type GetElementsOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject, begin: u32,
                                               end: u32,
                                               adder: *mut ElementAdder)
                              -> bool>;
pub type FinalizeOp =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut FreeOp,
                                               obj: *mut JSObject)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassOps {
    pub addProperty: JSAddPropertyOp,
    pub delProperty: JSDeletePropertyOp,
    pub getProperty: JSGetterOp,
    pub setProperty: JSSetterOp,
    pub enumerate: JSEnumerateOp,
    pub resolve: JSResolveOp,
    pub mayResolve: JSMayResolveOp,
    pub finalize: FinalizeOp,
    pub call: JSNative,
    pub hasInstance: JSHasInstanceOp,
    pub construct: JSNative,
    pub trace: JSTraceOp,
}
impl ::std::clone::Clone for ClassOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassOps() {
    assert_eq!(::std::mem::size_of::<ClassOps>() , 96usize);
    assert_eq!(::std::mem::align_of::<ClassOps>() , 8usize);
}
/** Callback for the creation of constructor and prototype objects. */
pub type ClassObjectCreationOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               key: JSProtoKey)
                              -> *mut JSObject>;
/** Callback for custom post-processing after class initialization via ClassSpec. */
pub type FinishClassInitOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               ctor: HandleObject,
                                               proto: HandleObject) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassSpec {
    pub createConstructor_: ClassObjectCreationOp,
    pub createPrototype_: ClassObjectCreationOp,
    pub constructorFunctions_: *const JSFunctionSpec,
    pub constructorProperties_: *const JSPropertySpec,
    pub prototypeFunctions_: *const JSFunctionSpec,
    pub prototypeProperties_: *const JSPropertySpec,
    pub finishInit_: FinishClassInitOp,
    pub flags: usize,
}
impl ::std::clone::Clone for ClassSpec {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassSpec() {
    assert_eq!(::std::mem::size_of::<ClassSpec>() , 64usize);
    assert_eq!(::std::mem::align_of::<ClassSpec>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassExtension {
    /**
     * If an object is used as a key in a weakmap, it may be desirable for the
     * garbage collector to keep that object around longer than it otherwise
     * would. A common case is when the key is a wrapper around an object in
     * another compartment, and we want to avoid collecting the wrapper (and
     * removing the weakmap entry) as long as the wrapped object is alive. In
     * that case, the wrapped object is returned by the wrapper's
     * weakmapKeyDelegateOp hook. As long as the wrapper is used as a weakmap
     * key, it will not be collected (and remain in the weakmap) until the
     * wrapped object is collected.
     */
    pub weakmapKeyDelegateOp: JSWeakmapKeyDelegateOp,
    /**
     * Optional hook called when an object is moved by a compacting GC.
     *
     * There may exist weak pointers to an object that are not traced through
     * when the normal trace APIs are used, for example objects in the wrapper
     * cache. This hook allows these pointers to be updated.
     *
     * Note that this hook can be called before JS_NewObject() returns if a GC
     * is triggered during construction of the object. This can happen for
     * global objects for example.
     */
    pub objectMovedOp: JSObjectMovedOp,
}
impl ::std::clone::Clone for ClassExtension {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassExtension() {
    assert_eq!(::std::mem::size_of::<ClassExtension>() , 16usize);
    assert_eq!(::std::mem::align_of::<ClassExtension>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectOps {
    pub lookupProperty: LookupPropertyOp,
    pub defineProperty: DefinePropertyOp,
    pub hasProperty: HasPropertyOp,
    pub getProperty: GetPropertyOp,
    pub setProperty: SetPropertyOp,
    pub getOwnPropertyDescriptor: GetOwnPropertyOp,
    pub deleteProperty: DeletePropertyOp,
    pub watch: WatchOp,
    pub unwatch: UnwatchOp,
    pub getElements: GetElementsOp,
    pub enumerate: JSNewEnumerateOp,
    pub funToString: JSFunToStringOp,
}
impl ::std::clone::Clone for ObjectOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectOps() {
    assert_eq!(::std::mem::size_of::<ObjectOps>() , 96usize);
    assert_eq!(::std::mem::align_of::<ObjectOps>() , 8usize);
}
pub type JSClassInternal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSClassOps {
    pub addProperty: JSAddPropertyOp,
    pub delProperty: JSDeletePropertyOp,
    pub getProperty: JSGetterOp,
    pub setProperty: JSSetterOp,
    pub enumerate: JSEnumerateOp,
    pub resolve: JSResolveOp,
    pub mayResolve: JSMayResolveOp,
    pub finalize: JSFinalizeOp,
    pub call: JSNative,
    pub hasInstance: JSHasInstanceOp,
    pub construct: JSNative,
    pub trace: JSTraceOp,
}
impl ::std::clone::Clone for JSClassOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSClassOps() {
    assert_eq!(::std::mem::size_of::<JSClassOps>() , 96usize);
    assert_eq!(::std::mem::align_of::<JSClassOps>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSClass {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub cOps: *const JSClassOps,
    pub reserved: [*mut ::std::os::raw::c_void; 3usize],
}
impl ::std::clone::Clone for JSClass {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSClass() {
    assert_eq!(::std::mem::size_of::<JSClass>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSClass>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Class {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub cOps: *const ClassOps,
    pub spec: *const ClassSpec,
    pub ext: *const ClassExtension,
    pub oOps: *const ObjectOps,
}
impl ::std::clone::Clone for Class {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Class() {
    assert_eq!(::std::mem::size_of::<Class>() , 48usize);
    assert_eq!(::std::mem::align_of::<Class>() , 8usize);
}
/**
 * Enumeration describing possible values of the [[Class]] internal property
 * value of objects.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ESClass {
    Object = 0,
    Array = 1,
    Number = 2,
    String = 3,
    Boolean = 4,
    RegExp = 5,
    ArrayBuffer = 6,
    SharedArrayBuffer = 7,
    Date = 8,
    Set = 9,
    Map = 10,
    Promise = 11,
    MapIterator = 12,
    SetIterator = 13,
    Arguments = 14,
    Error = 15,
    Other = 16,
}
pub const SCTAG_TMO_ALLOC_DATA: TransferableOwnership =
    TransferableOwnership::SCTAG_TMO_FIRST_OWNED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TransferableOwnership {
    SCTAG_TMO_UNFILLED = 0,
    SCTAG_TMO_UNOWNED = 1,
    SCTAG_TMO_FIRST_OWNED = 2,
    SCTAG_TMO_SHARED_BUFFER = 3,
    SCTAG_TMO_MAPPED_DATA = 4,
    SCTAG_TMO_CUSTOM = 5,
    SCTAG_TMO_USER_MIN = 6,
}
/**
 * Read structured data from the reader r. This hook is used to read a value
 * previously serialized by a call to the WriteStructuredCloneOp hook.
 *
 * tag and data are the pair of uint32_t values from the header. The callback
 * may use the JS_Read* APIs to read any other relevant parts of the object
 * from the reader r. closure is any value passed to the JS_ReadStructuredClone
 * function. Return the new object on success, nullptr on error/exception.
 */
pub type ReadStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               r:
                                                   *mut JSStructuredCloneReader,
                                               tag: u32, data: u32,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut JSObject>;
/**
 * Structured data serialization hook. The engine can write primitive values,
 * Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,
 * and SharedTypedArrays. Any other type of object requires application support.
 * This callback must first use the JS_WriteUint32Pair API to write an object
 * header, passing a value greater than JS_SCTAG_USER to the tag parameter.
 * Then it can use the JS_Write* APIs to write any other relevant parts of
 * the value v to the writer w. closure is any value passed to the
 * JS_WriteStructuredClone function.
 *
 * Return true on success, false on error/exception.
 */
pub type WriteStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               w:
                                                   *mut JSStructuredCloneWriter,
                                               obj: HandleObject,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
/**
 * This is called when JS_WriteStructuredClone is given an invalid transferable.
 * To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException
 * with error set to one of the JS_SCERR_* values.
 */
pub type StructuredCloneErrorOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               errorid: u32)>;
/**
 * This is called when JS_ReadStructuredClone receives a transferable object
 * not known to the engine. If this hook does not exist or returns false, the
 * JS engine calls the reportError op if set, otherwise it throws a
 * DATA_CLONE_ERR DOM Exception. This method is called before any other
 * callback and must return a non-null object in returnObject on success.
 */
pub type ReadTransferStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               r:
                                                   *mut JSStructuredCloneReader,
                                               tag: u32,
                                               content:
                                                   *mut ::std::os::raw::c_void,
                                               extraData: u64,
                                               closure:
                                                   *mut ::std::os::raw::c_void,
                                               returnObject:
                                                   MutableHandleObject)
                              -> bool>;
/**
 * Called when JS_WriteStructuredClone receives a transferable object not
 * handled by the engine. If this hook does not exist or returns false, the JS
 * engine will call the reportError hook or fall back to throwing a
 * DATA_CLONE_ERR DOM Exception. This method is called before any other
 * callback.
 *
 *  tag: indicates what type of transferable this is. Must be greater than
 *       0xFFFF0201 (value of the internal SCTAG_TRANSFER_MAP_PENDING_ENTRY)
 *
 *  ownership: see TransferableOwnership, above. Used to communicate any needed
 *       ownership info to the FreeTransferStructuredCloneOp.
 *
 *  content, extraData: what the ReadTransferStructuredCloneOp will receive
 */
pub type TransferStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: Handle<*mut JSObject>,
                                               closure:
                                                   *mut ::std::os::raw::c_void,
                                               tag: *mut u32,
                                               ownership:
                                                   *mut TransferableOwnership,
                                               content:
                                                   *mut *mut ::std::os::raw::c_void,
                                               extraData: *mut u64) -> bool>;
/**
 * Called when JS_ClearStructuredClone has to free an unknown transferable
 * object. Note that it should never trigger a garbage collection (and will
 * assert in a debug build if it does.)
 */
pub type FreeTransferStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(tag: u32,
                                               ownership:
                                                   TransferableOwnership,
                                               content:
                                                   *mut ::std::os::raw::c_void,
                                               extraData: u64,
                                               closure:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSStructuredCloneCallbacks {
    pub read: ReadStructuredCloneOp,
    pub write: WriteStructuredCloneOp,
    pub reportError: StructuredCloneErrorOp,
    pub readTransfer: ReadTransferStructuredCloneOp,
    pub writeTransfer: TransferStructuredCloneOp,
    pub freeTransfer: FreeTransferStructuredCloneOp,
}
impl ::std::clone::Clone for JSStructuredCloneCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSStructuredCloneCallbacks() {
    assert_eq!(::std::mem::size_of::<JSStructuredCloneCallbacks>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSStructuredCloneCallbacks>() , 8usize);
}
/** RAII sugar for JS_WriteStructuredClone. */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoStructuredCloneBuffer {
    pub data_: *mut u64,
    pub nbytes_: usize,
    pub version_: u32,
    pub ownTransferables_: JSAutoStructuredCloneBuffer_StructuredClone_h_unnamed_7,
    pub callbacks_: *const JSStructuredCloneCallbacks,
    pub closure_: *mut ::std::os::raw::c_void,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSAutoStructuredCloneBuffer_StructuredClone_h_unnamed_7 {
    OwnsTransferablesIfAny = 0,
    IgnoreTransferablesIfAny = 1,
    NoTransferables = 2,
}
#[test]
fn bindgen_test_layout_JSAutoStructuredCloneBuffer() {
    assert_eq!(::std::mem::size_of::<JSAutoStructuredCloneBuffer>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<JSAutoStructuredCloneBuffer>() ,
               8usize);
}
extern "C" {
    fn _ZN27JSAutoStructuredCloneBuffer5clearEPK26JSStructuredCloneCallbacksPv(this:
                                                                                   *mut JSAutoStructuredCloneBuffer,
                                                                               optionalCallbacks:
                                                                                   *const JSStructuredCloneCallbacks,
                                                                               closure:
                                                                                   *mut ::std::os::raw::c_void);
    fn _ZN27JSAutoStructuredCloneBuffer4copyEPKyyjPK26JSStructuredCloneCallbacksPv(this:
                                                                                       *mut JSAutoStructuredCloneBuffer,
                                                                                   data:
                                                                                       *const u64,
                                                                                   nbytes:
                                                                                       usize,
                                                                                   version:
                                                                                       u32,
                                                                                   callbacks:
                                                                                       *const JSStructuredCloneCallbacks,
                                                                                   closure:
                                                                                       *mut ::std::os::raw::c_void)
     -> bool;
    fn _ZN27JSAutoStructuredCloneBuffer5adoptEPyyjPK26JSStructuredCloneCallbacksPv(this:
                                                                                       *mut JSAutoStructuredCloneBuffer,
                                                                                   data:
                                                                                       *mut u64,
                                                                                   nbytes:
                                                                                       usize,
                                                                                   version:
                                                                                       u32,
                                                                                   callbacks:
                                                                                       *const JSStructuredCloneCallbacks,
                                                                                   closure:
                                                                                       *mut ::std::os::raw::c_void);
    fn _ZN27JSAutoStructuredCloneBuffer5stealEPPyS0_PjPPK26JSStructuredCloneCallbacksPPv(this:
                                                                                             *mut JSAutoStructuredCloneBuffer,
                                                                                         datap:
                                                                                             *mut *mut u64,
                                                                                         nbytesp:
                                                                                             *mut usize,
                                                                                         versionp:
                                                                                             *mut u32,
                                                                                         callbacks:
                                                                                             *mut *const JSStructuredCloneCallbacks,
                                                                                         closure:
                                                                                             *mut *mut ::std::os::raw::c_void);
    fn _ZN27JSAutoStructuredCloneBuffer4readEP9JSContextN2JS13MutableHandleINS2_5ValueEEEPK26JSStructuredCloneCallbacksPv(this:
                                                                                                                              *mut JSAutoStructuredCloneBuffer,
                                                                                                                          cx:
                                                                                                                              *mut JSContext,
                                                                                                                          vp:
                                                                                                                              MutableHandleValue,
                                                                                                                          optionalCallbacks:
                                                                                                                              *const JSStructuredCloneCallbacks,
                                                                                                                          closure:
                                                                                                                              *mut ::std::os::raw::c_void)
     -> bool;
    fn _ZN27JSAutoStructuredCloneBuffer5writeEP9JSContextN2JS6HandleINS2_5ValueEEEPK26JSStructuredCloneCallbacksPv(this:
                                                                                                                       *mut JSAutoStructuredCloneBuffer,
                                                                                                                   cx:
                                                                                                                       *mut JSContext,
                                                                                                                   v:
                                                                                                                       HandleValue,
                                                                                                                   optionalCallbacks:
                                                                                                                       *const JSStructuredCloneCallbacks,
                                                                                                                   closure:
                                                                                                                       *mut ::std::os::raw::c_void)
     -> bool;
    fn _ZN27JSAutoStructuredCloneBuffer5writeEP9JSContextN2JS6HandleINS2_5ValueEEES5_PK26JSStructuredCloneCallbacksPv(this:
                                                                                                                          *mut JSAutoStructuredCloneBuffer,
                                                                                                                      cx:
                                                                                                                          *mut JSContext,
                                                                                                                      v:
                                                                                                                          HandleValue,
                                                                                                                      transferable:
                                                                                                                          HandleValue,
                                                                                                                      optionalCallbacks:
                                                                                                                          *const JSStructuredCloneCallbacks,
                                                                                                                      closure:
                                                                                                                          *mut ::std::os::raw::c_void)
     -> bool;
}
impl JSAutoStructuredCloneBuffer {
    #[inline]
    pub unsafe fn clear(&mut self,
                        optionalCallbacks: *const JSStructuredCloneCallbacks,
                        closure: *mut ::std::os::raw::c_void) {
        _ZN27JSAutoStructuredCloneBuffer5clearEPK26JSStructuredCloneCallbacksPv(&mut *self,
                                                                                optionalCallbacks,
                                                                                closure)
    }
    /** Copy some memory. It will be automatically freed by the destructor. */
    #[inline]
    pub unsafe fn copy(&mut self, data: *const u64, nbytes: usize,
                       version: u32,
                       callbacks: *const JSStructuredCloneCallbacks,
                       closure: *mut ::std::os::raw::c_void) -> bool {
        _ZN27JSAutoStructuredCloneBuffer4copyEPKyyjPK26JSStructuredCloneCallbacksPv(&mut *self,
                                                                                    data,
                                                                                    nbytes,
                                                                                    version,
                                                                                    callbacks,
                                                                                    closure)
    }
    /**
     * Adopt some memory. It will be automatically freed by the destructor.
     * data must have been allocated by the JS engine (e.g., extracted via
     * JSAutoStructuredCloneBuffer::steal).
     */
    #[inline]
    pub unsafe fn adopt(&mut self, data: *mut u64, nbytes: usize,
                        version: u32,
                        callbacks: *const JSStructuredCloneCallbacks,
                        closure: *mut ::std::os::raw::c_void) {
        _ZN27JSAutoStructuredCloneBuffer5adoptEPyyjPK26JSStructuredCloneCallbacksPv(&mut *self,
                                                                                    data,
                                                                                    nbytes,
                                                                                    version,
                                                                                    callbacks,
                                                                                    closure)
    }
    /**
     * Release the buffer and transfer ownership to the caller. The caller is
     * responsible for calling JS_ClearStructuredClone or feeding the memory
     * back to JSAutoStructuredCloneBuffer::adopt.
     */
    #[inline]
    pub unsafe fn steal(&mut self, datap: *mut *mut u64, nbytesp: *mut usize,
                        versionp: *mut u32,
                        callbacks: *mut *const JSStructuredCloneCallbacks,
                        closure: *mut *mut ::std::os::raw::c_void) {
        _ZN27JSAutoStructuredCloneBuffer5stealEPPyS0_PjPPK26JSStructuredCloneCallbacksPPv(&mut *self,
                                                                                          datap,
                                                                                          nbytesp,
                                                                                          versionp,
                                                                                          callbacks,
                                                                                          closure)
    }
    #[inline]
    pub unsafe fn read(&mut self, cx: *mut JSContext, vp: MutableHandleValue,
                       optionalCallbacks: *const JSStructuredCloneCallbacks,
                       closure: *mut ::std::os::raw::c_void) -> bool {
        _ZN27JSAutoStructuredCloneBuffer4readEP9JSContextN2JS13MutableHandleINS2_5ValueEEEPK26JSStructuredCloneCallbacksPv(&mut *self,
                                                                                                                           cx,
                                                                                                                           vp,
                                                                                                                           optionalCallbacks,
                                                                                                                           closure)
    }
    #[inline]
    pub unsafe fn write(&mut self, cx: *mut JSContext, v: HandleValue,
                        optionalCallbacks: *const JSStructuredCloneCallbacks,
                        closure: *mut ::std::os::raw::c_void) -> bool {
        _ZN27JSAutoStructuredCloneBuffer5writeEP9JSContextN2JS6HandleINS2_5ValueEEEPK26JSStructuredCloneCallbacksPv(&mut *self,
                                                                                                                    cx,
                                                                                                                    v,
                                                                                                                    optionalCallbacks,
                                                                                                                    closure)
    }
    #[inline]
    pub unsafe fn write1(&mut self, cx: *mut JSContext, v: HandleValue,
                         transferable: HandleValue,
                         optionalCallbacks: *const JSStructuredCloneCallbacks,
                         closure: *mut ::std::os::raw::c_void) -> bool {
        _ZN27JSAutoStructuredCloneBuffer5writeEP9JSContextN2JS6HandleINS2_5ValueEEES5_PK26JSStructuredCloneCallbacksPv(&mut *self,
                                                                                                                       cx,
                                                                                                                       v,
                                                                                                                       transferable,
                                                                                                                       optionalCallbacks,
                                                                                                                       closure)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSPrincipals {
    pub _vftable: *const _vftable_JSPrincipals,
    pub refcount: u32,
    pub debugToken: u32,
}
#[repr(C)]
pub struct _vftable_JSPrincipals {
    pub write: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                    cx: *mut JSContext,
                                    writer: *mut JSStructuredCloneWriter)
                   -> bool,
}
#[test]
fn bindgen_test_layout_JSPrincipals() {
    assert_eq!(::std::mem::size_of::<JSPrincipals>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSPrincipals>() , 8usize);
}
pub type JSSubsumesOp =
    ::std::option::Option<unsafe extern "C" fn(first: *mut JSPrincipals,
                                               second: *mut JSPrincipals)
                              -> bool>;
pub type JSCSPEvalChecker =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSSecurityCallbacks {
    pub contentSecurityPolicyAllows: JSCSPEvalChecker,
    pub subsumes: JSSubsumesOp,
}
impl ::std::clone::Clone for JSSecurityCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSSecurityCallbacks() {
    assert_eq!(::std::mem::size_of::<JSSecurityCallbacks>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSSecurityCallbacks>() , 8usize);
}
pub type JSDestroyPrincipalsOp =
    ::std::option::Option<unsafe extern "C" fn(principals:
                                                   *mut JSPrincipals)>;
pub type JSReadPrincipalsOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               reader:
                                                   *mut JSStructuredCloneReader,
                                               outPrincipals:
                                                   *mut *mut JSPrincipals)
                              -> bool>;
pub enum TwoByteChars { }
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCheckRequestDepth {
    pub cx: *mut JSContext,
}
#[test]
fn bindgen_test_layout_AutoCheckRequestDepth() {
    assert_eq!(::std::mem::size_of::<AutoCheckRequestDepth>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoCheckRequestDepth>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoVectorRooterBase<T> {
    pub _base: AutoGCRooter,
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoVectorRooter<T> {
    pub _base: AutoVectorRooterBase<T>,
}
pub type AutoValueVector = AutoVectorRooter<Value>;
pub type AutoObjectVector = AutoVectorRooter<*mut JSObject>;
pub type ValueVector = ::std::os::raw::c_void;
pub type IdVector = ::std::os::raw::c_void;
pub type ScriptVector = ::std::os::raw::c_void;
pub type StringVector = ::std::os::raw::c_void;
/**
 * Custom rooting behavior for internal and external clients.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct CustomAutoRooter {
    pub _vftable: *const _vftable_CustomAutoRooter,
    pub _base: AutoGCRooter,
}
#[repr(C)]
pub struct _vftable_CustomAutoRooter {
    pub trace: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                    trc: *mut JSTracer),
}
#[test]
fn bindgen_test_layout_CustomAutoRooter() {
    assert_eq!(::std::mem::size_of::<CustomAutoRooter>() , 32usize);
    assert_eq!(::std::mem::align_of::<CustomAutoRooter>() , 8usize);
}
/** A handle to an array of rooted values. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HandleValueArray {
    pub length_: usize,
    pub elements_: *const Value,
}
impl ::std::clone::Clone for HandleValueArray {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_HandleValueArray() {
    assert_eq!(::std::mem::size_of::<HandleValueArray>() , 16usize);
    assert_eq!(::std::mem::align_of::<HandleValueArray>() , 8usize);
}
/************************************************************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSFreeOp {
    pub runtime_: *mut JSRuntime,
}
impl ::std::clone::Clone for JSFreeOp {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSFreeOp() {
    assert_eq!(::std::mem::size_of::<JSFreeOp>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSFreeOp>() , 8usize);
}
/************************************************************************/
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCStatus { JSGC_BEGIN = 0, JSGC_END = 1, }
pub type JSGCCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               status: JSGCStatus,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSObjectsTenuredCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSFinalizeStatus {
    JSFINALIZE_GROUP_START = 0,
    JSFINALIZE_GROUP_END = 1,
    JSFINALIZE_COLLECTION_END = 2,
}
pub type JSFinalizeCallback =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut JSFreeOp,
                                               status: JSFinalizeStatus,
                                               isCompartment: bool,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSWeakPointerZoneGroupCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSWeakPointerCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               comp: *mut JSCompartment,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSInterruptCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext) -> bool>;
pub type JSEnqueuePromiseJobCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               job: HandleObject,
                                               allocationSite: HandleObject,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PromiseRejectionHandlingState { Unhandled = 0, Handled = 1, }
pub type JSPromiseRejectionTrackerCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               promise: HandleObject,
                                               state:
                                                   PromiseRejectionHandlingState,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSProcessPromiseCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               promise: HandleObject)>;
pub const JSEXN_FIRST: JSExnType = JSExnType::JSEXN_ERR;
/**
 * Possible exception types. These types are part of a JSErrorFormatString
 * structure. They define which error to throw in case of a runtime error.
 *
 * JSEXN_WARN is used for warnings in js.msg files (for instance because we
 * don't want to prepend 'Error:' to warning messages). This value can go away
 * if we ever decide to use an entirely separate mechanism for warnings.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSExnType {
    JSEXN_ERR = 0,
    JSEXN_INTERNALERR = 1,
    JSEXN_EVALERR = 2,
    JSEXN_RANGEERR = 3,
    JSEXN_REFERENCEERR = 4,
    JSEXN_SYNTAXERR = 5,
    JSEXN_TYPEERR = 6,
    JSEXN_URIERR = 7,
    JSEXN_DEBUGGEEWOULDRUN = 8,
    JSEXN_WARN = 9,
    JSEXN_LIMIT = 10,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSErrorFormatString {
    /** The error message name in ASCII. */
    pub name: *const ::std::os::raw::c_char,
    /** The error format string in ASCII. */
    pub format: *const ::std::os::raw::c_char,
    /** The number of arguments to expand in the formatted error message. */
    pub argCount: u16,
    /** One of the JSExnType constants above. */
    pub exnType: i16,
}
impl ::std::clone::Clone for JSErrorFormatString {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSErrorFormatString() {
    assert_eq!(::std::mem::size_of::<JSErrorFormatString>() , 24usize);
    assert_eq!(::std::mem::align_of::<JSErrorFormatString>() , 8usize);
}
pub type JSErrorCallback =
    ::std::option::Option<unsafe extern "C" fn(userRef:
                                                   *mut ::std::os::raw::c_void,
                                               errorNumber:
                                                   ::std::os::raw::c_uint)
                              -> *const JSErrorFormatString>;
pub type JSLocaleToUpperCase =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src: HandleString,
                                               rval: MutableHandleValue)
                              -> bool>;
pub type JSLocaleToLowerCase =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src: HandleString,
                                               rval: MutableHandleValue)
                              -> bool>;
pub type JSLocaleCompare =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src1: HandleString,
                                               src2: HandleString,
                                               rval: MutableHandleValue)
                              -> bool>;
pub type JSLocaleToUnicode =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src:
                                                   *const ::std::os::raw::c_char,
                                               rval: MutableHandleValue)
                              -> bool>;
/**
 * Callback used to ask the embedding for the cross compartment wrapper handler
 * that implements the desired prolicy for this kind of object in the
 * destination compartment. |obj| is the object to be wrapped. If |existing| is
 * non-nullptr, it will point to an existing wrapper object that should be
 * re-used if possible. |existing| is guaranteed to be a cross-compartment
 * wrapper with a lazily-defined prototype and the correct global. It is
 * guaranteed not to wrap a function.
 */
pub type JSWrapObjectCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               existing: HandleObject,
                                               obj: HandleObject)
                              -> *mut JSObject>;
/**
 * Callback used by the wrap hook to ask the embedding to prepare an object
 * for wrapping in a context. This might include unwrapping other wrappers
 * or even finding a more suitable object for the new compartment.
 */
pub type JSPreWrapCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               scope: HandleObject,
                                               obj: HandleObject,
                                               objectPassedToWrap:
                                                   HandleObject)
                              -> *mut JSObject>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSWrapObjectCallbacks {
    pub wrap: JSWrapObjectCallback,
    pub preWrap: JSPreWrapCallback,
}
impl ::std::clone::Clone for JSWrapObjectCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSWrapObjectCallbacks() {
    assert_eq!(::std::mem::size_of::<JSWrapObjectCallbacks>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSWrapObjectCallbacks>() , 8usize);
}
pub type JSDestroyCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut JSFreeOp,
                                               compartment:
                                                   *mut JSCompartment)>;
pub type JSSizeOfIncludingThisCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(mallocSizeOf: MallocSizeOf,
                                               compartment:
                                                   *mut JSCompartment)
                              -> usize>;
pub type JSZoneCallback =
    ::std::option::Option<unsafe extern "C" fn(zone: *mut Zone)>;
pub type JSCompartmentNameCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               compartment:
                                                   *mut JSCompartment,
                                               buf:
                                                   *mut ::std::os::raw::c_char,
                                               bufsize: usize)>;
/**
 * Container class for passing in script source buffers to the JS engine.  This
 * not only groups the buffer and length values, it also provides a way to
 * optionally pass ownership of the buffer to the JS engine without copying.
 * Rules for use:
 *
 *  1) The data array must be allocated with js_malloc() or js_realloc() if
 *     ownership is being granted to the SourceBufferHolder.
 *  2) If ownership is not given to the SourceBufferHolder, then the memory
 *     must be kept alive until the JS compilation is complete.
 *  3) Any code calling SourceBufferHolder::take() must guarantee to keep the
 *     memory alive until JS compilation completes.  Normally only the JS
 *     engine should be calling take().
 *
 * Example use:
 *
 *    size_t length = 512;
 *    char16_t* chars = static_cast<char16_t*>(js_malloc(sizeof(char16_t) * length));
 *    JS::SourceBufferHolder srcBuf(chars, length, JS::SourceBufferHolder::GiveOwnership);
 *    JS::Compile(cx, options, srcBuf);
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct SourceBufferHolder {
    pub data_: *const ::std::os::raw::c_ushort,
    pub length_: usize,
    pub ownsChars_: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SourceBufferHolder_Ownership { NoOwnership = 0, GiveOwnership = 1, }
#[test]
fn bindgen_test_layout_SourceBufferHolder() {
    assert_eq!(::std::mem::size_of::<SourceBufferHolder>() , 24usize);
    assert_eq!(::std::mem::align_of::<SourceBufferHolder>() , 8usize);
}
pub type JS_CurrentEmbedderTimeFunction =
    ::std::option::Option<unsafe extern "C" fn() -> f64>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoRequest {
    pub mContext: *mut JSContext,
}
#[test]
fn bindgen_test_layout_JSAutoRequest() {
    assert_eq!(::std::mem::size_of::<JSAutoRequest>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSAutoRequest>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RuntimeOptions {
    pub _bitfield_1: u8,
    pub _bitfield_2: u8,
}
impl RuntimeOptions {
    #[inline]
    pub fn baseline_(&self) -> u8 {
        (self._bitfield_1 & (1usize as u8)) >> 0usize
    }
    #[inline]
    pub fn set_baseline_(&mut self, val: bool) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8) << 0usize) & (1usize as u8);
    }
    #[inline]
    pub fn ion_(&self) -> u8 { (self._bitfield_1 & (2usize as u8)) >> 1usize }
    #[inline]
    pub fn set_ion_(&mut self, val: bool) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8) << 1usize) & (2usize as u8);
    }
    #[inline]
    pub fn asmJS_(&self) -> u8 {
        (self._bitfield_1 & (4usize as u8)) >> 2usize
    }
    #[inline]
    pub fn set_asmJS_(&mut self, val: bool) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8) << 2usize) & (4usize as u8);
    }
    #[inline]
    pub fn wasm_(&self) -> u8 {
        (self._bitfield_1 & (8usize as u8)) >> 3usize
    }
    #[inline]
    pub fn set_wasm_(&mut self, val: bool) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8) << 3usize) & (8usize as u8);
    }
    #[inline]
    pub fn wasmAlwaysBaseline_(&self) -> u8 {
        (self._bitfield_1 & (16usize as u8)) >> 4usize
    }
    #[inline]
    pub fn set_wasmAlwaysBaseline_(&mut self, val: bool) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8) << 4usize) & (16usize as u8);
    }
    #[inline]
    pub fn throwOnAsmJSValidationFailure_(&self) -> u8 {
        (self._bitfield_1 & (32usize as u8)) >> 5usize
    }
    #[inline]
    pub fn set_throwOnAsmJSValidationFailure_(&mut self, val: bool) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u8) << 5usize) & (32usize as u8);
    }
    #[inline]
    pub fn nativeRegExp_(&self) -> u8 {
        (self._bitfield_1 & (64usize as u8)) >> 6usize
    }
    #[inline]
    pub fn set_nativeRegExp_(&mut self, val: bool) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u8) << 6usize) & (64usize as u8);
    }
    #[inline]
    pub fn unboxedArrays_(&self) -> u8 {
        (self._bitfield_1 & (128usize as u8)) >> 7usize
    }
    #[inline]
    pub fn set_unboxedArrays_(&mut self, val: bool) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u8) << 7usize) & (128usize as u8);
    }
    pub const fn new_bitfield_1(baseline_: bool, ion_: bool, asmJS_: bool,
                                wasm_: bool, wasmAlwaysBaseline_: bool,
                                throwOnAsmJSValidationFailure_: bool,
                                nativeRegExp_: bool, unboxedArrays_: bool)
     -> u8 {
        0 | ((baseline_ as u8) << 0u32) | ((ion_ as u8) << 1u32) |
            ((asmJS_ as u8) << 2u32) | ((wasm_ as u8) << 3u32) |
            ((wasmAlwaysBaseline_ as u8) << 4u32) |
            ((throwOnAsmJSValidationFailure_ as u8) << 5u32) |
            ((nativeRegExp_ as u8) << 6u32) | ((unboxedArrays_ as u8) << 7u32)
    }
    #[inline]
    pub fn asyncStack_(&self) -> u8 {
        (self._bitfield_2 & (1usize as u8)) >> 0usize
    }
    #[inline]
    pub fn set_asyncStack_(&mut self, val: bool) {
        self._bitfield_2 &= !(1usize as u8);
        self._bitfield_2 |= ((val as u8) << 0usize) & (1usize as u8);
    }
    #[inline]
    pub fn throwOnDebuggeeWouldRun_(&self) -> u8 {
        (self._bitfield_2 & (2usize as u8)) >> 1usize
    }
    #[inline]
    pub fn set_throwOnDebuggeeWouldRun_(&mut self, val: bool) {
        self._bitfield_2 &= !(2usize as u8);
        self._bitfield_2 |= ((val as u8) << 1usize) & (2usize as u8);
    }
    #[inline]
    pub fn dumpStackOnDebuggeeWouldRun_(&self) -> u8 {
        (self._bitfield_2 & (4usize as u8)) >> 2usize
    }
    #[inline]
    pub fn set_dumpStackOnDebuggeeWouldRun_(&mut self, val: bool) {
        self._bitfield_2 &= !(4usize as u8);
        self._bitfield_2 |= ((val as u8) << 2usize) & (4usize as u8);
    }
    #[inline]
    pub fn werror_(&self) -> u8 {
        (self._bitfield_2 & (8usize as u8)) >> 3usize
    }
    #[inline]
    pub fn set_werror_(&mut self, val: bool) {
        self._bitfield_2 &= !(8usize as u8);
        self._bitfield_2 |= ((val as u8) << 3usize) & (8usize as u8);
    }
    #[inline]
    pub fn strictMode_(&self) -> u8 {
        (self._bitfield_2 & (16usize as u8)) >> 4usize
    }
    #[inline]
    pub fn set_strictMode_(&mut self, val: bool) {
        self._bitfield_2 &= !(16usize as u8);
        self._bitfield_2 |= ((val as u8) << 4usize) & (16usize as u8);
    }
    #[inline]
    pub fn extraWarnings_(&self) -> u8 {
        (self._bitfield_2 & (32usize as u8)) >> 5usize
    }
    #[inline]
    pub fn set_extraWarnings_(&mut self, val: bool) {
        self._bitfield_2 &= !(32usize as u8);
        self._bitfield_2 |= ((val as u8) << 5usize) & (32usize as u8);
    }
    pub const fn new_bitfield_2(asyncStack_: bool,
                                throwOnDebuggeeWouldRun_: bool,
                                dumpStackOnDebuggeeWouldRun_: bool,
                                werror_: bool, strictMode_: bool,
                                extraWarnings_: bool) -> u8 {
        0 | ((asyncStack_ as u8) << 0u32) |
            ((throwOnDebuggeeWouldRun_ as u8) << 1u32) |
            ((dumpStackOnDebuggeeWouldRun_ as u8) << 2u32) |
            ((werror_ as u8) << 3u32) | ((strictMode_ as u8) << 4u32) |
            ((extraWarnings_ as u8) << 5u32)
    }
}
impl ::std::clone::Clone for RuntimeOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_RuntimeOptions() {
    assert_eq!(::std::mem::size_of::<RuntimeOptions>() , 2usize);
    assert_eq!(::std::mem::align_of::<RuntimeOptions>() , 1usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoCompartment {
    pub cx_: *mut JSContext,
    pub oldCompartment_: *mut JSCompartment,
}
#[test]
fn bindgen_test_layout_JSAutoCompartment() {
    assert_eq!(::std::mem::size_of::<JSAutoCompartment>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSAutoCompartment>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoNullableCompartment {
    pub cx_: *mut JSContext,
    pub oldCompartment_: *mut JSCompartment,
}
#[test]
fn bindgen_test_layout_JSAutoNullableCompartment() {
    assert_eq!(::std::mem::size_of::<JSAutoNullableCompartment>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSAutoNullableCompartment>() , 8usize);
}
pub type JSIterateCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               data:
                                                   *mut ::std::os::raw::c_void,
                                               compartment:
                                                   *mut JSCompartment)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCParamKey {
    JSGC_MAX_BYTES = 0,
    JSGC_MAX_MALLOC_BYTES = 1,
    JSGC_BYTES = 3,
    JSGC_NUMBER = 4,
    JSGC_MODE = 6,
    JSGC_UNUSED_CHUNKS = 7,
    JSGC_TOTAL_CHUNKS = 8,
    JSGC_SLICE_TIME_BUDGET = 9,
    JSGC_MARK_STACK_LIMIT = 10,
    JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
    JSGC_HIGH_FREQUENCY_LOW_LIMIT = 12,
    JSGC_HIGH_FREQUENCY_HIGH_LIMIT = 13,
    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX = 14,
    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN = 15,
    JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
    JSGC_DYNAMIC_HEAP_GROWTH = 17,
    JSGC_DYNAMIC_MARK_SLICE = 18,
    JSGC_ALLOCATION_THRESHOLD = 19,
    JSGC_DECOMMIT_THRESHOLD = 20,
    JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
    JSGC_MAX_EMPTY_CHUNK_COUNT = 22,
    JSGC_COMPACTING_ENABLED = 23,
    JSGC_REFRESH_FRAME_SLICES_ENABLED = 24,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSConstScalarSpec<T> {
    pub name: *const ::std::os::raw::c_char,
    pub val: T,
}
/**
 * Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will
 * allow us to pass one JSJitInfo per function with the property/function spec,
 * without additional field overhead.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSNativeWrapper {
    pub op: JSNative,
    pub info: *const JSJitInfo,
}
impl ::std::clone::Clone for JSNativeWrapper {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSNativeWrapper() {
    assert_eq!(::std::mem::size_of::<JSNativeWrapper>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSNativeWrapper>() , 8usize);
}
/**
 * Description of a property. JS_DefineProperties and JS_InitClass take arrays
 * of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END
 * are helper macros for defining such arrays.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSPropertySpec {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u8,
    pub getter: JSNativeWrapper,
    pub setter: JSNativeWrapper,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSPropertySpec_SelfHostedWrapper {
    pub unused: *mut ::std::os::raw::c_void,
    pub funname: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for JSPropertySpec_SelfHostedWrapper {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSPropertySpec_SelfHostedWrapper() {
    assert_eq!(::std::mem::size_of::<JSPropertySpec_SelfHostedWrapper>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<JSPropertySpec_SelfHostedWrapper>() ,
               8usize);
}
impl ::std::clone::Clone for JSPropertySpec {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSPropertySpec() {
    assert_eq!(::std::mem::size_of::<JSPropertySpec>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSPropertySpec>() , 8usize);
}
/**
 * To define a native function, set call to a JSNativeWrapper. To define a
 * self-hosted function, set selfHostedName to the name of a function
 * compiled during JSRuntime::initSelfHosting.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSFunctionSpec {
    pub name: *const ::std::os::raw::c_char,
    pub call: JSNativeWrapper,
    pub nargs: u16,
    pub flags: u16,
    pub selfHostedName: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for JSFunctionSpec {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSFunctionSpec() {
    assert_eq!(::std::mem::size_of::<JSFunctionSpec>() , 40usize);
    assert_eq!(::std::mem::align_of::<JSFunctionSpec>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ZoneSpecifier { FreshZone = 0, SystemZone = 1, }
/**
 * CompartmentCreationOptions specifies options relevant to creating a new
 * compartment, that are either immutable characteristics of that compartment
 * or that are discarded after the compartment has been created.
 *
 * Access to these options on an existing compartment is read-only: if you
 * need particular selections, make them before you create the compartment.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentCreationOptions {
    pub addonId_: *mut JSAddonId,
    pub traceGlobal_: JSTraceOp,
    pub zone_: CompartmentCreationOptions_jsapi_h_unnamed_8,
    pub invisibleToDebugger_: bool,
    pub mergeable_: bool,
    pub preserveJitCode_: bool,
    pub cloneSingletons_: bool,
    pub experimentalDateTimeFormatFormatToPartsEnabled_: bool,
    pub sharedMemoryAndAtomics_: bool,
    pub secureContext_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentCreationOptions_jsapi_h_unnamed_8 {
    pub spec: __BindgenUnionField<ZoneSpecifier>,
    pub pointer: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub _bindgen_data_: u64,
}
impl CompartmentCreationOptions_jsapi_h_unnamed_8 {
    pub unsafe fn spec(&mut self) -> *mut ZoneSpecifier {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pointer(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for CompartmentCreationOptions_jsapi_h_unnamed_8 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentCreationOptions_jsapi_h_unnamed_8() {
    assert_eq!(::std::mem::size_of::<CompartmentCreationOptions_jsapi_h_unnamed_8>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<CompartmentCreationOptions_jsapi_h_unnamed_8>()
               , 8usize);
}
impl ::std::clone::Clone for CompartmentCreationOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentCreationOptions() {
    assert_eq!(::std::mem::size_of::<CompartmentCreationOptions>() , 32usize);
    assert_eq!(::std::mem::align_of::<CompartmentCreationOptions>() , 8usize);
}
extern "C" {
    fn _ZN2JS26CompartmentCreationOptions7setZoneENS_13ZoneSpecifierE(this:
                                                                          *mut CompartmentCreationOptions,
                                                                      spec:
                                                                          ZoneSpecifier)
     -> *mut CompartmentCreationOptions;
    fn _ZN2JS26CompartmentCreationOptions13setSameZoneAsEP8JSObject(this:
                                                                        *mut CompartmentCreationOptions,
                                                                    obj:
                                                                        *mut JSObject)
     -> *mut CompartmentCreationOptions;
    fn _ZNK2JS26CompartmentCreationOptions32getSharedMemoryAndAtomicsEnabledEv(this:
                                                                                   *mut CompartmentCreationOptions)
     -> bool;
    fn _ZN2JS26CompartmentCreationOptions32setSharedMemoryAndAtomicsEnabledEb(this:
                                                                                  *mut CompartmentCreationOptions,
                                                                              flag:
                                                                                  bool)
     -> *mut CompartmentCreationOptions;
}
impl CompartmentCreationOptions {
    #[inline]
    pub unsafe fn setZone(&mut self, spec: ZoneSpecifier)
     -> *mut CompartmentCreationOptions {
        _ZN2JS26CompartmentCreationOptions7setZoneENS_13ZoneSpecifierE(&mut *self,
                                                                       spec)
    }
    #[inline]
    pub unsafe fn setSameZoneAs(&mut self, obj: *mut JSObject)
     -> *mut CompartmentCreationOptions {
        _ZN2JS26CompartmentCreationOptions13setSameZoneAsEP8JSObject(&mut *self,
                                                                     obj)
    }
    #[inline]
    pub unsafe fn getSharedMemoryAndAtomicsEnabled(&mut self) -> bool {
        _ZNK2JS26CompartmentCreationOptions32getSharedMemoryAndAtomicsEnabledEv(&mut *self)
    }
    #[inline]
    pub unsafe fn setSharedMemoryAndAtomicsEnabled(&mut self, flag: bool)
     -> *mut CompartmentCreationOptions {
        _ZN2JS26CompartmentCreationOptions32setSharedMemoryAndAtomicsEnabledEb(&mut *self,
                                                                               flag)
    }
}
/**
 * CompartmentBehaviors specifies behaviors of a compartment that can be
 * changed after the compartment's been created.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentBehaviors {
    pub version_: JSVersion,
    pub discardSource_: bool,
    pub disableLazyParsing_: bool,
    pub extraWarningsOverride_: CompartmentBehaviors_Override,
    pub singletonsAsTemplates_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentBehaviors_Override {
    pub mode_: CompartmentBehaviors_Override_Mode,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum CompartmentBehaviors_Override_Mode {
    Default = 0,
    ForceTrue = 1,
    ForceFalse = 2,
}
impl ::std::clone::Clone for CompartmentBehaviors_Override {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentBehaviors_Override() {
    assert_eq!(::std::mem::size_of::<CompartmentBehaviors_Override>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<CompartmentBehaviors_Override>() ,
               4usize);
}
impl ::std::clone::Clone for CompartmentBehaviors {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentBehaviors() {
    assert_eq!(::std::mem::size_of::<CompartmentBehaviors>() , 16usize);
    assert_eq!(::std::mem::align_of::<CompartmentBehaviors>() , 4usize);
}
extern "C" {
    fn _ZNK2JS20CompartmentBehaviors13extraWarningsEP9JSRuntime(this:
                                                                    *mut CompartmentBehaviors,
                                                                rt:
                                                                    *mut JSRuntime)
     -> bool;
}
impl CompartmentBehaviors {
    #[inline]
    pub unsafe fn extraWarnings(&mut self, rt: *mut JSRuntime) -> bool {
        _ZNK2JS20CompartmentBehaviors13extraWarningsEP9JSRuntime(&mut *self,
                                                                 rt)
    }
}
/**
 * CompartmentOptions specifies compartment characteristics: both those that
 * can't be changed on a compartment once it's been created
 * (CompartmentCreationOptions), and those that can be changed on an existing
 * compartment (CompartmentBehaviors).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentOptions {
    pub creationOptions_: CompartmentCreationOptions,
    pub behaviors_: CompartmentBehaviors,
}
impl ::std::clone::Clone for CompartmentOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentOptions() {
    assert_eq!(::std::mem::size_of::<CompartmentOptions>() , 48usize);
    assert_eq!(::std::mem::align_of::<CompartmentOptions>() , 8usize);
}
/**
 * During global creation, we fire notifications to callbacks registered
 * via the Debugger API. These callbacks are arbitrary script, and can touch
 * the global in arbitrary ways. When that happens, the global should not be
 * in a half-baked state. But this creates a problem for consumers that need
 * to set slots on the global to put it in a consistent state.
 *
 * This API provides a way for consumers to set slots atomically (immediately
 * after the global is created), before any debugger hooks are fired. It's
 * unfortunately on the clunky side, but that's the way the cookie crumbles.
 *
 * If callers have no additional state on the global to set up, they may pass
 * |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to
 * fire the hook as its final act before returning. Otherwise, callers should
 * pass |DontFireOnNewGlobalHook|, which means that they are responsible for
 * invoking JS_FireOnNewGlobalObject upon successfully creating the global. If
 * an error occurs and the operation aborts, callers should skip firing the
 * hook. But otherwise, callers must take care to fire the hook exactly once
 * before compiling any script in the global's scope (we have assertions in
 * place to enforce this). This lets us be sure that debugger clients never miss
 * breakpoints.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum OnNewGlobalHookOption {
    FireOnNewGlobalHook = 0,
    DontFireOnNewGlobalHook = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PropertyDescriptor {
    pub obj: *mut JSObject,
    pub attrs: ::std::os::raw::c_uint,
    pub getter: JSGetterOp,
    pub setter: JSSetterOp,
    pub value: Value,
}
impl ::std::clone::Clone for PropertyDescriptor {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PropertyDescriptor() {
    assert_eq!(::std::mem::size_of::<PropertyDescriptor>() , 40usize);
    assert_eq!(::std::mem::align_of::<PropertyDescriptor>() , 8usize);
}
extern "C" {
    fn _ZN2JS18PropertyDescriptor5traceEP8JSTracer(this:
                                                       *mut PropertyDescriptor,
                                                   trc: *mut JSTracer);
}
impl PropertyDescriptor {
    #[inline]
    pub unsafe fn trace(&mut self, trc: *mut JSTracer) {
        _ZN2JS18PropertyDescriptor5traceEP8JSTracer(&mut *self, trc)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyDescriptorOperations<Outer> {
    pub _phantom0: ::std::marker::PhantomData<Outer>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PropertyDescriptorOperations_jsapi_h_unnamed_9 { SHADOWABLE = 0, }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutablePropertyDescriptorOperations<Outer> {
    pub _base: PropertyDescriptorOperations<Outer>,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AsmJSOption { Enabled = 0, Disabled = 1, DisabledByDebugger = 2, }
/**
 * The common base class for the CompileOptions hierarchy.
 *
 * Use this in code that needs to propagate compile options from one compilation
 * unit to another.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TransitiveCompileOptions {
    pub _vftable: *const _vftable_TransitiveCompileOptions,
    pub mutedErrors_: bool,
    pub filename_: *const ::std::os::raw::c_char,
    pub introducerFilename_: *const ::std::os::raw::c_char,
    pub sourceMapURL_: *const ::std::os::raw::c_ushort,
    pub version: JSVersion,
    pub versionSet: bool,
    pub utf8: bool,
    pub selfHostingMode: bool,
    pub canLazilyParse: bool,
    pub strictOption: bool,
    pub extraWarningsOption: bool,
    pub werrorOption: bool,
    pub asmJSOption: AsmJSOption,
    pub throwOnAsmJSValidationFailureOption: bool,
    pub forceAsync: bool,
    pub installedFile: bool,
    pub sourceIsLazy: bool,
    pub introductionType: *const ::std::os::raw::c_char,
    pub introductionLineno: ::std::os::raw::c_uint,
    pub introductionOffset: u32,
    pub hasIntroductionInfo: bool,
}
#[repr(C)]
pub struct _vftable_TransitiveCompileOptions {
    pub element: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void)
                     -> *mut JSObject,
    pub elementAttributeName: unsafe extern "C" fn(this:
                                                       *mut ::std::os::raw::c_void)
                                  -> *mut JSString,
    pub introductionScript: unsafe extern "C" fn(this:
                                                     *mut ::std::os::raw::c_void)
                                -> *mut JSScript,
}
impl ::std::clone::Clone for TransitiveCompileOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TransitiveCompileOptions() {
    assert_eq!(::std::mem::size_of::<TransitiveCompileOptions>() , 80usize);
    assert_eq!(::std::mem::align_of::<TransitiveCompileOptions>() , 8usize);
}
extern "C" {
    fn _ZN2JS24TransitiveCompileOptions24copyPODTransitiveOptionsERKS0_(this:
                                                                            *mut TransitiveCompileOptions,
                                                                        rhs:
                                                                            *const TransitiveCompileOptions);
}
impl TransitiveCompileOptions {
    #[inline]
    pub unsafe fn copyPODTransitiveOptions(&mut self,
                                           rhs:
                                               *const TransitiveCompileOptions) {
        _ZN2JS24TransitiveCompileOptions24copyPODTransitiveOptionsERKS0_(&mut *self,
                                                                         rhs)
    }
}
#[repr(C)]
pub struct ReadOnlyCompileOptions {
    pub _bindgen_opaque_blob: [u64; 11usize],
}
#[test]
fn bindgen_test_layout_ReadOnlyCompileOptions() {
    assert_eq!(::std::mem::size_of::<ReadOnlyCompileOptions>() , 88usize);
    assert_eq!(::std::mem::align_of::<ReadOnlyCompileOptions>() , 8usize);
}
#[repr(C)]
pub struct OwningCompileOptions {
    pub _bindgen_opaque_blob: [u64; 24usize],
}
#[test]
fn bindgen_test_layout_OwningCompileOptions() {
    assert_eq!(::std::mem::size_of::<OwningCompileOptions>() , 192usize);
    assert_eq!(::std::mem::align_of::<OwningCompileOptions>() , 8usize);
}
#[repr(C)]
pub struct CompileOptions {
    pub _bindgen_opaque_blob: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_CompileOptions() {
    assert_eq!(::std::mem::size_of::<CompileOptions>() , 160usize);
    assert_eq!(::std::mem::align_of::<CompileOptions>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PromiseState { Pending = 0, Fulfilled = 1, Rejected = 2, }
/**
 * This class can be used to store a pointer to the youngest frame of a saved
 * stack in the specified JSContext. This reference will be picked up by any new
 * calls performed until the class is destroyed, with the specified asyncCause,
 * that must not be empty.
 *
 * Any stack capture initiated during these new calls will go through the async
 * stack instead of the current stack.
 *
 * Capturing the stack before a new call is performed will not be affected.
 *
 * The provided chain of SavedFrame objects can live in any compartment,
 * although it will be copied to the compartment where the stack is captured.
 *
 * See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
 * stack frames.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSetAsyncStackForNewCalls {
    pub cx: *mut JSContext,
    pub oldAsyncStack: RootedObject,
    pub oldAsyncCause: *const ::std::os::raw::c_char,
    pub oldAsyncCallIsExplicit: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
    IMPLICIT = 0,
    EXPLICIT = 1,
}
#[test]
fn bindgen_test_layout_AutoSetAsyncStackForNewCalls() {
    assert_eq!(::std::mem::size_of::<AutoSetAsyncStackForNewCalls>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<AutoSetAsyncStackForNewCalls>() ,
               8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoByteString {
    pub mBytes: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_JSAutoByteString() {
    assert_eq!(::std::mem::size_of::<JSAutoByteString>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSAutoByteString>() , 8usize);
}
extern "C" {
    fn _ZN16JSAutoByteString12encodeLatin1EPN2js16ExclusiveContextEP8JSString(this:
                                                                                  *mut JSAutoByteString,
                                                                              cx:
                                                                                  *mut ExclusiveContext,
                                                                              str:
                                                                                  *mut JSString)
     -> *mut ::std::os::raw::c_char;
}
impl JSAutoByteString {
    #[inline]
    pub unsafe fn encodeLatin1(&mut self, cx: *mut ExclusiveContext,
                               str: *mut JSString)
     -> *mut ::std::os::raw::c_char {
        _ZN16JSAutoByteString12encodeLatin1EPN2js16ExclusiveContextEP8JSString(&mut *self,
                                                                               cx,
                                                                               str)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SymbolCode {
    isConcatSpreadable = 0,
    iterator = 1,
    match_ = 2,
    replace = 3,
    search = 4,
    species = 5,
    hasInstance = 6,
    split = 7,
    toPrimitive = 8,
    unscopables = 9,
    Limit = 10,
    InSymbolRegistry = -2,
    UniqueSymbol = -1,
}
/************************************************************************/
pub type JSONWriteCallback =
    ::std::option::Option<unsafe extern "C" fn(buf:
                                                   *const ::std::os::raw::c_ushort,
                                               len: u32,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
/**
 * Locale specific string conversion and error message callbacks.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSLocaleCallbacks {
    pub localeToUpperCase: JSLocaleToUpperCase,
    pub localeToLowerCase: JSLocaleToLowerCase,
    pub localeCompare: JSLocaleCompare,
    pub localeToUnicode: JSLocaleToUnicode,
}
impl ::std::clone::Clone for JSLocaleCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSLocaleCallbacks() {
    assert_eq!(::std::mem::size_of::<JSLocaleCallbacks>() , 32usize);
    assert_eq!(::std::mem::align_of::<JSLocaleCallbacks>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSErrorReport {
    pub linebuf_: *const ::std::os::raw::c_ushort,
    pub linebufLength_: usize,
    pub tokenOffset_: usize,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_uint,
    pub column: ::std::os::raw::c_uint,
    pub isMuted: bool,
    pub flags: ::std::os::raw::c_uint,
    pub errorNumber: ::std::os::raw::c_uint,
    pub ucmessage: *const ::std::os::raw::c_ushort,
    pub messageArgs: *mut *const ::std::os::raw::c_ushort,
    pub exnType: i16,
}
impl ::std::clone::Clone for JSErrorReport {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSErrorReport() {
    assert_eq!(::std::mem::size_of::<JSErrorReport>() , 80usize);
    assert_eq!(::std::mem::align_of::<JSErrorReport>() , 8usize);
}
extern "C" {
    fn _ZN13JSErrorReport11initLinebufEPKDsyy(this: *mut JSErrorReport,
                                              linebuf:
                                                  *const ::std::os::raw::c_ushort,
                                              linebufLength: usize,
                                              tokenOffset: usize);
}
impl JSErrorReport {
    #[inline]
    pub unsafe fn initLinebuf(&mut self,
                              linebuf: *const ::std::os::raw::c_ushort,
                              linebufLength: usize, tokenOffset: usize) {
        _ZN13JSErrorReport11initLinebufEPKDsyy(&mut *self, linebuf,
                                               linebufLength, tokenOffset)
    }
}
pub type WarningReporter =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               message:
                                                   *const ::std::os::raw::c_char,
                                               report: *mut JSErrorReport)>;
/**
 * Save and later restore the current exception state of a given JSContext.
 * This is useful for implementing behavior in C++ that's like try/catch
 * or try/finally in JS.
 *
 * Typical usage:
 *
 *     bool ok = JS::Evaluate(cx, ...);
 *     AutoSaveExceptionState savedExc(cx);
 *     ... cleanup that might re-enter JS ...
 *     return ok;
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSaveExceptionState {
    pub context: *mut JSContext,
    pub wasPropagatingForcedReturn: bool,
    pub wasOverRecursed: bool,
    pub wasThrowing: bool,
    pub exceptionValue: RootedValue,
}
#[test]
fn bindgen_test_layout_AutoSaveExceptionState() {
    assert_eq!(::std::mem::size_of::<AutoSaveExceptionState>() , 40usize);
    assert_eq!(::std::mem::align_of::<AutoSaveExceptionState>() , 8usize);
}
extern "C" {
    fn _ZN2JS22AutoSaveExceptionState7restoreEv(this:
                                                    *mut AutoSaveExceptionState);
}
impl AutoSaveExceptionState {
    #[inline]
    pub unsafe fn restore(&mut self) {
        _ZN2JS22AutoSaveExceptionState7restoreEv(&mut *self)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitCompilerOption {
    JSJITCOMPILER_BASELINE_WARMUP_TRIGGER = 0,
    JSJITCOMPILER_ION_WARMUP_TRIGGER = 1,
    JSJITCOMPILER_ION_GVN_ENABLE = 2,
    JSJITCOMPILER_ION_FORCE_IC = 3,
    JSJITCOMPILER_ION_ENABLE = 4,
    JSJITCOMPILER_BASELINE_ENABLE = 5,
    JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE = 6,
    JSJITCOMPILER_SIGNALS_ENABLE = 7,
    JSJITCOMPILER_JUMP_THRESHOLD = 8,
    JSJITCOMPILER_WASM_TEST_MODE = 9,
    JSJITCOMPILER_NOT_AN_OPTION = 10,
}
pub enum ScriptSource { }
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoFilename {
    pub ss_: *mut ScriptSource,
    pub filename_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_AutoFilename() {
    assert_eq!(::std::mem::size_of::<AutoFilename>() , 24usize);
    assert_eq!(::std::mem::align_of::<AutoFilename>() , 8usize);
}
extern "C" {
    fn _ZN2JS12AutoFilename5resetEv(this: *mut AutoFilename);
    fn _ZN2JS12AutoFilename8setOwnedEON7mozilla9UniquePtrIA_cNS_10FreePolicyEEE(this:
                                                                                    *mut AutoFilename,
                                                                                filename:
                                                                                    ::std::os::raw::c_void);
    fn _ZN2JS12AutoFilename10setUnownedEPKc(this: *mut AutoFilename,
                                            filename:
                                                *const ::std::os::raw::c_char);
    fn _ZN2JS12AutoFilename15setScriptSourceEPN2js12ScriptSourceE(this:
                                                                      *mut AutoFilename,
                                                                  ss:
                                                                      *mut ScriptSource);
    fn _ZNK2JS12AutoFilename3getEv(this: *mut AutoFilename)
     -> *const ::std::os::raw::c_char;
}
impl AutoFilename {
    #[inline]
    pub unsafe fn reset(&mut self) {
        _ZN2JS12AutoFilename5resetEv(&mut *self)
    }
    #[inline]
    pub unsafe fn setOwned(&mut self, filename: ::std::os::raw::c_void) {
        _ZN2JS12AutoFilename8setOwnedEON7mozilla9UniquePtrIA_cNS_10FreePolicyEEE(&mut *self,
                                                                                 filename)
    }
    #[inline]
    pub unsafe fn setUnowned(&mut self,
                             filename: *const ::std::os::raw::c_char) {
        _ZN2JS12AutoFilename10setUnownedEPKc(&mut *self, filename)
    }
    #[inline]
    pub unsafe fn setScriptSource(&mut self, ss: *mut ScriptSource) {
        _ZN2JS12AutoFilename15setScriptSourceEPN2js12ScriptSourceE(&mut *self,
                                                                   ss)
    }
    #[inline]
    pub unsafe fn get(&mut self) -> *const ::std::os::raw::c_char {
        _ZNK2JS12AutoFilename3getEv(&mut *self)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoHideScriptedCaller {
    pub mContext: *mut JSContext,
}
#[test]
fn bindgen_test_layout_AutoHideScriptedCaller() {
    assert_eq!(::std::mem::size_of::<AutoHideScriptedCaller>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoHideScriptedCaller>() , 8usize);
}
pub type OpenAsmJSCacheEntryForReadOp =
    ::std::option::Option<unsafe extern "C" fn(global: HandleObject,
                                               begin:
                                                   *const ::std::os::raw::c_ushort,
                                               limit:
                                                   *const ::std::os::raw::c_ushort,
                                               size: *mut usize,
                                               memory: *mut *const u8,
                                               handle: *mut isize) -> bool>;
pub type CloseAsmJSCacheEntryForReadOp =
    ::std::option::Option<unsafe extern "C" fn(size: usize, memory: *const u8,
                                               handle: isize)>;
pub const AsmJSCache_MIN: AsmJSCacheResult =
    AsmJSCacheResult::AsmJSCache_Success;
/** The list of reasons why an asm.js module may not be stored in the cache. */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AsmJSCacheResult {
    AsmJSCache_Success = 0,
    AsmJSCache_ModuleTooSmall = 1,
    AsmJSCache_SynchronousScript = 2,
    AsmJSCache_QuotaExceeded = 3,
    AsmJSCache_StorageInitFailure = 4,
    AsmJSCache_Disabled_Internal = 5,
    AsmJSCache_Disabled_ShellFlags = 6,
    AsmJSCache_Disabled_JitInspector = 7,
    AsmJSCache_InternalError = 8,
    AsmJSCache_LIMIT = 9,
}
pub type OpenAsmJSCacheEntryForWriteOp =
    ::std::option::Option<unsafe extern "C" fn(global: HandleObject,
                                               installed: bool,
                                               begin:
                                                   *const ::std::os::raw::c_ushort,
                                               end:
                                                   *const ::std::os::raw::c_ushort,
                                               size: usize,
                                               memory: *mut *mut u8,
                                               handle: *mut isize)
                              -> AsmJSCacheResult>;
pub type CloseAsmJSCacheEntryForWriteOp =
    ::std::option::Option<unsafe extern "C" fn(size: usize, memory: *mut u8,
                                               handle: isize)>;
pub type BuildIdCharVector = ::std::os::raw::c_void;
/**
 * Return the buildId (represented as a sequence of characters) associated with
 * the currently-executing build. If the JS engine is embedded such that a
 * single cache entry can be observed by different compiled versions of the JS
 * engine, it is critical that the buildId shall change for each new build of
 * the JS engine.
 */
pub type BuildIdOp =
    ::std::option::Option<unsafe extern "C" fn(buildId:
                                                   *mut BuildIdCharVector)
                              -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AsmJSCacheOps {
    pub openEntryForRead: OpenAsmJSCacheEntryForReadOp,
    pub closeEntryForRead: CloseAsmJSCacheEntryForReadOp,
    pub openEntryForWrite: OpenAsmJSCacheEntryForWriteOp,
    pub closeEntryForWrite: CloseAsmJSCacheEntryForWriteOp,
}
impl ::std::clone::Clone for AsmJSCacheOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_AsmJSCacheOps() {
    assert_eq!(::std::mem::size_of::<AsmJSCacheOps>() , 32usize);
    assert_eq!(::std::mem::align_of::<AsmJSCacheOps>() , 8usize);
}
/**
 * Convenience class for imitating a JS level for-of loop. Typical usage:
 *
 *     ForOfIterator it(cx);
 *     if (!it.init(iterable))
 *       return false;
 *     RootedValue val(cx);
 *     while (true) {
 *       bool done;
 *       if (!it.next(&val, &done))
 *         return false;
 *       if (done)
 *         break;
 *       if (!DoStuff(cx, val))
 *         return false;
 *     }
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct ForOfIterator {
    pub cx_: *mut JSContext,
    pub iterator: RootedObject,
    pub index: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ForOfIterator_NonIterableBehavior {
    ThrowOnNonIterable = 0,
    AllowNonIterable = 1,
}
#[test]
fn bindgen_test_layout_ForOfIterator() {
    assert_eq!(::std::mem::size_of::<ForOfIterator>() , 40usize);
    assert_eq!(::std::mem::align_of::<ForOfIterator>() , 8usize);
}
extern "C" {
    fn _ZN2JS13ForOfIterator4initENS_6HandleINS_5ValueEEENS0_19NonIterableBehaviorE(this:
                                                                                        *mut ForOfIterator,
                                                                                    iterable:
                                                                                        HandleValue,
                                                                                    nonIterableBehavior:
                                                                                        ForOfIterator_NonIterableBehavior)
     -> bool;
    fn _ZN2JS13ForOfIterator4nextENS_13MutableHandleINS_5ValueEEEPb(this:
                                                                        *mut ForOfIterator,
                                                                    val:
                                                                        MutableHandleValue,
                                                                    done:
                                                                        *mut bool)
     -> bool;
}
impl ForOfIterator {
    /**
     * Initialize the iterator.  If AllowNonIterable is passed then if getting
     * the @@iterator property from iterable returns undefined init() will just
     * return true instead of throwing.  Callers must then check
     * valueIsIterable() before continuing with the iteration.
     */
    #[inline]
    pub unsafe fn init(&mut self, iterable: HandleValue,
                       nonIterableBehavior: ForOfIterator_NonIterableBehavior)
     -> bool {
        _ZN2JS13ForOfIterator4initENS_6HandleINS_5ValueEEENS0_19NonIterableBehaviorE(&mut *self,
                                                                                     iterable,
                                                                                     nonIterableBehavior)
    }
    /**
     * Get the next value from the iterator.  If false *done is true
     * after this call, do not examine val.
     */
    #[inline]
    pub unsafe fn next(&mut self, val: MutableHandleValue, done: *mut bool)
     -> bool {
        _ZN2JS13ForOfIterator4nextENS_13MutableHandleINS_5ValueEEEPb(&mut *self,
                                                                     val,
                                                                     done)
    }
}
/**
 * If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS
 * engine may call the large-allocation- failure callback, if set, to allow the
 * embedding to flush caches, possibly perform shrinking GCs, etc. to make some
 * room. The allocation will then be retried (and may still fail.)
 */
pub type LargeAllocationFailureCallback =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void)>;
/**
 * Unlike the error reporter, which is only called if the exception for an OOM
 * bubbles up and is not caught, the OutOfMemoryCallback is called immediately
 * at the OOM site to allow the embedding to capture the current state of heap
 * allocation before anything is freed. If the large-allocation-failure callback
 * is called at all (not all allocation sites call the large-allocation-failure
 * callback on failure), it is called before the out-of-memory callback; the
 * out-of-memory callback is only called if the allocation still fails after the
 * large-allocation-failure callback has returned.
 */
pub type OutOfMemoryCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SavedFrameResult { Ok = 0, AccessDenied = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SavedFrameSelfHosted { Include = 0, Exclude = 1, }
pub enum AutoStopwatch { }
/**
 * Abstract base class for a representation of the performance of a
 * component. Embeddings interested in performance monitoring should
 * provide a concrete implementation of this class, as well as the
 * relevant callbacks (see below).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PerformanceGroup {
    pub _vftable: *const _vftable_PerformanceGroup,
    pub recentCycles_: u64,
    pub recentTicks_: u64,
    pub recentCPOW_: u64,
    pub iteration_: u64,
    pub isActive_: bool,
    pub isUsedInThisIteration_: bool,
    pub owner_: *const AutoStopwatch,
    pub refCount_: u64,
}
#[repr(C)]
pub struct _vftable_PerformanceGroup {
    pub Delete: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void),
}
impl ::std::clone::Clone for PerformanceGroup {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PerformanceGroup() {
    assert_eq!(::std::mem::size_of::<PerformanceGroup>() , 64usize);
    assert_eq!(::std::mem::align_of::<PerformanceGroup>() , 8usize);
}
extern "C" {
    fn _ZNK2js16PerformanceGroup9iterationEv(this: *mut PerformanceGroup)
     -> u64;
    fn _ZNK2js16PerformanceGroup10isAcquiredEy(this: *mut PerformanceGroup,
                                               it: u64) -> bool;
    fn _ZNK2js16PerformanceGroup10isAcquiredEyPKNS_13AutoStopwatchE(this:
                                                                        *mut PerformanceGroup,
                                                                    it: u64,
                                                                    owner:
                                                                        *const AutoStopwatch)
     -> bool;
    fn _ZN2js16PerformanceGroup7acquireEyPKNS_13AutoStopwatchE(this:
                                                                   *mut PerformanceGroup,
                                                               it: u64,
                                                               owner:
                                                                   *const AutoStopwatch);
    fn _ZN2js16PerformanceGroup7releaseEyPKNS_13AutoStopwatchE(this:
                                                                   *mut PerformanceGroup,
                                                               it: u64,
                                                               owner:
                                                                   *const AutoStopwatch);
    fn _ZNK2js16PerformanceGroup12recentCyclesEy(this: *mut PerformanceGroup,
                                                 iteration: u64) -> u64;
    fn _ZN2js16PerformanceGroup15addRecentCyclesEyy(this:
                                                        *mut PerformanceGroup,
                                                    iteration: u64,
                                                    cycles: u64);
    fn _ZNK2js16PerformanceGroup11recentTicksEy(this: *mut PerformanceGroup,
                                                iteration: u64) -> u64;
    fn _ZN2js16PerformanceGroup14addRecentTicksEyy(this:
                                                       *mut PerformanceGroup,
                                                   iteration: u64,
                                                   ticks: u64);
    fn _ZNK2js16PerformanceGroup10recentCPOWEy(this: *mut PerformanceGroup,
                                               iteration: u64) -> u64;
    fn _ZN2js16PerformanceGroup13addRecentCPOWEyy(this: *mut PerformanceGroup,
                                                  iteration: u64, CPOW: u64);
    fn _ZN2js16PerformanceGroup15resetRecentDataEv(this:
                                                       *mut PerformanceGroup);
    fn _ZNK2js16PerformanceGroup8isActiveEv(this: *mut PerformanceGroup)
     -> bool;
    fn _ZN2js16PerformanceGroup11setIsActiveEb(this: *mut PerformanceGroup,
                                               arg1: bool);
    fn _ZNK2js16PerformanceGroup21isUsedInThisIterationEv(this:
                                                              *mut PerformanceGroup)
     -> bool;
    fn _ZN2js16PerformanceGroup24setIsUsedInThisIterationEb(this:
                                                                *mut PerformanceGroup,
                                                            arg1: bool);
    fn _ZN2js16PerformanceGroup6AddRefEv(this: *mut PerformanceGroup);
    fn _ZN2js16PerformanceGroup7ReleaseEv(this: *mut PerformanceGroup);
}
impl PerformanceGroup {
    #[inline]
    pub unsafe fn iteration(&mut self) -> u64 {
        _ZNK2js16PerformanceGroup9iterationEv(&mut *self)
    }
    #[inline]
    pub unsafe fn isAcquired(&mut self, it: u64) -> bool {
        _ZNK2js16PerformanceGroup10isAcquiredEy(&mut *self, it)
    }
    #[inline]
    pub unsafe fn isAcquired1(&mut self, it: u64, owner: *const AutoStopwatch)
     -> bool {
        _ZNK2js16PerformanceGroup10isAcquiredEyPKNS_13AutoStopwatchE(&mut *self,
                                                                     it,
                                                                     owner)
    }
    #[inline]
    pub unsafe fn acquire(&mut self, it: u64, owner: *const AutoStopwatch) {
        _ZN2js16PerformanceGroup7acquireEyPKNS_13AutoStopwatchE(&mut *self,
                                                                it, owner)
    }
    #[inline]
    pub unsafe fn release(&mut self, it: u64, owner: *const AutoStopwatch) {
        _ZN2js16PerformanceGroup7releaseEyPKNS_13AutoStopwatchE(&mut *self,
                                                                it, owner)
    }
    #[inline]
    pub unsafe fn recentCycles(&mut self, iteration: u64) -> u64 {
        _ZNK2js16PerformanceGroup12recentCyclesEy(&mut *self, iteration)
    }
    #[inline]
    pub unsafe fn addRecentCycles(&mut self, iteration: u64, cycles: u64) {
        _ZN2js16PerformanceGroup15addRecentCyclesEyy(&mut *self, iteration,
                                                     cycles)
    }
    #[inline]
    pub unsafe fn recentTicks(&mut self, iteration: u64) -> u64 {
        _ZNK2js16PerformanceGroup11recentTicksEy(&mut *self, iteration)
    }
    #[inline]
    pub unsafe fn addRecentTicks(&mut self, iteration: u64, ticks: u64) {
        _ZN2js16PerformanceGroup14addRecentTicksEyy(&mut *self, iteration,
                                                    ticks)
    }
    #[inline]
    pub unsafe fn recentCPOW(&mut self, iteration: u64) -> u64 {
        _ZNK2js16PerformanceGroup10recentCPOWEy(&mut *self, iteration)
    }
    #[inline]
    pub unsafe fn addRecentCPOW(&mut self, iteration: u64, CPOW: u64) {
        _ZN2js16PerformanceGroup13addRecentCPOWEyy(&mut *self, iteration,
                                                   CPOW)
    }
    #[inline]
    pub unsafe fn resetRecentData(&mut self) {
        _ZN2js16PerformanceGroup15resetRecentDataEv(&mut *self)
    }
    #[inline]
    pub unsafe fn isActive(&mut self) -> bool {
        _ZNK2js16PerformanceGroup8isActiveEv(&mut *self)
    }
    #[inline]
    pub unsafe fn setIsActive(&mut self, arg1: bool) {
        _ZN2js16PerformanceGroup11setIsActiveEb(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn isUsedInThisIteration(&mut self) -> bool {
        _ZNK2js16PerformanceGroup21isUsedInThisIterationEv(&mut *self)
    }
    #[inline]
    pub unsafe fn setIsUsedInThisIteration(&mut self, arg1: bool) {
        _ZN2js16PerformanceGroup24setIsUsedInThisIterationEb(&mut *self, arg1)
    }
    #[inline]
    pub unsafe fn AddRef(&mut self) {
        _ZN2js16PerformanceGroup6AddRefEv(&mut *self)
    }
    #[inline]
    pub unsafe fn Release(&mut self) {
        _ZN2js16PerformanceGroup7ReleaseEv(&mut *self)
    }
}
pub type StopwatchStartCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: u64,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type jsbytecode = u8;
pub type IsAcceptableThis =
    ::std::option::Option<unsafe extern "C" fn(v: HandleValue) -> bool>;
pub type NativeImpl =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               args: *const CallArgs)
                              -> bool>;
pub enum JSLinearString { }
pub enum BaseProxyHandler { }
pub enum InterpreterFrame { }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum jsfriendapi_h_unnamed_10 {
    JS_TELEMETRY_GC_REASON = 0,
    JS_TELEMETRY_GC_IS_COMPARTMENTAL = 1,
    JS_TELEMETRY_GC_MS = 2,
    JS_TELEMETRY_GC_BUDGET_MS = 3,
    JS_TELEMETRY_GC_ANIMATION_MS = 4,
    JS_TELEMETRY_GC_MAX_PAUSE_MS = 5,
    JS_TELEMETRY_GC_MARK_MS = 6,
    JS_TELEMETRY_GC_SWEEP_MS = 7,
    JS_TELEMETRY_GC_COMPACT_MS = 8,
    JS_TELEMETRY_GC_MARK_ROOTS_MS = 9,
    JS_TELEMETRY_GC_MARK_GRAY_MS = 10,
    JS_TELEMETRY_GC_SLICE_MS = 11,
    JS_TELEMETRY_GC_SLOW_PHASE = 12,
    JS_TELEMETRY_GC_MMU_50 = 13,
    JS_TELEMETRY_GC_RESET = 14,
    JS_TELEMETRY_GC_INCREMENTAL_DISABLED = 15,
    JS_TELEMETRY_GC_NON_INCREMENTAL = 16,
    JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS = 17,
    JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS = 18,
    JS_TELEMETRY_GC_MINOR_REASON = 19,
    JS_TELEMETRY_GC_MINOR_REASON_LONG = 20,
    JS_TELEMETRY_GC_MINOR_US = 21,
    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT = 22,
    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS = 23,
    JS_TELEMETRY_ADDON_EXCEPTIONS = 24,
    JS_TELEMETRY_DEFINE_GETTER_SETTER_THIS_NULL_UNDEFINED = 25,
    JS_TELEMETRY_END = 26,
}
pub type JSAccumulateTelemetryDataCallback =
    ::std::option::Option<unsafe extern "C" fn(id: ::std::os::raw::c_int,
                                               sample: u32,
                                               key:
                                                   *const ::std::os::raw::c_char)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum jsfriendapi_h_unnamed_11 {
    MakeNonConfigurableIntoConfigurable = 0,
    CopyNonConfigurableAsIs = 1,
}
pub type PropertyCopyBehavior = jsfriendapi_h_unnamed_11;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSFunctionSpecWithHelp {
    pub name: *const ::std::os::raw::c_char,
    pub call: JSNative,
    pub nargs: u16,
    pub flags: u16,
    pub jitInfo: *const JSJitInfo,
    pub usage: *const ::std::os::raw::c_char,
    pub help: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for JSFunctionSpecWithHelp {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSFunctionSpecWithHelp() {
    assert_eq!(::std::mem::size_of::<JSFunctionSpecWithHelp>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSFunctionSpecWithHelp>() , 8usize);
}
/**
 * A class of objects that return source code on demand.
 *
 * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
 * retain the source code (and doesn't do lazy bytecode generation). If we ever
 * need the source code, say, in response to a call to Function.prototype.
 * toSource or Debugger.Source.prototype.text, then we call the 'load' member
 * function of the instance of this class that has hopefully been registered
 * with the runtime, passing the code's URL, and hope that it will be able to
 * find the source.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct SourceHook {
    pub _vftable: *const _vftable_SourceHook,
}
#[repr(C)]
pub struct _vftable_SourceHook {
    pub load: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                   cx: *mut JSContext,
                                   filename: *const ::std::os::raw::c_char,
                                   src: *mut *mut ::std::os::raw::c_ushort,
                                   length: *mut usize) -> bool,
}
#[test]
fn bindgen_test_layout_SourceHook() {
    assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize);
    assert_eq!(::std::mem::align_of::<SourceHook>() , 8usize);
}
pub type PreserveWrapperCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: *mut JSObject) -> bool>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum jsfriendapi_h_unnamed_12 {
    CollectNurseryBeforeDump = 0,
    IgnoreNurseryObjects = 1,
}
pub type DumpHeapNurseryBehaviour = jsfriendapi_h_unnamed_12;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WeakMapTracer {
    pub _vftable: *const _vftable_WeakMapTracer,
    pub runtime: *mut JSRuntime,
}
#[repr(C)]
pub struct _vftable_WeakMapTracer {
    pub trace: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                    m: *mut JSObject, key: GCCellPtr,
                                    value: GCCellPtr),
}
impl ::std::clone::Clone for WeakMapTracer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_WeakMapTracer() {
    assert_eq!(::std::mem::size_of::<WeakMapTracer>() , 16usize);
    assert_eq!(::std::mem::align_of::<WeakMapTracer>() , 8usize);
}
pub type GCThingCallback =
    ::std::option::Option<unsafe extern "C" fn(closure:
                                                   *mut ::std::os::raw::c_void,
                                               thing: GCCellPtr)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectGroup {
    pub clasp: *const Class,
    pub proto: *mut JSObject,
    pub compartment: *mut JSCompartment,
}
impl ::std::clone::Clone for ObjectGroup {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectGroup() {
    assert_eq!(::std::mem::size_of::<ObjectGroup>() , 24usize);
    assert_eq!(::std::mem::align_of::<ObjectGroup>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BaseShape {
    pub clasp_: *const Class,
    pub parent: *mut JSObject,
}
impl ::std::clone::Clone for BaseShape {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_BaseShape() {
    assert_eq!(::std::mem::size_of::<BaseShape>() , 16usize);
    assert_eq!(::std::mem::align_of::<BaseShape>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Shape {
    pub base: *mut BaseShape,
    pub _1: jsid,
    pub slotInfo: u32,
}
impl ::std::clone::Clone for Shape {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Shape() {
    assert_eq!(::std::mem::size_of::<Shape>() , 24usize);
    assert_eq!(::std::mem::align_of::<Shape>() , 8usize);
}
/**
 * This layout is shared by all native objects. For non-native objects, the
 * group may always be accessed safely, and other members may be as well,
 * depending on the object's specific layout.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Object {
    pub group: *mut ObjectGroup,
    pub shape: *mut Shape,
    pub slots: *mut Value,
    pub _1: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Object {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Object() {
    assert_eq!(::std::mem::size_of::<Object>() , 32usize);
    assert_eq!(::std::mem::align_of::<Object>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Function {
    pub base: Object,
    pub nargs: u16,
    pub flags: u16,
    pub native: JSNative,
    pub jitinfo: *const JSJitInfo,
    pub _1: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Function {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Function() {
    assert_eq!(::std::mem::size_of::<Function>() , 64usize);
    assert_eq!(::std::mem::align_of::<Function>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct String {
    pub flags: u32,
    pub length: u32,
    pub String_jsfriendapi_h_unnamed_13: String_jsfriendapi_h_unnamed_13,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct String_jsfriendapi_h_unnamed_13 {
    pub nonInlineCharsLatin1: __BindgenUnionField<*const Latin1Char>,
    pub nonInlineCharsTwoByte: __BindgenUnionField<*const ::std::os::raw::c_ushort>,
    pub inlineStorageLatin1: __BindgenUnionField<[Latin1Char; 1usize]>,
    pub inlineStorageTwoByte: __BindgenUnionField<[::std::os::raw::c_ushort; 1usize]>,
    pub _bindgen_data_: u64,
}
impl String_jsfriendapi_h_unnamed_13 {
    pub unsafe fn nonInlineCharsLatin1(&mut self) -> *mut *const Latin1Char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn nonInlineCharsTwoByte(&mut self)
     -> *mut *const ::std::os::raw::c_ushort {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn inlineStorageLatin1(&mut self)
     -> *mut [Latin1Char; 1usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn inlineStorageTwoByte(&mut self)
     -> *mut [::std::os::raw::c_ushort; 1usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for String_jsfriendapi_h_unnamed_13 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_String_jsfriendapi_h_unnamed_13() {
    assert_eq!(::std::mem::size_of::<String_jsfriendapi_h_unnamed_13>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<String_jsfriendapi_h_unnamed_13>() ,
               8usize);
}
impl ::std::clone::Clone for String {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_String() {
    assert_eq!(::std::mem::size_of::<String>() , 16usize);
    assert_eq!(::std::mem::align_of::<String>() , 8usize);
}
pub type ActivityCallback =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               active: bool)>;
pub type DOMInstanceClassHasProtoAtDepth =
    ::std::option::Option<unsafe extern "C" fn(instanceClass: *const Class,
                                               protoID: u32, depth: u32)
                              -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSDOMCallbacks {
    pub instanceClassMatchesProto: DOMInstanceClassHasProtoAtDepth,
}
impl ::std::clone::Clone for JSDOMCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSDOMCallbacks() {
    assert_eq!(::std::mem::size_of::<JSDOMCallbacks>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSDOMCallbacks>() , 8usize);
}
pub type DOMCallbacks = JSDOMCallbacks;
pub enum RegExpGuard { }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum NukeReferencesToWindow {
    NukeWindowReferences = 0,
    DontNukeWindowReferences = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentFilter {
    pub _vftable: *const _vftable_CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_CompartmentFilter {
    pub match_: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                     c: *mut JSCompartment) -> bool,
}
impl ::std::clone::Clone for CompartmentFilter {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentFilter() {
    assert_eq!(::std::mem::size_of::<CompartmentFilter>() , 8usize);
    assert_eq!(::std::mem::align_of::<CompartmentFilter>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AllCompartments {
    pub _base: CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_AllCompartments {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for AllCompartments {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ContentCompartmentsOnly {
    pub _base: CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_ContentCompartmentsOnly {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for ContentCompartmentsOnly {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ChromeCompartmentsOnly {
    pub _base: CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_ChromeCompartmentsOnly {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for ChromeCompartmentsOnly {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SingleCompartment {
    pub _base: CompartmentFilter,
    pub ours: *mut JSCompartment,
}
#[repr(C)]
pub struct _vftable_SingleCompartment {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for SingleCompartment {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SingleCompartment() {
    assert_eq!(::std::mem::size_of::<SingleCompartment>() , 16usize);
    assert_eq!(::std::mem::align_of::<SingleCompartment>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentsWithPrincipals {
    pub _base: CompartmentFilter,
    pub principals: *mut JSPrincipals,
}
#[repr(C)]
pub struct _vftable_CompartmentsWithPrincipals {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for CompartmentsWithPrincipals {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentsWithPrincipals() {
    assert_eq!(::std::mem::size_of::<CompartmentsWithPrincipals>() , 16usize);
    assert_eq!(::std::mem::align_of::<CompartmentsWithPrincipals>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ExpandoAndGeneration {
    pub expando: Heap<Value>,
    pub generation: u64,
}
#[test]
fn bindgen_test_layout_ExpandoAndGeneration() {
    assert_eq!(::std::mem::size_of::<ExpandoAndGeneration>() , 16usize);
    assert_eq!(::std::mem::align_of::<ExpandoAndGeneration>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum DOMProxyShadowsResult {
    ShadowCheckFailed = 0,
    Shadows = 1,
    DoesntShadow = 2,
    DoesntShadowUnique = 3,
    ShadowsViaDirectExpando = 4,
    ShadowsViaIndirectExpando = 5,
}
pub type DOMProxyShadowsCheck =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               object: HandleObject,
                                               id: HandleId)
                              -> DOMProxyShadowsResult>;
/**
 * Report an exception, which is currently realized as a printf-style format
 * string and its arguments.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSErrNum {
    JSMSG_NOT_AN_ERROR = 0,
    JSMSG_NOT_DEFINED = 1,
    JSMSG_MORE_ARGS_NEEDED = 2,
    JSMSG_INCOMPATIBLE_PROTO = 3,
    JSMSG_NO_CONSTRUCTOR = 4,
    JSMSG_BAD_SORT_ARG = 5,
    JSMSG_CANT_WATCH = 6,
    JSMSG_READ_ONLY = 7,
    JSMSG_CANT_DELETE = 8,
    JSMSG_CANT_TRUNCATE_ARRAY = 9,
    JSMSG_NOT_FUNCTION = 10,
    JSMSG_NOT_CONSTRUCTOR = 11,
    JSMSG_CANT_CONVERT_TO = 12,
    JSMSG_TOPRIMITIVE_NOT_CALLABLE = 13,
    JSMSG_TOPRIMITIVE_RETURNED_OBJECT = 14,
    JSMSG_NO_PROPERTIES = 15,
    JSMSG_BAD_REGEXP_FLAG = 16,
    JSMSG_ARG_INDEX_OUT_OF_RANGE = 17,
    JSMSG_SPREAD_TOO_LARGE = 18,
    JSMSG_BAD_WEAKMAP_KEY = 19,
    JSMSG_BAD_GETTER_OR_SETTER = 20,
    JSMSG_BAD_ARRAY_LENGTH = 21,
    JSMSG_REDECLARED_VAR = 22,
    JSMSG_UNDECLARED_VAR = 23,
    JSMSG_GETTER_ONLY = 24,
    JSMSG_OVERWRITING_ACCESSOR = 25,
    JSMSG_UNDEFINED_PROP = 26,
    JSMSG_INVALID_MAP_ITERABLE = 27,
    JSMSG_NESTING_GENERATOR = 28,
    JSMSG_INCOMPATIBLE_METHOD = 29,
    JSMSG_OBJECT_WATCH_DEPRECATED = 30,
    JSMSG_BAD_SURROGATE_CHAR = 31,
    JSMSG_UTF8_CHAR_TOO_LARGE = 32,
    JSMSG_MALFORMED_UTF8_CHAR = 33,
    JSMSG_BUILTIN_CTOR_NO_NEW = 34,
    JSMSG_BAD_GENERATOR_YIELD = 35,
    JSMSG_EMPTY_ARRAY_REDUCE = 36,
    JSMSG_UNEXPECTED_TYPE = 37,
    JSMSG_MISSING_FUN_ARG = 38,
    JSMSG_NOT_NONNULL_OBJECT = 39,
    JSMSG_SET_NON_OBJECT_RECEIVER = 40,
    JSMSG_INVALID_DESCRIPTOR = 41,
    JSMSG_OBJECT_NOT_EXTENSIBLE = 42,
    JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE = 43,
    JSMSG_CANT_REDEFINE_PROP = 44,
    JSMSG_CANT_REDEFINE_ARRAY_LENGTH = 45,
    JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH = 46,
    JSMSG_BAD_GET_SET_FIELD = 47,
    JSMSG_THROW_TYPE_ERROR = 48,
    JSMSG_NOT_EXPECTED_TYPE = 49,
    JSMSG_NOT_ITERABLE = 50,
    JSMSG_ALREADY_HAS_PRAGMA = 51,
    JSMSG_NEXT_RETURNED_PRIMITIVE = 52,
    JSMSG_CANT_SET_PROTO = 53,
    JSMSG_CANT_SET_PROTO_OF = 54,
    JSMSG_CANT_SET_PROTO_CYCLE = 55,
    JSMSG_INVALID_ARG_TYPE = 56,
    JSMSG_TERMINATED = 57,
    JSMSG_PROTO_NOT_OBJORNULL = 58,
    JSMSG_CANT_CALL_CLASS_CONSTRUCTOR = 59,
    JSMSG_UNINITIALIZED_THIS = 60,
    JSMSG_UNINITIALIZED_THIS_ARROW = 61,
    JSMSG_BAD_DERIVED_RETURN = 62,
    JSMSG_JSON_BAD_PARSE = 63,
    JSMSG_JSON_CYCLIC_VALUE = 64,
    JSMSG_BAD_INSTANCEOF_RHS = 65,
    JSMSG_BAD_LEFTSIDE_OF_ASS = 66,
    JSMSG_BAD_PROTOTYPE = 67,
    JSMSG_IN_NOT_OBJECT = 68,
    JSMSG_TOO_MANY_CON_SPREADARGS = 69,
    JSMSG_TOO_MANY_FUN_SPREADARGS = 70,
    JSMSG_UNINITIALIZED_LEXICAL = 71,
    JSMSG_BAD_CONST_ASSIGN = 72,
    JSMSG_INVALID_DATE = 73,
    JSMSG_BAD_TOISOSTRING_PROP = 74,
    JSMSG_BAD_URI = 75,
    JSMSG_INVALID_NORMALIZE_FORM = 76,
    JSMSG_NEGATIVE_REPETITION_COUNT = 77,
    JSMSG_NOT_A_CODEPOINT = 78,
    JSMSG_RESULTING_STRING_TOO_LARGE = 79,
    JSMSG_BAD_RADIX = 80,
    JSMSG_PRECISION_RANGE = 81,
    JSMSG_BAD_APPLY_ARGS = 82,
    JSMSG_BAD_FORMAL = 83,
    JSMSG_CALLER_IS_STRICT = 84,
    JSMSG_DEPRECATED_USAGE = 85,
    JSMSG_NOT_SCRIPTED_FUNCTION = 86,
    JSMSG_NO_REST_NAME = 87,
    JSMSG_PARAMETER_AFTER_REST = 88,
    JSMSG_TOO_MANY_FUN_APPLY_ARGS = 89,
    JSMSG_CSP_BLOCKED_EVAL = 90,
    JSMSG_CSP_BLOCKED_FUNCTION = 91,
    JSMSG_ACCESSOR_DEF_DENIED = 92,
    JSMSG_DEAD_OBJECT = 93,
    JSMSG_UNWRAP_DENIED = 94,
    JSMSG_BAD_CLONE_FUNOBJ_SCOPE = 95,
    JSMSG_CANT_CLONE_OBJECT = 96,
    JSMSG_CANT_OPEN = 97,
    JSMSG_USER_DEFINED_ERROR = 98,
    JSMSG_ALLOC_OVERFLOW = 99,
    JSMSG_BAD_BUILD_ID = 100,
    JSMSG_BAD_BYTECODE = 101,
    JSMSG_BUFFER_TOO_SMALL = 102,
    JSMSG_BUILD_ID_NOT_AVAILABLE = 103,
    JSMSG_BYTECODE_TOO_BIG = 104,
    JSMSG_ERR_DURING_THROW = 105,
    JSMSG_NEED_DIET = 106,
    JSMSG_OUT_OF_MEMORY = 107,
    JSMSG_OVER_RECURSED = 108,
    JSMSG_TOO_BIG_TO_ENCODE = 109,
    JSMSG_TOO_DEEP = 110,
    JSMSG_UNCAUGHT_EXCEPTION = 111,
    JSMSG_UNKNOWN_FORMAT = 112,
    JSMSG_ACCESSOR_WRONG_ARGS = 113,
    JSMSG_ARRAY_COMP_LEFTSIDE = 114,
    JSMSG_ARRAY_INIT_TOO_BIG = 115,
    JSMSG_AS_AFTER_IMPORT_STAR = 116,
    JSMSG_AS_AFTER_RESERVED_WORD = 117,
    JSMSG_BAD_ANON_GENERATOR_RETURN = 118,
    JSMSG_BAD_ARROW_ARGS = 119,
    JSMSG_BAD_BINDING = 120,
    JSMSG_BAD_CONST_DECL = 121,
    JSMSG_BAD_CONTINUE = 122,
    JSMSG_BAD_DESTRUCT_ASS = 123,
    JSMSG_BAD_DESTRUCT_TARGET = 124,
    JSMSG_BAD_DESTRUCT_PARENS = 125,
    JSMSG_BAD_DESTRUCT_DECL = 126,
    JSMSG_BAD_DUP_ARGS = 127,
    JSMSG_BAD_FOR_EACH_LOOP = 128,
    JSMSG_BAD_FOR_LEFTSIDE = 129,
    JSMSG_LEXICAL_DECL_DEFINES_LET = 130,
    JSMSG_LET_STARTING_FOROF_LHS = 131,
    JSMSG_BAD_GENERATOR_RETURN = 132,
    JSMSG_BAD_GENEXP_BODY = 133,
    JSMSG_BAD_INCOP_OPERAND = 134,
    JSMSG_BAD_METHOD_DEF = 135,
    JSMSG_BAD_OCTAL = 136,
    JSMSG_BAD_OPERAND = 137,
    JSMSG_BAD_PROP_ID = 138,
    JSMSG_BAD_RETURN_OR_YIELD = 139,
    JSMSG_BAD_STRICT_ASSIGN = 140,
    JSMSG_BAD_SWITCH = 141,
    JSMSG_BAD_SUPER = 142,
    JSMSG_BAD_SUPERPROP = 143,
    JSMSG_BAD_SUPERCALL = 144,
    JSMSG_BRACKET_AFTER_ARRAY_COMPREHENSION = 145,
    JSMSG_BRACKET_AFTER_LIST = 146,
    JSMSG_BRACKET_IN_INDEX = 147,
    JSMSG_CATCH_AFTER_GENERAL = 148,
    JSMSG_CATCH_IDENTIFIER = 149,
    JSMSG_CATCH_OR_FINALLY = 150,
    JSMSG_CATCH_WITHOUT_TRY = 151,
    JSMSG_COLON_AFTER_CASE = 152,
    JSMSG_COLON_AFTER_ID = 153,
    JSMSG_COLON_IN_COND = 154,
    JSMSG_COMP_PROP_UNTERM_EXPR = 155,
    JSMSG_CONTRARY_NONDIRECTIVE = 156,
    JSMSG_CURLY_AFTER_BODY = 157,
    JSMSG_CURLY_AFTER_CATCH = 158,
    JSMSG_CURLY_AFTER_FINALLY = 159,
    JSMSG_CURLY_AFTER_LIST = 160,
    JSMSG_CURLY_AFTER_TRY = 161,
    JSMSG_CURLY_BEFORE_BODY = 162,
    JSMSG_CURLY_BEFORE_CATCH = 163,
    JSMSG_CURLY_BEFORE_CLASS = 164,
    JSMSG_CURLY_BEFORE_FINALLY = 165,
    JSMSG_CURLY_BEFORE_SWITCH = 166,
    JSMSG_CURLY_BEFORE_TRY = 167,
    JSMSG_CURLY_IN_COMPOUND = 168,
    JSMSG_DECLARATION_AFTER_EXPORT = 169,
    JSMSG_DECLARATION_AFTER_IMPORT = 170,
    JSMSG_DEPRECATED_DELETE_OPERAND = 171,
    JSMSG_DEPRECATED_EXPR_CLOSURE = 172,
    JSMSG_DEPRECATED_FOR_EACH = 173,
    JSMSG_DEPRECATED_OCTAL = 174,
    JSMSG_DEPRECATED_PRAGMA = 175,
    JSMSG_DEPRECATED_BLOCK_SCOPE_FUN_REDECL = 176,
    JSMSG_DUPLICATE_EXPORT_NAME = 177,
    JSMSG_DUPLICATE_FORMAL = 178,
    JSMSG_DUPLICATE_LABEL = 179,
    JSMSG_DUPLICATE_PROPERTY = 180,
    JSMSG_EMPTY_CONSEQUENT = 181,
    JSMSG_EQUAL_AS_ASSIGN = 182,
    JSMSG_EXPORT_DECL_AT_TOP_LEVEL = 183,
    JSMSG_FINALLY_WITHOUT_TRY = 184,
    JSMSG_FROM_AFTER_IMPORT_CLAUSE = 185,
    JSMSG_FROM_AFTER_EXPORT_STAR = 186,
    JSMSG_GARBAGE_AFTER_INPUT = 187,
    JSMSG_IDSTART_AFTER_NUMBER = 188,
    JSMSG_ILLEGAL_CHARACTER = 189,
    JSMSG_IMPORT_DECL_AT_TOP_LEVEL = 190,
    JSMSG_INVALID_FOR_IN_DECL_WITH_INIT = 191,
    JSMSG_LABEL_NOT_FOUND = 192,
    JSMSG_LET_CLASS_BINDING = 193,
    JSMSG_LET_COMP_BINDING = 194,
    JSMSG_LEXICAL_DECL_NOT_IN_BLOCK = 195,
    JSMSG_LEXICAL_DECL_LABEL = 196,
    JSMSG_FUNCTION_LABEL = 197,
    JSMSG_SLOPPY_FUNCTION_LABEL = 198,
    JSMSG_LINE_BREAK_AFTER_THROW = 199,
    JSMSG_MALFORMED_ESCAPE = 200,
    JSMSG_MISSING_BINARY_DIGITS = 201,
    JSMSG_MISSING_EXPONENT = 202,
    JSMSG_MISSING_EXPR_AFTER_THROW = 203,
    JSMSG_MISSING_FORMAL = 204,
    JSMSG_MISSING_HEXDIGITS = 205,
    JSMSG_MISSING_OCTAL_DIGITS = 206,
    JSMSG_MODULE_SPEC_AFTER_FROM = 207,
    JSMSG_NAME_AFTER_DOT = 208,
    JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT = 209,
    JSMSG_NO_BINDING_NAME = 210,
    JSMSG_NO_EXPORT_NAME = 211,
    JSMSG_NO_IMPORT_NAME = 212,
    JSMSG_NO_VARIABLE_NAME = 213,
    JSMSG_OF_AFTER_FOR_NAME = 214,
    JSMSG_PAREN_AFTER_ARGS = 215,
    JSMSG_PAREN_AFTER_CATCH = 216,
    JSMSG_PAREN_AFTER_COND = 217,
    JSMSG_PAREN_AFTER_FOR = 218,
    JSMSG_PAREN_AFTER_FORMAL = 219,
    JSMSG_PAREN_AFTER_FOR_CTRL = 220,
    JSMSG_PAREN_AFTER_FOR_OF_ITERABLE = 221,
    JSMSG_PAREN_AFTER_SWITCH = 222,
    JSMSG_PAREN_AFTER_WITH = 223,
    JSMSG_PAREN_BEFORE_CATCH = 224,
    JSMSG_PAREN_BEFORE_COND = 225,
    JSMSG_PAREN_BEFORE_FORMAL = 226,
    JSMSG_PAREN_BEFORE_SWITCH = 227,
    JSMSG_PAREN_BEFORE_WITH = 228,
    JSMSG_PAREN_IN_PAREN = 229,
    JSMSG_RC_AFTER_EXPORT_SPEC_LIST = 230,
    JSMSG_RC_AFTER_IMPORT_SPEC_LIST = 231,
    JSMSG_REDECLARED_CATCH_IDENTIFIER = 232,
    JSMSG_REDECLARED_PARAM = 233,
    JSMSG_RESERVED_ID = 234,
    JSMSG_REST_WITH_DEFAULT = 235,
    JSMSG_SELFHOSTED_TOP_LEVEL_LEXICAL = 236,
    JSMSG_SELFHOSTED_UNBOUND_NAME = 237,
    JSMSG_SEMI_AFTER_FOR_COND = 238,
    JSMSG_SEMI_AFTER_FOR_INIT = 239,
    JSMSG_SEMI_BEFORE_STMNT = 240,
    JSMSG_SOURCE_TOO_LONG = 241,
    JSMSG_STMT_AFTER_RETURN = 242,
    JSMSG_STRICT_CODE_WITH = 243,
    JSMSG_TEMPLSTR_UNTERM_EXPR = 244,
    JSMSG_SIMD_NOT_A_VECTOR = 245,
    JSMSG_TOO_MANY_CASES = 246,
    JSMSG_TOO_MANY_CATCH_VARS = 247,
    JSMSG_TOO_MANY_CON_ARGS = 248,
    JSMSG_TOO_MANY_DEFAULTS = 249,
    JSMSG_TOO_MANY_FUN_ARGS = 250,
    JSMSG_TOO_MANY_LOCALS = 251,
    JSMSG_TOO_MANY_YIELDS = 252,
    JSMSG_TOUGH_BREAK = 253,
    JSMSG_UNEXPECTED_TOKEN = 254,
    JSMSG_UNNAMED_CLASS_STMT = 255,
    JSMSG_UNNAMED_FUNCTION_STMT = 256,
    JSMSG_UNTERMINATED_COMMENT = 257,
    JSMSG_UNTERMINATED_REGEXP = 258,
    JSMSG_UNTERMINATED_STRING = 259,
    JSMSG_USELESS_EXPR = 260,
    JSMSG_USE_ASM_DIRECTIVE_FAIL = 261,
    JSMSG_VAR_HIDES_ARG = 262,
    JSMSG_WHILE_AFTER_DO = 263,
    JSMSG_YIELD_IN_ARROW = 264,
    JSMSG_YIELD_IN_DEFAULT = 265,
    JSMSG_BAD_COLUMN_NUMBER = 266,
    JSMSG_COMPUTED_NAME_IN_PATTERN = 267,
    JSMSG_DEFAULT_IN_PATTERN = 268,
    JSMSG_BAD_NEWTARGET = 269,
    JSMSG_ESCAPED_KEYWORD = 270,
    JSMSG_USE_ASM_TYPE_FAIL = 271,
    JSMSG_USE_ASM_LINK_FAIL = 272,
    JSMSG_USE_ASM_TYPE_OK = 273,
    JSMSG_WASM_FAIL = 274,
    JSMSG_WASM_DECODE_FAIL = 275,
    JSMSG_WASM_TEXT_FAIL = 276,
    JSMSG_WASM_BAD_IND_CALL = 277,
    JSMSG_WASM_BAD_BUF_ARG = 278,
    JSMSG_WASM_BAD_IMPORT_ARG = 279,
    JSMSG_WASM_UNREACHABLE = 280,
    JSMSG_WASM_INTEGER_OVERFLOW = 281,
    JSMSG_WASM_INVALID_CONVERSION = 282,
    JSMSG_WASM_INT_DIVIDE_BY_ZERO = 283,
    JSMSG_WASM_OVERRECURSED = 284,
    JSMSG_BAD_TRAP_RETURN_VALUE = 285,
    JSMSG_BAD_GETPROTOTYPEOF_TRAP_RETURN = 286,
    JSMSG_INCONSISTENT_GETPROTOTYPEOF_TRAP = 287,
    JSMSG_PROXY_SETPROTOTYPEOF_RETURNED_FALSE = 288,
    JSMSG_PROXY_ISEXTENSIBLE_RETURNED_FALSE = 289,
    JSMSG_INCONSISTENT_SETPROTOTYPEOF_TRAP = 290,
    JSMSG_CANT_CHANGE_EXTENSIBILITY = 291,
    JSMSG_CANT_DEFINE_INVALID = 292,
    JSMSG_CANT_DEFINE_NEW = 293,
    JSMSG_CANT_DEFINE_NE_AS_NC = 294,
    JSMSG_PROXY_DEFINE_RETURNED_FALSE = 295,
    JSMSG_PROXY_DELETE_RETURNED_FALSE = 296,
    JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE = 297,
    JSMSG_PROXY_SET_RETURNED_FALSE = 298,
    JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 299,
    JSMSG_CANT_REPORT_C_AS_NC = 300,
    JSMSG_CANT_REPORT_E_AS_NE = 301,
    JSMSG_CANT_REPORT_INVALID = 302,
    JSMSG_CANT_REPORT_NC_AS_NE = 303,
    JSMSG_CANT_REPORT_NEW = 304,
    JSMSG_CANT_REPORT_NE_AS_NC = 305,
    JSMSG_CANT_SET_NW_NC = 306,
    JSMSG_CANT_SET_WO_SETTER = 307,
    JSMSG_CANT_SKIP_NC = 308,
    JSMSG_ONWKEYS_STR_SYM = 309,
    JSMSG_MUST_REPORT_SAME_VALUE = 310,
    JSMSG_MUST_REPORT_UNDEFINED = 311,
    JSMSG_OBJECT_ACCESS_DENIED = 312,
    JSMSG_PROPERTY_ACCESS_DENIED = 313,
    JSMSG_PROXY_CONSTRUCT_OBJECT = 314,
    JSMSG_PROXY_EXTENSIBILITY = 315,
    JSMSG_PROXY_GETOWN_OBJORUNDEF = 316,
    JSMSG_PROXY_REVOKED = 317,
    JSMSG_PROXY_ARG_REVOKED = 318,
    JSMSG_BAD_TRAP = 319,
    JSMSG_SC_BAD_CLONE_VERSION = 320,
    JSMSG_SC_BAD_SERIALIZED_DATA = 321,
    JSMSG_SC_DUP_TRANSFERABLE = 322,
    JSMSG_SC_NOT_TRANSFERABLE = 323,
    JSMSG_SC_UNSUPPORTED_TYPE = 324,
    JSMSG_SC_SHMEM_MUST_TRANSFER = 325,
    JSMSG_ASSIGN_FUNCTION_OR_NULL = 326,
    JSMSG_DEBUG_BAD_LINE = 327,
    JSMSG_DEBUG_BAD_OFFSET = 328,
    JSMSG_DEBUG_BAD_REFERENT = 329,
    JSMSG_DEBUG_BAD_RESUMPTION = 330,
    JSMSG_DEBUG_CANT_DEBUG_GLOBAL = 331,
    JSMSG_DEBUG_CCW_REQUIRED = 332,
    JSMSG_DEBUG_COMPARTMENT_MISMATCH = 333,
    JSMSG_DEBUG_LOOP = 334,
    JSMSG_DEBUG_NOT_DEBUGGEE = 335,
    JSMSG_DEBUG_NOT_DEBUGGING = 336,
    JSMSG_DEBUG_NOT_IDLE = 337,
    JSMSG_DEBUG_NOT_LIVE = 338,
    JSMSG_DEBUG_NO_SCOPE_OBJECT = 339,
    JSMSG_DEBUG_OBJECT_PROTO = 340,
    JSMSG_DEBUG_OBJECT_WRONG_OWNER = 341,
    JSMSG_DEBUG_OPTIMIZED_OUT = 342,
    JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED = 343,
    JSMSG_DEBUG_VARIABLE_NOT_FOUND = 344,
    JSMSG_DEBUG_WRAPPER_IN_WAY = 345,
    JSMSG_DEBUGGEE_WOULD_RUN = 346,
    JSMSG_NOT_CALLABLE_OR_UNDEFINED = 347,
    JSMSG_NOT_TRACKING_ALLOCATIONS = 348,
    JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET = 349,
    JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 350,
    JSMSG_QUERY_LINE_WITHOUT_URL = 351,
    JSMSG_DEBUG_CANT_SET_OPT_ENV = 352,
    JSMSG_DEBUG_INVISIBLE_COMPARTMENT = 353,
    JSMSG_DEBUG_CENSUS_BREAKDOWN = 354,
    JSMSG_DEBUG_PROMISE_NOT_RESOLVED = 355,
    JSMSG_TRACELOGGER_ENABLE_FAIL = 356,
    JSMSG_DATE_NOT_FINITE = 357,
    JSMSG_INTERNAL_INTL_ERROR = 358,
    JSMSG_INTL_OBJECT_NOT_INITED = 359,
    JSMSG_INTL_OBJECT_REINITED = 360,
    JSMSG_INVALID_CURRENCY_CODE = 361,
    JSMSG_INVALID_DIGITS_VALUE = 362,
    JSMSG_INVALID_LANGUAGE_TAG = 363,
    JSMSG_INVALID_LOCALES_ELEMENT = 364,
    JSMSG_INVALID_LOCALE_MATCHER = 365,
    JSMSG_INVALID_OPTION_VALUE = 366,
    JSMSG_INVALID_TIME_ZONE = 367,
    JSMSG_UNDEFINED_CURRENCY = 368,
    JSMSG_BACK_REF_OUT_OF_RANGE = 369,
    JSMSG_BAD_CLASS_RANGE = 370,
    JSMSG_ESCAPE_AT_END_OF_REGEXP = 371,
    JSMSG_EXEC_NOT_OBJORNULL = 372,
    JSMSG_INVALID_DECIMAL_ESCAPE = 373,
    JSMSG_INVALID_GROUP = 374,
    JSMSG_INVALID_IDENTITY_ESCAPE = 375,
    JSMSG_INVALID_UNICODE_ESCAPE = 376,
    JSMSG_MISSING_PAREN = 377,
    JSMSG_NEWREGEXP_FLAGGED = 378,
    JSMSG_NOTHING_TO_REPEAT = 379,
    JSMSG_NUMBERS_OUT_OF_ORDER = 380,
    JSMSG_RANGE_WITH_CLASS_ESCAPE = 381,
    JSMSG_RAW_BRACE_IN_REGEP = 382,
    JSMSG_RAW_BRACKET_IN_REGEP = 383,
    JSMSG_TOO_MANY_PARENS = 384,
    JSMSG_UNICODE_OVERFLOW = 385,
    JSMSG_UNMATCHED_RIGHT_PAREN = 386,
    JSMSG_UNTERM_CLASS = 387,
    JSMSG_DEFAULT_LOCALE_ERROR = 388,
    JSMSG_NO_SUCH_SELF_HOSTED_PROP = 389,
    JSMSG_INVALID_PROTOTYPE = 390,
    JSMSG_TYPEDOBJECT_BAD_ARGS = 391,
    JSMSG_TYPEDOBJECT_BINARYARRAY_BAD_INDEX = 392,
    JSMSG_TYPEDOBJECT_HANDLE_UNATTACHED = 393,
    JSMSG_TYPEDOBJECT_STRUCTTYPE_BAD_ARGS = 394,
    JSMSG_TYPEDOBJECT_TOO_BIG = 395,
    JSMSG_SIMD_FAILED_CONVERSION = 396,
    JSMSG_SIMD_TO_NUMBER = 397,
    JSMSG_TOO_LONG_ARRAY = 398,
    JSMSG_BAD_INDEX = 399,
    JSMSG_NON_ARRAY_BUFFER_RETURNED = 400,
    JSMSG_SAME_ARRAY_BUFFER_RETURNED = 401,
    JSMSG_SHORT_ARRAY_BUFFER_RETURNED = 402,
    JSMSG_TYPED_ARRAY_BAD_ARGS = 403,
    JSMSG_TYPED_ARRAY_NEGATIVE_ARG = 404,
    JSMSG_TYPED_ARRAY_DETACHED = 405,
    JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS = 406,
    JSMSG_SHARED_ARRAY_BAD_LENGTH = 407,
    JSMSG_BAD_PARSE_NODE = 408,
    JSMSG_SYMBOL_TO_STRING = 409,
    JSMSG_SYMBOL_TO_NUMBER = 410,
    JSMSG_ATOMICS_BAD_ARRAY = 411,
    JSMSG_ATOMICS_TOO_LONG = 412,
    JSMSG_ATOMICS_WAIT_NOT_ALLOWED = 413,
    JSMSG_CANT_SET_INTERPOSED = 414,
    JSMSG_CANT_DEFINE_WINDOW_ELEMENT = 415,
    JSMSG_CANT_DELETE_WINDOW_ELEMENT = 416,
    JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY = 417,
    JSMSG_CANT_PREVENT_EXTENSIONS = 418,
    JSMSG_NO_NAMED_SETTER = 419,
    JSMSG_NO_INDEXED_SETTER = 420,
    JSMSG_CANT_DELETE_SUPER = 421,
    JSMSG_REINIT_THIS = 422,
    JSMSG_BAD_DEFAULT_EXPORT = 423,
    JSMSG_MISSING_INDIRECT_EXPORT = 424,
    JSMSG_AMBIGUOUS_INDIRECT_EXPORT = 425,
    JSMSG_MISSING_IMPORT = 426,
    JSMSG_AMBIGUOUS_IMPORT = 427,
    JSMSG_MISSING_NAMESPACE_EXPORT = 428,
    JSMSG_MISSING_EXPORT = 429,
    JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF = 430,
    JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY = 431,
    JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE = 432,
    JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE = 433,
    JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON = 434,
    JSErr_Limit = 435,
}
/**
 * Scalar types that can appear in typed arrays and typed objects.  The enum
 * values must to be kept in sync with the JS_SCALARTYPEREPR_ constants, as
 * well as the TypedArrayObject::classes and TypedArrayObject::protoClasses
 * definitions.
 */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Type {
    Int8 = 0,
    Uint8 = 1,
    Int16 = 2,
    Uint16 = 3,
    Int32 = 4,
    Uint32 = 5,
    Float32 = 6,
    Float64 = 7,
    Uint8Clamped = 8,
    MaxTypedArrayViewType = 9,
    Float32x4 = 10,
    Int8x16 = 11,
    Int16x8 = 12,
    Int32x4 = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum DetachDataDisposition { ChangeData = 0, KeepData = 1, }
#[repr(i16)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum InlinableNative { _BindgenOpaqueEnum = 0, }
/**
 * A class, expected to be passed by value, which represents the CallArgs for a
 * JSJitGetterOp.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitGetterCallArgs {
    pub _base: MutableHandleValue,
}
impl ::std::clone::Clone for JSJitGetterCallArgs {
    fn clone(&self) -> Self { *self }
}
/**
 * A class, expected to be passed by value, which represents the CallArgs for a
 * JSJitSetterOp.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitSetterCallArgs {
    pub _base: MutableHandleValue,
}
impl ::std::clone::Clone for JSJitSetterCallArgs {
    fn clone(&self) -> Self { *self }
}
/**
 * A class, expected to be passed by reference, which represents the CallArgs
 * for a JSJitMethodOp.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitMethodCallArgs {
    pub _base: CallArgsBase<NoUsedRval>,
}
impl ::std::clone::Clone for JSJitMethodCallArgs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitMethodCallArgsTraits;
impl ::std::clone::Clone for JSJitMethodCallArgsTraits {
    fn clone(&self) -> Self { *self }
}
pub type JSJitGetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               thisObj: HandleObject,
                                               specializedThis:
                                                   *mut ::std::os::raw::c_void,
                                               args: JSJitGetterCallArgs)
                              -> bool>;
pub type JSJitSetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               thisObj: HandleObject,
                                               specializedThis:
                                                   *mut ::std::os::raw::c_void,
                                               args: JSJitSetterCallArgs)
                              -> bool>;
pub type JSJitMethodOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               thisObj: HandleObject,
                                               specializedThis:
                                                   *mut ::std::os::raw::c_void,
                                               args:
                                                   *const JSJitMethodCallArgs)
                              -> bool>;
/**
 * This struct contains metadata passed from the DOM to the JS Engine for JIT
 * optimizations on DOM property accessors. Eventually, this should be made
 * available to general JSAPI users, but we are not currently ready to do so.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitInfo {
    pub call: *const ::std::os::raw::c_void,
    pub protoID: u16,
    pub depth: u16,
    /** The OpType that says what sort of function we are. */
    pub _bitfield_1: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitInfo_OpType {
    Getter = 0,
    Setter = 1,
    Method = 2,
    StaticMethod = 3,
    InlinableNative = 4,
    OpTypeCount = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitInfo_ArgType {
    String = 1,
    Integer = 2,
    Double = 4,
    Boolean = 8,
    Object = 16,
    Null = 32,
    Numeric = 6,
    Primitive = 47,
    ObjectOrNull = 48,
    Any = 63,
    ArgTypeListEnd = -2147483648,
}
/**
     * An enum that describes what this getter/setter/method aliases.  This
     * determines what things can be hoisted past this call, and if this
     * call is movable what it can be hoisted past.
     */
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitInfo_AliasSet {
    AliasNone = 0,
    AliasDOMSets = 1,
    AliasEverything = 2,
    AliasSetCount = 3,
}
impl JSJitInfo {
    #[inline]
    pub fn type_(&self) -> u32 {
        (self._bitfield_1 & (15usize as u32)) >> 0usize
    }
    #[inline]
    pub fn set_type_(&mut self, val: u8) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32) << 0usize) & (15usize as u32);
    }
    #[inline]
    pub fn aliasSet_(&self) -> u32 {
        (self._bitfield_1 & (240usize as u32)) >> 4usize
    }
    #[inline]
    pub fn set_aliasSet_(&mut self, val: u8) {
        self._bitfield_1 &= !(240usize as u32);
        self._bitfield_1 |= ((val as u32) << 4usize) & (240usize as u32);
    }
    #[inline]
    pub fn returnType_(&self) -> u32 {
        (self._bitfield_1 & (65280usize as u32)) >> 8usize
    }
    #[inline]
    pub fn set_returnType_(&mut self, val: u8) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |= ((val as u32) << 8usize) & (65280usize as u32);
    }
    #[inline]
    pub fn isInfallible(&self) -> u32 {
        (self._bitfield_1 & (65536usize as u32)) >> 16usize
    }
    #[inline]
    pub fn set_isInfallible(&mut self, val: bool) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |= ((val as u32) << 16usize) & (65536usize as u32);
    }
    #[inline]
    pub fn isMovable(&self) -> u32 {
        (self._bitfield_1 & (131072usize as u32)) >> 17usize
    }
    #[inline]
    pub fn set_isMovable(&mut self, val: bool) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |= ((val as u32) << 17usize) & (131072usize as u32);
    }
    #[inline]
    pub fn isEliminatable(&self) -> u32 {
        (self._bitfield_1 & (262144usize as u32)) >> 18usize
    }
    #[inline]
    pub fn set_isEliminatable(&mut self, val: bool) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |= ((val as u32) << 18usize) & (262144usize as u32);
    }
    #[inline]
    pub fn isAlwaysInSlot(&self) -> u32 {
        (self._bitfield_1 & (524288usize as u32)) >> 19usize
    }
    #[inline]
    pub fn set_isAlwaysInSlot(&mut self, val: bool) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |= ((val as u32) << 19usize) & (524288usize as u32);
    }
    #[inline]
    pub fn isLazilyCachedInSlot(&self) -> u32 {
        (self._bitfield_1 & (1048576usize as u32)) >> 20usize
    }
    #[inline]
    pub fn set_isLazilyCachedInSlot(&mut self, val: bool) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |= ((val as u32) << 20usize) & (1048576usize as u32);
    }
    #[inline]
    pub fn isTypedMethod(&self) -> u32 {
        (self._bitfield_1 & (2097152usize as u32)) >> 21usize
    }
    #[inline]
    pub fn set_isTypedMethod(&mut self, val: bool) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |= ((val as u32) << 21usize) & (2097152usize as u32);
    }
    #[inline]
    pub fn slotIndex(&self) -> u32 {
        (self._bitfield_1 & (4290772992usize as u32)) >> 22usize
    }
    #[inline]
    pub fn set_slotIndex(&mut self, val: u16) {
        self._bitfield_1 &= !(4290772992usize as u32);
        self._bitfield_1 |=
            ((val as u32) << 22usize) & (4290772992usize as u32);
    }
    pub const fn new_bitfield_1(type_: u8, aliasSet_: u8, returnType_: u8,
                                isInfallible: bool, isMovable: bool,
                                isEliminatable: bool, isAlwaysInSlot: bool,
                                isLazilyCachedInSlot: bool,
                                isTypedMethod: bool, slotIndex: u16) -> u32 {
        0 | ((type_ as u32) << 0u32) | ((aliasSet_ as u32) << 4u32) |
            ((returnType_ as u32) << 8u32) | ((isInfallible as u32) << 16u32)
            | ((isMovable as u32) << 17u32) |
            ((isEliminatable as u32) << 18u32) |
            ((isAlwaysInSlot as u32) << 19u32) |
            ((isLazilyCachedInSlot as u32) << 20u32) |
            ((isTypedMethod as u32) << 21u32) | ((slotIndex as u32) << 22u32)
    }
}
impl ::std::clone::Clone for JSJitInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSJitInfo() {
    assert_eq!(::std::mem::size_of::<JSJitInfo>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSJitInfo>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSTypedMethodJitInfo {
    pub base: JSJitInfo,
    pub argTypes: *const JSJitInfo_ArgType,
}
impl ::std::clone::Clone for JSTypedMethodJitInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSTypedMethodJitInfo() {
    assert_eq!(::std::mem::size_of::<JSTypedMethodJitInfo>() , 24usize);
    assert_eq!(::std::mem::align_of::<JSTypedMethodJitInfo>() , 8usize);
}
/**
 * If the embedder has registered a ScriptEnvironmentPreparer,
 * PrepareScriptEnvironmentAndInvoke will call the preparer's 'invoke' method
 * with the given |closure|, with the assumption that the preparer will set up
 * any state necessary to run script in |scope|, invoke |closure| with a valid
 * JSContext*, report any exceptions thrown from the closure, and return.
 *
 * If no preparer is registered, PrepareScriptEnvironmentAndInvoke will assert
 * that |rt| has exactly one JSContext associated with it, enter the compartment
 * of |scope| on that context, and invoke |closure|.
 *
 * In both cases, PrepareScriptEnvironmentAndInvoke will report any exceptions
 * that are thrown by the closure.  Consumers who want to propagate back
 * whether the closure succeeded should do so via members of the closure
 * itself.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScriptEnvironmentPreparer {
    pub _vftable: *const _vftable_ScriptEnvironmentPreparer,
}
#[repr(C)]
pub struct _vftable_ScriptEnvironmentPreparer {
    pub invoke: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                     scope: HandleObject,
                                     closure:
                                         *mut ScriptEnvironmentPreparer_Closure),
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScriptEnvironmentPreparer_Closure {
    pub _vftable: *const _vftable_ScriptEnvironmentPreparer_Closure,
}
#[repr(C)]
pub struct _vftable_ScriptEnvironmentPreparer_Closure {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for ScriptEnvironmentPreparer_Closure {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ScriptEnvironmentPreparer_Closure() {
    assert_eq!(::std::mem::size_of::<ScriptEnvironmentPreparer_Closure>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<ScriptEnvironmentPreparer_Closure>() ,
               8usize);
}
impl ::std::clone::Clone for ScriptEnvironmentPreparer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ScriptEnvironmentPreparer() {
    assert_eq!(::std::mem::size_of::<ScriptEnvironmentPreparer>() , 8usize);
    assert_eq!(::std::mem::align_of::<ScriptEnvironmentPreparer>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum CTypesActivityType {
    CTYPES_CALL_BEGIN = 0,
    CTYPES_CALL_END = 1,
    CTYPES_CALLBACK_BEGIN = 2,
    CTYPES_CALLBACK_END = 3,
}
pub type CTypesActivityCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               type_: CTypesActivityType)>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCTypesActivityCallback {
    pub cx: *mut JSContext,
    pub callback: CTypesActivityCallback,
    pub endType: CTypesActivityType,
}
#[test]
fn bindgen_test_layout_AutoCTypesActivityCallback() {
    assert_eq!(::std::mem::size_of::<AutoCTypesActivityCallback>() , 24usize);
    assert_eq!(::std::mem::align_of::<AutoCTypesActivityCallback>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AllocationMetadataBuilder {
    pub _vftable: *const _vftable_AllocationMetadataBuilder,
}
#[repr(C)]
pub struct _vftable_AllocationMetadataBuilder {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for AllocationMetadataBuilder {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_AllocationMetadataBuilder() {
    assert_eq!(::std::mem::size_of::<AllocationMetadataBuilder>() , 8usize);
    assert_eq!(::std::mem::align_of::<AllocationMetadataBuilder>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NativeProfiler {
    pub _vftable: *const _vftable_NativeProfiler,
}
#[repr(C)]
pub struct _vftable_NativeProfiler {
    pub sampleNative: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                           addr: *mut ::std::os::raw::c_void,
                                           size: u32),
    pub removeNative: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                           addr: *mut ::std::os::raw::c_void),
    pub reset: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void),
}
#[test]
fn bindgen_test_layout_NativeProfiler() {
    assert_eq!(::std::mem::size_of::<NativeProfiler>() , 8usize);
    assert_eq!(::std::mem::align_of::<NativeProfiler>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct GCHeapProfiler {
    pub _vftable: *const _vftable_GCHeapProfiler,
}
#[repr(C)]
pub struct _vftable_GCHeapProfiler {
    pub sampleTenured: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                            addr: *mut ::std::os::raw::c_void,
                                            size: u32),
    pub sampleNursery: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                            addr: *mut ::std::os::raw::c_void,
                                            size: u32),
    pub markTenuredStart: unsafe extern "C" fn(this:
                                                   *mut ::std::os::raw::c_void),
    pub markTenured: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                          addr: *mut ::std::os::raw::c_void),
    pub sweepTenured: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void),
    pub sweepNursery: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void),
    pub moveNurseryToTenured: unsafe extern "C" fn(this:
                                                       *mut ::std::os::raw::c_void,
                                                   addrOld:
                                                       *mut ::std::os::raw::c_void,
                                                   addrNew:
                                                       *mut ::std::os::raw::c_void),
    pub reset: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void),
}
#[test]
fn bindgen_test_layout_GCHeapProfiler() {
    assert_eq!(::std::mem::size_of::<GCHeapProfiler>() , 8usize);
    assert_eq!(::std::mem::align_of::<GCHeapProfiler>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MemProfiler {
    pub mGCHeapProfiler: *mut GCHeapProfiler,
    pub mRuntime: *mut JSRuntime,
}
impl ::std::clone::Clone for MemProfiler {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_MemProfiler() {
    assert_eq!(::std::mem::size_of::<MemProfiler>() , 16usize);
    assert_eq!(::std::mem::align_of::<MemProfiler>() , 8usize);
}
extern "C" {
    fn _ZN11MemProfiler5startEP14GCHeapProfiler(this: *mut MemProfiler,
                                                aGCHeapProfiler:
                                                    *mut GCHeapProfiler);
    fn _ZN11MemProfiler4stopEv(this: *mut MemProfiler);
    fn _ZN11MemProfiler14GetMemProfilerEP9JSRuntime(runtime: *mut JSRuntime)
     -> *mut MemProfiler;
}
impl MemProfiler {
    #[inline]
    pub unsafe fn start(&mut self, aGCHeapProfiler: *mut GCHeapProfiler) {
        _ZN11MemProfiler5startEP14GCHeapProfiler(&mut *self, aGCHeapProfiler)
    }
    #[inline]
    pub unsafe fn stop(&mut self) { _ZN11MemProfiler4stopEv(&mut *self) }
    #[inline]
    pub unsafe fn GetMemProfiler(runtime: *mut JSRuntime)
     -> *mut MemProfiler {
        _ZN11MemProfiler14GetMemProfilerEP9JSRuntime(runtime)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum InitState { Uninitialized = 0, Running = 1, ShutDown = 2, }
pub type JS_ICUAllocFn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               size: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type JS_ICUReallocFn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               p: *mut ::std::os::raw::c_void,
                                               size: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type JS_ICUFreeFn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               p:
                                                   *mut ::std::os::raw::c_void)>;
pub enum nsISupports { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TabSizes {
    pub objects: usize,
    pub strings: usize,
    pub private_: usize,
    pub other: usize,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TabSizes_Kind { Objects = 0, Strings = 1, Private = 2, Other = 3, }
impl ::std::clone::Clone for TabSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TabSizes() {
    assert_eq!(::std::mem::size_of::<TabSizes>() , 32usize);
    assert_eq!(::std::mem::align_of::<TabSizes>() , 8usize);
}
/** These are the measurements used by Servo. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ServoSizes {
    pub gcHeapUsed: usize,
    pub gcHeapUnused: usize,
    pub gcHeapAdmin: usize,
    pub gcHeapDecommitted: usize,
    pub mallocHeap: usize,
    pub nonHeap: usize,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ServoSizes_Kind {
    GCHeapUsed = 0,
    GCHeapUnused = 1,
    GCHeapAdmin = 2,
    GCHeapDecommitted = 3,
    MallocHeap = 4,
    NonHeap = 5,
    Ignore = 6,
}
impl ::std::clone::Clone for ServoSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ServoSizes() {
    assert_eq!(::std::mem::size_of::<ServoSizes>() , 48usize);
    assert_eq!(::std::mem::align_of::<ServoSizes>() , 8usize);
}
/**
 * This hash policy avoids flattening ropes (which perturbs the site being
 * measured and requires a JSContext) at the expense of doing a FULL ROPE COPY
 * on every hash and match! Beware.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct InefficientNonFlatteningStringHashPolicy;
impl ::std::clone::Clone for InefficientNonFlatteningStringHashPolicy {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    fn _ZN2js40InefficientNonFlatteningStringHashPolicy4hashERKP8JSString(l:
                                                                              *const *mut JSString)
     -> HashNumber;
    fn _ZN2js40InefficientNonFlatteningStringHashPolicy5matchERKPK8JSStringRKPS1_(k:
                                                                                      *const *const JSString,
                                                                                  l:
                                                                                      *const *mut JSString)
     -> bool;
}
impl InefficientNonFlatteningStringHashPolicy {
    #[inline]
    pub unsafe fn hash(l: *const *mut JSString) -> HashNumber {
        _ZN2js40InefficientNonFlatteningStringHashPolicy4hashERKP8JSString(l)
    }
    #[inline]
    pub unsafe fn match_(k: *const *const JSString, l: *const *mut JSString)
     -> bool {
        _ZN2js40InefficientNonFlatteningStringHashPolicy5matchERKPK8JSStringRKPS1_(k,
                                                                                   l)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CStringHashPolicy;
impl ::std::clone::Clone for CStringHashPolicy {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    fn _ZN2js17CStringHashPolicy4hashERKPKc(l:
                                                *const *const ::std::os::raw::c_char)
     -> HashNumber;
    fn _ZN2js17CStringHashPolicy5matchERKPKcS4_(k:
                                                    *const *const ::std::os::raw::c_char,
                                                l:
                                                    *const *const ::std::os::raw::c_char)
     -> bool;
}
impl CStringHashPolicy {
    #[inline]
    pub unsafe fn hash(l: *const *const ::std::os::raw::c_char)
     -> HashNumber {
        _ZN2js17CStringHashPolicy4hashERKPKc(l)
    }
    #[inline]
    pub unsafe fn match_(k: *const *const ::std::os::raw::c_char,
                         l: *const *const ::std::os::raw::c_char) -> bool {
        _ZN2js17CStringHashPolicy5matchERKPKcS4_(k, l)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassInfo {
    pub objectsGCHeap: usize,
    pub objectsMallocHeapSlots: usize,
    pub objectsMallocHeapElementsNormal: usize,
    pub objectsMallocHeapElementsAsmJS: usize,
    pub objectsNonHeapElementsNormal: usize,
    pub objectsNonHeapElementsAsmJS: usize,
    pub objectsNonHeapElementsShared: usize,
    pub objectsNonHeapCodeAsmJS: usize,
    pub objectsMallocHeapMisc: usize,
    pub shapesGCHeapTree: usize,
    pub shapesGCHeapDict: usize,
    pub shapesGCHeapBase: usize,
    pub shapesMallocHeapTreeTables: usize,
    pub shapesMallocHeapDictTables: usize,
    pub shapesMallocHeapTreeKids: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for ClassInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassInfo() {
    assert_eq!(::std::mem::size_of::<ClassInfo>() , 128usize);
    assert_eq!(::std::mem::align_of::<ClassInfo>() , 8usize);
}
/**
 * Holds data about a notable class (one whose combined object and shape
 * instances use more than a certain amount of memory) so we can report it
 * individually.
 *
 * The only difference between this class and ClassInfo is that this class
 * holds a copy of the filename.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NotableClassInfo {
    pub _base: ClassInfo,
    pub className_: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotableClassInfo() {
    assert_eq!(::std::mem::size_of::<NotableClassInfo>() , 136usize);
    assert_eq!(::std::mem::align_of::<NotableClassInfo>() , 8usize);
}
/** Data for tracking JIT-code memory usage. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CodeSizes {
    pub ion: usize,
    pub baseline: usize,
    pub regexp: usize,
    pub other: usize,
    pub unused: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for CodeSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CodeSizes() {
    assert_eq!(::std::mem::size_of::<CodeSizes>() , 48usize);
    assert_eq!(::std::mem::align_of::<CodeSizes>() , 8usize);
}
/** Data for tracking GC memory usage. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GCSizes {
    pub marker: usize,
    pub nurseryCommitted: usize,
    pub nurseryDecommitted: usize,
    pub nurseryMallocedBuffers: usize,
    pub storeBufferVals: usize,
    pub storeBufferCells: usize,
    pub storeBufferSlots: usize,
    pub storeBufferWholeCells: usize,
    pub storeBufferGenerics: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for GCSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GCSizes() {
    assert_eq!(::std::mem::size_of::<GCSizes>() , 80usize);
    assert_eq!(::std::mem::align_of::<GCSizes>() , 8usize);
}
/**
 * This class holds information about the memory taken up by identical copies of
 * a particular string.  Multiple JSStrings may have their sizes aggregated
 * together into one StringInfo object.  Note that two strings with identical
 * chars will not be aggregated together if one is a short string and the other
 * is not.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StringInfo {
    pub gcHeapLatin1: usize,
    pub gcHeapTwoByte: usize,
    pub mallocHeapLatin1: usize,
    pub mallocHeapTwoByte: usize,
    pub numCopies: u32,
}
impl ::std::clone::Clone for StringInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_StringInfo() {
    assert_eq!(::std::mem::size_of::<StringInfo>() , 40usize);
    assert_eq!(::std::mem::align_of::<StringInfo>() , 8usize);
}
/**
 * Holds data about a notable string (one which, counting all duplicates, uses
 * more than a certain amount of memory) so we can report it individually.
 *
 * The only difference between this class and StringInfo is that
 * NotableStringInfo holds a copy of some or all of the string's chars.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NotableStringInfo {
    pub _base: StringInfo,
    pub buffer: *mut ::std::os::raw::c_char,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_NotableStringInfo() {
    assert_eq!(::std::mem::size_of::<NotableStringInfo>() , 56usize);
    assert_eq!(::std::mem::align_of::<NotableStringInfo>() , 8usize);
}
/**
 * This class holds information about the memory taken up by script sources
 * from a particular file.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScriptSourceInfo {
    pub misc: usize,
    pub numScripts: u32,
}
impl ::std::clone::Clone for ScriptSourceInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ScriptSourceInfo() {
    assert_eq!(::std::mem::size_of::<ScriptSourceInfo>() , 16usize);
    assert_eq!(::std::mem::align_of::<ScriptSourceInfo>() , 8usize);
}
/**
 * Holds data about a notable script source file (one whose combined
 * script sources use more than a certain amount of memory) so we can report it
 * individually.
 *
 * The only difference between this class and ScriptSourceInfo is that this
 * class holds a copy of the filename.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NotableScriptSourceInfo {
    pub _base: ScriptSourceInfo,
    pub filename_: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotableScriptSourceInfo() {
    assert_eq!(::std::mem::size_of::<NotableScriptSourceInfo>() , 24usize);
    assert_eq!(::std::mem::align_of::<NotableScriptSourceInfo>() , 8usize);
}
/**
 * These measurements relate directly to the JSRuntime, and not to zones and
 * compartments within it.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct RuntimeSizes {
    pub object: usize,
    pub atomsTable: usize,
    pub contexts: usize,
    pub temporary: usize,
    pub interpreterStack: usize,
    pub mathCache: usize,
    pub sharedImmutableStringsCache: usize,
    pub uncompressedSourceCache: usize,
    pub scriptData: usize,
    pub scriptSourceInfo: ScriptSourceInfo,
    pub code: CodeSizes,
    pub gc: GCSizes,
    pub allScriptSources: u64,
    pub notableScriptSources: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_RuntimeSizes() {
    assert_eq!(::std::mem::size_of::<RuntimeSizes>() , 256usize);
    assert_eq!(::std::mem::align_of::<RuntimeSizes>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UnusedGCThingSizes {
    pub object: usize,
    pub script: usize,
    pub lazyScript: usize,
    pub shape: usize,
    pub baseShape: usize,
    pub objectGroup: usize,
    pub string: usize,
    pub symbol: usize,
    pub jitcode: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for UnusedGCThingSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_UnusedGCThingSizes() {
    assert_eq!(::std::mem::size_of::<UnusedGCThingSizes>() , 80usize);
    assert_eq!(::std::mem::align_of::<UnusedGCThingSizes>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ZoneStats {
    pub symbolsGCHeap: usize,
    pub gcHeapArenaAdmin: usize,
    pub lazyScriptsGCHeap: usize,
    pub lazyScriptsMallocHeap: usize,
    pub jitCodesGCHeap: usize,
    pub objectGroupsGCHeap: usize,
    pub objectGroupsMallocHeap: usize,
    pub typePool: usize,
    pub baselineStubsOptimized: usize,
    pub uniqueIdMap: usize,
    pub unusedGCThings: UnusedGCThingSizes,
    pub stringInfo: StringInfo,
    pub extra: *mut ::std::os::raw::c_void,
    pub allStrings: u64,
    pub notableStrings: [u64; 4usize],
    pub isTotals: bool,
}
#[test]
fn bindgen_test_layout_ZoneStats() {
    assert_eq!(::std::mem::size_of::<ZoneStats>() , 256usize);
    assert_eq!(::std::mem::align_of::<ZoneStats>() , 8usize);
}
extern "C" {
    fn _ZN2JS9ZoneStats11initStringsEP9JSRuntime(this: *mut ZoneStats,
                                                 rt: *mut JSRuntime) -> bool;
}
impl ZoneStats {
    #[inline]
    pub unsafe fn initStrings(&mut self, rt: *mut JSRuntime) -> bool {
        _ZN2JS9ZoneStats11initStringsEP9JSRuntime(&mut *self, rt)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct CompartmentStats {
    pub objectsPrivate: usize,
    pub scriptsGCHeap: usize,
    pub scriptsMallocHeapData: usize,
    pub baselineData: usize,
    pub baselineStubsFallback: usize,
    pub ionData: usize,
    pub typeInferenceTypeScripts: usize,
    pub typeInferenceAllocationSiteTables: usize,
    pub typeInferenceArrayTypeTables: usize,
    pub typeInferenceObjectTypeTables: usize,
    pub compartmentObject: usize,
    pub compartmentTables: usize,
    pub innerViewsTable: usize,
    pub lazyArrayBuffersTable: usize,
    pub objectMetadataTable: usize,
    pub crossCompartmentWrappersTable: usize,
    pub regexpCompartment: usize,
    pub savedStacksSet: usize,
    pub nonSyntacticLexicalScopesTable: usize,
    pub jitCompartment: usize,
    pub privateData: usize,
    pub classInfo: ClassInfo,
    pub extra: *mut ::std::os::raw::c_void,
    pub allClasses: u64,
    pub notableClasses: [u64; 4usize],
    pub isTotals: bool,
}
#[test]
fn bindgen_test_layout_CompartmentStats() {
    assert_eq!(::std::mem::size_of::<CompartmentStats>() , 352usize);
    assert_eq!(::std::mem::align_of::<CompartmentStats>() , 8usize);
}
extern "C" {
    fn _ZN2JS16CompartmentStats11initClassesEP9JSRuntime(this:
                                                             *mut CompartmentStats,
                                                         rt: *mut JSRuntime)
     -> bool;
}
impl CompartmentStats {
    #[inline]
    pub unsafe fn initClasses(&mut self, rt: *mut JSRuntime) -> bool {
        _ZN2JS16CompartmentStats11initClassesEP9JSRuntime(&mut *self, rt)
    }
}
pub type CompartmentStatsVector = ::std::os::raw::c_void;
pub type ZoneStatsVector = ::std::os::raw::c_void;
#[repr(C)]
pub struct RuntimeStats {
    pub _bindgen_opaque_blob: [u64; 125usize],
}
#[test]
fn bindgen_test_layout_RuntimeStats() {
    assert_eq!(::std::mem::size_of::<RuntimeStats>() , 1000usize);
    assert_eq!(::std::mem::align_of::<RuntimeStats>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectPrivateVisitor {
    pub _vftable: *const _vftable_ObjectPrivateVisitor,
    pub getISupports_: ::std::option::Option<unsafe extern "C" fn() -> bool>,
}
#[repr(C)]
pub struct _vftable_ObjectPrivateVisitor {
    pub sizeOfIncludingThis: unsafe extern "C" fn(this:
                                                      *mut ::std::os::raw::c_void,
                                                  aSupports: *mut nsISupports)
                                 -> usize,
}
impl ::std::clone::Clone for ObjectPrivateVisitor {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectPrivateVisitor() {
    assert_eq!(::std::mem::size_of::<ObjectPrivateVisitor>() , 16usize);
    assert_eq!(::std::mem::align_of::<ObjectPrivateVisitor>() , 8usize);
}
extern "C" {
    #[link_name = "_ZN2JS15NullHandleValueE"]
    pub static NullHandleValue: Handle<Value>;
    #[link_name = "_ZN2JS20UndefinedHandleValueE"]
    pub static UndefinedHandleValue: Handle<Value>;
    #[link_name = "_ZN2JS15TrueHandleValueE"]
    pub static TrueHandleValue: Handle<Value>;
    #[link_name = "_ZN2JS16FalseHandleValueE"]
    pub static FalseHandleValue: Handle<Value>;
    pub static JSID_VOID: jsid;
    pub static JSID_EMPTY: jsid;
    pub static JSID_VOIDHANDLE: Handle<jsid>;
    pub static JSID_EMPTYHANDLE: Handle<jsid>;
    #[link_name = "_ZN2js16FunctionClassPtrE"]
    pub static FunctionClassPtr: *const Class;
    #[link_name = "_ZN2js13ProxyClassOpsE"]
    pub static ProxyClassOps: ClassOps;
    #[link_name = "_ZN2js19ProxyClassExtensionE"]
    pub static ProxyClassExtension: ClassExtension;
    #[link_name = "_ZN2js14ProxyObjectOpsE"]
    pub static ProxyObjectOps: ObjectOps;
    #[link_name = "_ZN2js14ObjectClassPtrE"]
    pub static ObjectClassPtr: *const Class;
    #[link_name = "_ZN2js6detail17Int8ArrayClassPtrE"]
    pub static Int8ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail18Uint8ArrayClassPtrE"]
    pub static Uint8ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail25Uint8ClampedArrayClassPtrE"]
    pub static Uint8ClampedArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail18Int16ArrayClassPtrE"]
    pub static Int16ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail19Uint16ArrayClassPtrE"]
    pub static Uint16ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail18Int32ArrayClassPtrE"]
    pub static Int32ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail19Uint32ArrayClassPtrE"]
    pub static Uint32ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail20Float32ArrayClassPtrE"]
    pub static Float32ArrayClassPtr: *const Class;
    #[link_name = "_ZN2js6detail20Float64ArrayClassPtrE"]
    pub static Float64ArrayClassPtr: *const Class;
    #[link_name = "_ZN2JS6detail16libraryInitStateE"]
    pub static mut libraryInitState: InitState;
}
extern "C" {
    #[link_name = "_ZN2js17ReportOutOfMemoryEPNS_16ExclusiveContextE"]
    pub fn ReportOutOfMemory(cxArg: *mut ExclusiveContext);
    #[link_name = "_ZN2js29CurrentThreadCanAccessRuntimeEP9JSRuntime"]
    pub fn CurrentThreadCanAccessRuntime(rt: *mut JSRuntime) -> bool;
    #[link_name = "_ZN2js26CurrentThreadCanAccessZoneEPN2JS4ZoneE"]
    pub fn CurrentThreadCanAccessZone(zone: *mut Zone) -> bool;
    #[link_name =
          "_ZN2js2gc20AssertGCThingHasTypeEPNS0_4CellEN2JS9TraceKindE"]
    pub fn AssertGCThingHasType(cell: *mut Cell, kind: TraceKind);
    #[link_name = "_ZN2JS13GetObjectZoneEP8JSObject"]
    pub fn GetObjectZone(obj: *mut JSObject) -> *mut Zone;
    #[link_name = "_ZN2JS16GCThingTraceKindEPv"]
    pub fn GCThingTraceKind(thing: *mut ::std::os::raw::c_void) -> TraceKind;
    /**
 * Create an object providing access to the garbage collector's internal notion
 * of the current state of memory (both GC heap memory and GCthing-controlled
 * malloc memory.
 */
    #[link_name = "_ZN2js2gc19NewMemoryInfoObjectEP9JSContext"]
    pub fn NewMemoryInfoObject(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Get a statically allocated C string explaining the given GC reason.
 */
    #[link_name = "_ZN2JS8gcreason13ExplainReasonENS0_6ReasonE"]
    pub fn ExplainReason(reason: Reason) -> *const ::std::os::raw::c_char;
    /**
 * Schedule the given zone to be collected as part of the next GC.
 */
    #[link_name = "_ZN2JS16PrepareZoneForGCEPNS_4ZoneE"]
    pub fn PrepareZoneForGC(zone: *mut Zone);
    /**
 * Schedule all zones to be collected in the next GC.
 */
    #[link_name = "_ZN2JS16PrepareForFullGCEP9JSRuntime"]
    pub fn PrepareForFullGC(rt: *mut JSRuntime);
    /**
 * When performing an incremental GC, the zones that were selected for the
 * previous incremental slice must be selected in subsequent slices as well.
 * This function selects those slices automatically.
 */
    #[link_name = "_ZN2JS23PrepareForIncrementalGCEP9JSRuntime"]
    pub fn PrepareForIncrementalGC(rt: *mut JSRuntime);
    /**
 * Returns true if any zone in the system has been scheduled for GC with one of
 * the functions above or by the JS engine.
 */
    #[link_name = "_ZN2JS13IsGCScheduledEP9JSRuntime"]
    pub fn IsGCScheduled(rt: *mut JSRuntime) -> bool;
    /**
 * Undoes the effect of the Prepare methods above. The given zone will not be
 * collected in the next GC.
 */
    #[link_name = "_ZN2JS13SkipZoneForGCEPNS_4ZoneE"]
    pub fn SkipZoneForGC(zone: *mut Zone);
    /**
 * Performs a non-incremental collection of all selected zones.
 *
 * If the gckind argument is GC_NORMAL, then some objects that are unreachable
 * from the program may still be alive afterwards because of internal
 * references; if GC_SHRINK is passed then caches and other temporary references
 * to objects will be cleared and all unreferenced objects will be removed from
 * the system.
 */
    #[link_name =
          "_ZN2JS11GCForReasonEP9JSRuntime18JSGCInvocationKindNS_8gcreason6ReasonE"]
    pub fn GCForReason(rt: *mut JSRuntime, gckind: JSGCInvocationKind,
                       reason: Reason);
    /**
 * Begin an incremental collection and perform one slice worth of work. When
 * this function returns, the collection may not be complete.
 * IncrementalGCSlice() must be called repeatedly until
 * !IsIncrementalGCInProgress(rt).
 *
 * Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or
 *       shorter than the requested interval.
 */
    #[link_name =
          "_ZN2JS18StartIncrementalGCEP9JSRuntime18JSGCInvocationKindNS_8gcreason6ReasonEx"]
    pub fn StartIncrementalGC(rt: *mut JSRuntime, gckind: JSGCInvocationKind,
                              reason: Reason, millis: i64);
    /**
 * Perform a slice of an ongoing incremental collection. When this function
 * returns, the collection may not be complete. It must be called repeatedly
 * until !IsIncrementalGCInProgress(rt).
 *
 * Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or
 *       shorter than the requested interval.
 */
    #[link_name =
          "_ZN2JS18IncrementalGCSliceEP9JSRuntimeNS_8gcreason6ReasonEx"]
    pub fn IncrementalGCSlice(rt: *mut JSRuntime, reason: Reason,
                              millis: i64);
    /**
 * If IsIncrementalGCInProgress(rt), this call finishes the ongoing collection
 * by performing an arbitrarily long slice. If !IsIncrementalGCInProgress(rt),
 * this is equivalent to GCForReason. When this function returns,
 * IsIncrementalGCInProgress(rt) will always be false.
 */
    #[link_name =
          "_ZN2JS19FinishIncrementalGCEP9JSRuntimeNS_8gcreason6ReasonE"]
    pub fn FinishIncrementalGC(rt: *mut JSRuntime, reason: Reason);
    /**
 * If IsIncrementalGCInProgress(rt), this call aborts the ongoing collection and
 * performs whatever work needs to be done to return the collector to its idle
 * state. This may take an arbitrarily long time. When this function returns,
 * IsIncrementalGCInProgress(rt) will always be false.
 */
    #[link_name = "_ZN2JS18AbortIncrementalGCEP9JSRuntime"]
    pub fn AbortIncrementalGC(rt: *mut JSRuntime);
    /**
 * The GC slice callback is called at the beginning and end of each slice. This
 * callback may be used for GC notifications as well as to perform additional
 * marking.
 */
    #[link_name =
          "_ZN2JS18SetGCSliceCallbackEP9JSRuntimePFvS1_NS_10GCProgressERKNS_13GCDescriptionEE"]
    pub fn SetGCSliceCallback(rt: *mut JSRuntime, callback: GCSliceCallback)
     -> GCSliceCallback;
    /**
 * Set the nursery collection callback for the given runtime. When set, it will
 * be called at the start and end of every nursery collection.
 */
    #[link_name =
          "_ZN2JS30SetGCNurseryCollectionCallbackEP9JSRuntimePFvS1_NS_17GCNurseryProgressENS_8gcreason6ReasonEE"]
    pub fn SetGCNurseryCollectionCallback(rt: *mut JSRuntime,
                                          callback:
                                              GCNurseryCollectionCallback)
     -> GCNurseryCollectionCallback;
    /**
 * Incremental GC defaults to enabled, but may be disabled for testing or in
 * embeddings that have not yet implemented barriers on their native classes.
 * There is not currently a way to re-enable incremental GC once it has been
 * disabled on the runtime.
 */
    #[link_name = "_ZN2JS20DisableIncrementalGCEP9JSRuntime"]
    pub fn DisableIncrementalGC(rt: *mut JSRuntime);
    /**
 * Returns true if incremental GC is enabled. Simply having incremental GC
 * enabled is not sufficient to ensure incremental collections are happening.
 * See the comment "Incremental GC" above for reasons why incremental GC may be
 * suppressed. Inspection of the "nonincremental reason" field of the
 * GCDescription returned by GCSliceCallback may help narrow down the cause if
 * collections are not happening incrementally when expected.
 */
    #[link_name = "_ZN2JS22IsIncrementalGCEnabledEP9JSRuntime"]
    pub fn IsIncrementalGCEnabled(rt: *mut JSRuntime) -> bool;
    /**
 * Returns true while an incremental GC is ongoing, both when actively
 * collecting and between slices.
 */
    #[link_name = "_ZN2JS25IsIncrementalGCInProgressEP9JSRuntime"]
    pub fn IsIncrementalGCInProgress(rt: *mut JSRuntime) -> bool;
    #[link_name = "_ZN2JS26IsIncrementalBarrierNeededEP9JSRuntime"]
    pub fn IsIncrementalBarrierNeeded(rt: *mut JSRuntime) -> bool;
    #[link_name = "_ZN2JS27IncrementalReferenceBarrierENS_9GCCellPtrE"]
    pub fn IncrementalReferenceBarrier(thing: GCCellPtr);
    #[link_name = "_ZN2JS23IncrementalValueBarrierERKNS_5ValueE"]
    pub fn IncrementalValueBarrier(v: *const Value);
    #[link_name = "_ZN2JS24IncrementalObjectBarrierEP8JSObject"]
    pub fn IncrementalObjectBarrier(obj: *mut JSObject);
    /**
 * Returns true if the most recent GC ran incrementally.
 */
    #[link_name = "_ZN2JS16WasIncrementalGCEP9JSRuntime"]
    pub fn WasIncrementalGC(rt: *mut JSRuntime) -> bool;
    /**
 * Returns true if generational allocation and collection is currently enabled
 * on the given runtime.
 */
    #[link_name = "_ZN2JS23IsGenerationalGCEnabledEP9JSRuntime"]
    pub fn IsGenerationalGCEnabled(rt: *mut JSRuntime) -> bool;
    /**
 * Returns the GC's "number". This does not correspond directly to the number
 * of GCs that have been run, but is guaranteed to be monotonically increasing
 * with GC activity.
 */
    #[link_name = "_ZN2JS11GetGCNumberEv"]
    pub fn GetGCNumber() -> usize;
    /**
 * The GC does not immediately return the unused memory freed by a collection
 * back to the system incase it is needed soon afterwards. This call forces the
 * GC to return this memory immediately.
 */
    #[link_name = "_ZN2JS15ShrinkGCBuffersEP9JSRuntime"]
    pub fn ShrinkGCBuffers(rt: *mut JSRuntime);
    /**
 * Unsets the gray bit for anything reachable from |thing|. |kind| should not be
 * JS::TraceKind::Shape. |thing| should be non-null. The return value indicates
 * if anything was unmarked.
 */
    #[link_name = "_ZN2JS28UnmarkGrayGCThingRecursivelyENS_9GCCellPtrE"]
    pub fn UnmarkGrayGCThingRecursively(thing: GCCellPtr) -> bool;
    #[link_name = "_ZN2JS6PokeGCEP9JSRuntime"]
    pub fn PokeGC(rt: *mut JSRuntime);
    #[link_name = "_ZN2JS14NotifyDidPaintEP9JSRuntime"]
    pub fn NotifyDidPaint(rt: *mut JSRuntime);
    /** Returns a static string equivalent of |kind|. */
    #[link_name = "_ZN2JS18GCTraceKindToAsciiENS_9TraceKindE"]
    pub fn GCTraceKindToAscii(kind: TraceKind)
     -> *const ::std::os::raw::c_char;
    #[link_name =
          "_ZN2JS9TraceEdgeEP8JSTracerPNS_11TenuredHeapIP8JSObjectEEPKc"]
    pub fn TraceEdge(trc: *mut JSTracer,
                     edgep: *mut TenuredHeap<*mut JSObject>,
                     name: *const ::std::os::raw::c_char);
    #[link_name = "_ZN2JS13TraceChildrenEP8JSTracerNS_9GCCellPtrE"]
    pub fn TraceChildren(trc: *mut JSTracer, thing: GCCellPtr);
    #[link_name = "_Z20JS_GetTraceThingInfoPcyP8JSTracerPvN2JS9TraceKindEb"]
    pub fn JS_GetTraceThingInfo(buf: *mut ::std::os::raw::c_char,
                                bufsize: usize, trc: *mut JSTracer,
                                thing: *mut ::std::os::raw::c_void,
                                kind: TraceKind, includeDetails: bool);
    #[link_name = "_ZN2JS11isGCEnabledEv"]
    pub fn isGCEnabled() -> bool;
    #[link_name = "_ZN2JS21HeapObjectPostBarrierEPP8JSObjectS1_S1_"]
    pub fn HeapObjectPostBarrier(objp: *mut *mut JSObject,
                                 prev: *mut JSObject, next: *mut JSObject);
    /**
 * For generational GC, assert that an object is in the tenured generation as
 * opposed to being in the nursery.
 */
    #[link_name = "_ZN2JS26AssertGCThingMustBeTenuredEP8JSObject"]
    pub fn AssertGCThingMustBeTenured(obj: *mut JSObject);
    #[link_name = "_ZN2JS34AssertGCThingIsNotAnObjectSubclassEPN2js2gc4CellE"]
    pub fn AssertGCThingIsNotAnObjectSubclass(cell: *mut Cell);
    #[link_name = "_ZN2JS20HeapValuePostBarrierEPNS_5ValueERKS0_S3_"]
    pub fn HeapValuePostBarrier(valuep: *mut Value, prev: *const Value,
                                next: *const Value);
    #[link_name = "_ZN2JS6detail11ComputeThisEP9JSContextPNS_5ValueE"]
    pub fn ComputeThis(cx: *mut JSContext, vp: *mut Value) -> Value;
    #[link_name = "_ZN2JS6detail25CheckIsValidConstructibleENS_5ValueE"]
    pub fn CheckIsValidConstructible(v: Value);
    /**
 * Only JSStrings that have been interned via the JSAPI can be turned into
 * jsids by API clients.
 *
 * N.B. if a jsid is backed by a string which has not been interned, that
 * string must be appropriately rooted to avoid being collected by the GC.
 */
    #[link_name = "_Z23INTERNED_STRING_TO_JSIDP9JSContextP8JSString"]
    pub fn INTERNED_STRING_TO_JSID(cx: *mut JSContext, str: *mut JSString)
     -> jsid;
    /**
 * ES6 7.2.2.
 *
 * Returns false on failure, otherwise returns true and sets |*isArray|
 * indicating whether the object passes ECMAScript's IsArray test.  This is the
 * same test performed by |Array.isArray|.
 *
 * This is NOT the same as asking whether |obj| is an Array or a wrapper around
 * one.  If |obj| is a proxy created by |Proxy.revocable()| and has been
 * revoked, or if |obj| is a proxy whose target (at any number of hops) is a
 * revoked proxy, this method throws a TypeError and returns false.
 */
    #[link_name = "_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPb"]
    pub fn IsArray(cx: *mut JSContext, obj: HandleObject, isArray: *mut bool)
     -> bool;
    /**
 * Identical to IsArray above, but the nature of the object (if successfully
 * determined) is communicated via |*answer|.  In particular this method
 * returns true and sets |*answer = IsArrayAnswer::RevokedProxy| when called on
 * a revoked proxy.
 *
 * Most users will want the overload above, not this one.
 */
    #[link_name =
          "_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPNS_13IsArrayAnswerE"]
    pub fn IsArray1(cx: *mut JSContext, obj: HandleObject,
                    answer: *mut IsArrayAnswer) -> bool;
    #[link_name =
          "_ZN2js5UnboxEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleINS2_5ValueEEE"]
    pub fn Unbox(cx: *mut JSContext, obj: HandleObject,
                 vp: MutableHandleValue) -> bool;
    /** Note: if the *data contains transferable objects, it can be read only once. */
    #[link_name =
          "_Z22JS_ReadStructuredCloneP9JSContextPyyjN2JS13MutableHandleINS2_5ValueEEEPK26JSStructuredCloneCallbacksPv"]
    pub fn JS_ReadStructuredClone(cx: *mut JSContext, data: *mut u64,
                                  nbytes: usize, version: u32,
                                  vp: MutableHandleValue,
                                  optionalCallbacks:
                                      *const JSStructuredCloneCallbacks,
                                  closure: *mut ::std::os::raw::c_void)
     -> bool;
    /**
 * Note: On success, the caller is responsible for calling
 * JS_ClearStructuredClone(*datap, nbytes, optionalCallbacks, closure).
 */
    #[link_name =
          "_Z23JS_WriteStructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEEPPyS5_PK26JSStructuredCloneCallbacksPvS4_"]
    pub fn JS_WriteStructuredClone(cx: *mut JSContext, v: HandleValue,
                                   datap: *mut *mut u64, nbytesp: *mut usize,
                                   optionalCallbacks:
                                       *const JSStructuredCloneCallbacks,
                                   closure: *mut ::std::os::raw::c_void,
                                   transferable: HandleValue) -> bool;
    #[link_name =
          "_Z23JS_ClearStructuredClonePyyPK26JSStructuredCloneCallbacksPvb"]
    pub fn JS_ClearStructuredClone(data: *mut u64, nbytes: usize,
                                   optionalCallbacks:
                                       *const JSStructuredCloneCallbacks,
                                   closure: *mut ::std::os::raw::c_void,
                                   freeData: bool) -> bool;
    #[link_name = "_Z34JS_StructuredCloneHasTransferablesPKyyPb"]
    pub fn JS_StructuredCloneHasTransferables(data: *const u64, nbytes: usize,
                                              hasTransferable: *mut bool)
     -> bool;
    #[link_name =
          "_Z18JS_StructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIS3_EEPK26JSStructuredCloneCallbacksPv"]
    pub fn JS_StructuredClone(cx: *mut JSContext, v: HandleValue,
                              vp: MutableHandleValue,
                              optionalCallbacks:
                                  *const JSStructuredCloneCallbacks,
                              closure: *mut ::std::os::raw::c_void) -> bool;
    #[link_name = "_Z17JS_ReadUint32PairP23JSStructuredCloneReaderPjS1_"]
    pub fn JS_ReadUint32Pair(r: *mut JSStructuredCloneReader, p1: *mut u32,
                             p2: *mut u32) -> bool;
    #[link_name = "_Z12JS_ReadBytesP23JSStructuredCloneReaderPvy"]
    pub fn JS_ReadBytes(r: *mut JSStructuredCloneReader,
                        p: *mut ::std::os::raw::c_void, len: usize) -> bool;
    #[link_name =
          "_Z17JS_ReadTypedArrayP23JSStructuredCloneReaderN2JS13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ReadTypedArray(r: *mut JSStructuredCloneReader,
                             vp: MutableHandleValue) -> bool;
    #[link_name = "_Z18JS_WriteUint32PairP23JSStructuredCloneWriterjj"]
    pub fn JS_WriteUint32Pair(w: *mut JSStructuredCloneWriter, tag: u32,
                              data: u32) -> bool;
    #[link_name = "_Z13JS_WriteBytesP23JSStructuredCloneWriterPKvy"]
    pub fn JS_WriteBytes(w: *mut JSStructuredCloneWriter,
                         p: *const ::std::os::raw::c_void, len: usize)
     -> bool;
    #[link_name =
          "_Z14JS_WriteStringP23JSStructuredCloneWriterN2JS6HandleIP8JSStringEE"]
    pub fn JS_WriteString(w: *mut JSStructuredCloneWriter, str: HandleString)
     -> bool;
    #[link_name =
          "_Z18JS_WriteTypedArrayP23JSStructuredCloneWriterN2JS6HandleINS1_5ValueEEE"]
    pub fn JS_WriteTypedArray(w: *mut JSStructuredCloneWriter, v: HandleValue)
     -> bool;
    #[link_name =
          "_Z19JS_ObjectNotWrittenP23JSStructuredCloneWriterN2JS6HandleIP8JSObjectEE"]
    pub fn JS_ObjectNotWritten(w: *mut JSStructuredCloneWriter,
                               obj: HandleObject) -> bool;
    #[link_name = "_Z17JS_HoldPrincipalsP12JSPrincipals"]
    pub fn JS_HoldPrincipals(principals: *mut JSPrincipals);
    #[link_name = "_Z17JS_DropPrincipalsP9JSRuntimeP12JSPrincipals"]
    pub fn JS_DropPrincipals(rt: *mut JSRuntime,
                             principals: *mut JSPrincipals);
    #[link_name =
          "_Z23JS_SetSecurityCallbacksP9JSRuntimePK19JSSecurityCallbacks"]
    pub fn JS_SetSecurityCallbacks(rt: *mut JSRuntime,
                                   callbacks: *const JSSecurityCallbacks);
    #[link_name = "_Z23JS_GetSecurityCallbacksP9JSRuntime"]
    pub fn JS_GetSecurityCallbacks(rt: *mut JSRuntime)
     -> *const JSSecurityCallbacks;
    #[link_name = "_Z23JS_SetTrustedPrincipalsP9JSRuntimeP12JSPrincipals"]
    pub fn JS_SetTrustedPrincipals(rt: *mut JSRuntime,
                                   prin: *mut JSPrincipals);
    #[link_name =
          "_Z32JS_InitDestroyPrincipalsCallbackP9JSRuntimePFvP12JSPrincipalsE"]
    pub fn JS_InitDestroyPrincipalsCallback(rt: *mut JSRuntime,
                                            destroyPrincipals:
                                                JSDestroyPrincipalsOp);
    #[link_name =
          "_Z29JS_InitReadPrincipalsCallbackP9JSRuntimePFbP9JSContextP23JSStructuredCloneReaderPP12JSPrincipalsE"]
    pub fn JS_InitReadPrincipalsCallback(rt: *mut JSRuntime,
                                         read: JSReadPrincipalsOp);
    /************************************************************************/
    #[link_name = "_Z22JS_StringHasBeenPinnedP9JSContextP8JSString"]
    pub fn JS_StringHasBeenPinned(cx: *mut JSContext, str: *mut JSString)
     -> bool;
    /**
 * The first call to JS_CallOnce by any thread in a process will call 'func'.
 * Later calls to JS_CallOnce with the same JSCallOnceType object will be
 * suppressed.
 *
 * Equivalently: each distinct JSCallOnceType object will allow one JS_CallOnce
 * to invoke its JSInitCallback.
 */
    #[link_name = "_Z11JS_CallOnceP14PRCallOnceTypePFbvE"]
    pub fn JS_CallOnce(once: *mut JSCallOnceType, func: JSInitCallback)
     -> bool;
    /** Microseconds since the epoch, midnight, January 1, 1970 UTC. */
    #[link_name = "_Z6JS_Nowv"]
    pub fn JS_Now() -> i64;
    /** Don't want to export data, so provide accessors for non-inline Values. */
    #[link_name = "_Z14JS_GetNaNValueP9JSContext"]
    pub fn JS_GetNaNValue(cx: *mut JSContext) -> Value;
    #[link_name = "_Z27JS_GetNegativeInfinityValueP9JSContext"]
    pub fn JS_GetNegativeInfinityValue(cx: *mut JSContext) -> Value;
    #[link_name = "_Z27JS_GetPositiveInfinityValueP9JSContext"]
    pub fn JS_GetPositiveInfinityValue(cx: *mut JSContext) -> Value;
    #[link_name = "_Z22JS_GetEmptyStringValueP9JSContext"]
    pub fn JS_GetEmptyStringValue(cx: *mut JSContext) -> Value;
    #[link_name = "_Z17JS_GetEmptyStringP9JSRuntime"]
    pub fn JS_GetEmptyString(rt: *mut JSRuntime) -> *mut JSString;
    #[link_name =
          "_Z16JS_ValueToObjectP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIP8JSObjectEE"]
    pub fn JS_ValueToObject(cx: *mut JSContext, v: HandleValue,
                            objp: MutableHandleObject) -> bool;
    #[link_name =
          "_Z18JS_ValueToFunctionP9JSContextN2JS6HandleINS1_5ValueEEE"]
    pub fn JS_ValueToFunction(cx: *mut JSContext, v: HandleValue)
     -> *mut JSFunction;
    #[link_name =
          "_Z21JS_ValueToConstructorP9JSContextN2JS6HandleINS1_5ValueEEE"]
    pub fn JS_ValueToConstructor(cx: *mut JSContext, v: HandleValue)
     -> *mut JSFunction;
    #[link_name = "_Z16JS_ValueToSourceP9JSContextN2JS6HandleINS1_5ValueEEE"]
    pub fn JS_ValueToSource(cx: *mut JSContext, v: Handle<Value>)
     -> *mut JSString;
    #[link_name = "_Z16JS_DoubleIsInt32dPi"]
    pub fn JS_DoubleIsInt32(d: f64, ip: *mut i32) -> bool;
    #[link_name = "_Z14JS_TypeOfValueP9JSContextN2JS6HandleINS1_5ValueEEE"]
    pub fn JS_TypeOfValue(cx: *mut JSContext, v: Handle<Value>) -> JSType;
    #[link_name =
          "_Z16JS_StrictlyEqualP9JSContextN2JS6HandleINS1_5ValueEEES4_Pb"]
    pub fn JS_StrictlyEqual(cx: *mut JSContext, v1: Handle<Value>,
                            v2: Handle<Value>, equal: *mut bool) -> bool;
    #[link_name =
          "_Z15JS_LooselyEqualP9JSContextN2JS6HandleINS1_5ValueEEES4_Pb"]
    pub fn JS_LooselyEqual(cx: *mut JSContext, v1: Handle<Value>,
                           v2: Handle<Value>, equal: *mut bool) -> bool;
    #[link_name = "_Z12JS_SameValueP9JSContextN2JS6HandleINS1_5ValueEEES4_Pb"]
    pub fn JS_SameValue(cx: *mut JSContext, v1: Handle<Value>,
                        v2: Handle<Value>, same: *mut bool) -> bool;
    /** True iff fun is the global eval function. */
    #[link_name = "_Z24JS_IsBuiltinEvalFunctionP10JSFunction"]
    pub fn JS_IsBuiltinEvalFunction(fun: *mut JSFunction) -> bool;
    /** True iff fun is the Function constructor. */
    #[link_name = "_Z31JS_IsBuiltinFunctionConstructorP10JSFunction"]
    pub fn JS_IsBuiltinFunctionConstructor(fun: *mut JSFunction) -> bool;
    /************************************************************************/
    #[link_name = "_Z13JS_NewRuntimejjP9JSRuntime"]
    pub fn JS_NewRuntime(maxbytes: u32, maxNurseryBytes: u32,
                         parentRuntime: *mut JSRuntime) -> *mut JSRuntime;
    #[link_name = "_Z17JS_DestroyRuntimeP9JSRuntime"]
    pub fn JS_DestroyRuntime(rt: *mut JSRuntime);
    /**
 * The embedding can specify a time function that will be used in some
 * situations.  The function can return the time however it likes; but
 * the norm is to return times in units of milliseconds since an
 * arbitrary, but consistent, epoch.  If the time function is not set,
 * a built-in default will be used.
 */
    #[link_name = "_Z33JS_SetCurrentEmbedderTimeFunctionPFdvE"]
    pub fn JS_SetCurrentEmbedderTimeFunction(timeFn:
                                                 JS_CurrentEmbedderTimeFunction);
    /**
 * Return the time as computed using the current time function, or a
 * suitable default if one has not been set.
 */
    #[link_name = "_Z25JS_GetCurrentEmbedderTimev"]
    pub fn JS_GetCurrentEmbedderTime() -> f64;
    #[link_name = "_Z20JS_GetRuntimePrivateP9JSRuntime"]
    pub fn JS_GetRuntimePrivate(rt: *mut JSRuntime)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "_Z13JS_GetRuntimeP9JSContext"]
    pub fn JS_GetRuntime(cx: *mut JSContext) -> *mut JSRuntime;
    #[link_name = "_Z19JS_GetParentRuntimeP9JSRuntime"]
    pub fn JS_GetParentRuntime(rt: *mut JSRuntime) -> *mut JSRuntime;
    #[link_name = "_Z20JS_SetRuntimePrivateP9JSRuntimePv"]
    pub fn JS_SetRuntimePrivate(rt: *mut JSRuntime,
                                data: *mut ::std::os::raw::c_void);
    #[link_name = "_Z15JS_BeginRequestP9JSContext"]
    pub fn JS_BeginRequest(cx: *mut JSContext);
    #[link_name = "_Z13JS_EndRequestP9JSContext"]
    pub fn JS_EndRequest(cx: *mut JSContext);
    #[link_name = "_Z18JS_SetFutexCanWaitP9JSRuntime"]
    pub fn JS_SetFutexCanWait(rt: *mut JSRuntime);
    #[link_name = "_ZN2js16AssertHeapIsIdleEP9JSRuntime"]
    pub fn AssertHeapIsIdle(rt: *mut JSRuntime);
    /**
 * Returns the runtime's JSContext. The plan is to expose a single type to the
 * API, so this function will likely be removed soon.
 */
    #[link_name = "_Z13JS_GetContextP9JSRuntime"]
    pub fn JS_GetContext(rt: *mut JSRuntime) -> *mut JSContext;
    #[link_name = "_Z13JS_GetVersionP9JSContext"]
    pub fn JS_GetVersion(cx: *mut JSContext) -> JSVersion;
    /**
 * Mutate the version on the compartment. This is generally discouraged, but
 * necessary to support the version mutation in the js and xpc shell command
 * set.
 *
 * It would be nice to put this in jsfriendapi, but the linkage requirements
 * of the shells make that impossible.
 */
    #[link_name = "_Z27JS_SetVersionForCompartmentP13JSCompartment9JSVersion"]
    pub fn JS_SetVersionForCompartment(compartment: *mut JSCompartment,
                                       version: JSVersion);
    #[link_name = "_Z18JS_VersionToString9JSVersion"]
    pub fn JS_VersionToString(version: JSVersion)
     -> *const ::std::os::raw::c_char;
    #[link_name = "_Z18JS_StringToVersionPKc"]
    pub fn JS_StringToVersion(string: *const ::std::os::raw::c_char)
     -> JSVersion;
    #[link_name = "_ZN2JS17RuntimeOptionsRefEP9JSRuntime"]
    pub fn RuntimeOptionsRef(rt: *mut JSRuntime) -> *mut RuntimeOptions;
    #[link_name = "_ZN2JS17RuntimeOptionsRefEP9JSContext"]
    pub fn RuntimeOptionsRef1(cx: *mut JSContext) -> *mut RuntimeOptions;
    /**
 * Initialize the runtime's self-hosted code. Embeddings should call this
 * exactly once per runtime/context, before the first JS_NewGlobalObject
 * call.
 */
    #[link_name = "_ZN2JS18InitSelfHostedCodeEP9JSContext"]
    pub fn InitSelfHostedCode(cx: *mut JSContext) -> bool;
    #[link_name = "_Z27JS_GetImplementationVersionv"]
    pub fn JS_GetImplementationVersion() -> *const ::std::os::raw::c_char;
    #[link_name =
          "_Z32JS_SetDestroyCompartmentCallbackP9JSRuntimePFvP8JSFreeOpP13JSCompartmentE"]
    pub fn JS_SetDestroyCompartmentCallback(rt: *mut JSRuntime,
                                            callback:
                                                JSDestroyCompartmentCallback);
    #[link_name =
          "_Z44JS_SetSizeOfIncludingThisCompartmentCallbackP9JSRuntimePFyPFyPKvEP13JSCompartmentE"]
    pub fn JS_SetSizeOfIncludingThisCompartmentCallback(rt: *mut JSRuntime,
                                                        callback:
                                                            JSSizeOfIncludingThisCompartmentCallback);
    #[link_name = "_Z25JS_SetDestroyZoneCallbackP9JSRuntimePFvPN2JS4ZoneEE"]
    pub fn JS_SetDestroyZoneCallback(rt: *mut JSRuntime,
                                     callback: JSZoneCallback);
    #[link_name = "_Z23JS_SetSweepZoneCallbackP9JSRuntimePFvPN2JS4ZoneEE"]
    pub fn JS_SetSweepZoneCallback(rt: *mut JSRuntime,
                                   callback: JSZoneCallback);
    #[link_name =
          "_Z29JS_SetCompartmentNameCallbackP9JSRuntimePFvS0_P13JSCompartmentPcyE"]
    pub fn JS_SetCompartmentNameCallback(rt: *mut JSRuntime,
                                         callback: JSCompartmentNameCallback);
    #[link_name =
          "_Z25JS_SetWrapObjectCallbacksP9JSRuntimePK21JSWrapObjectCallbacks"]
    pub fn JS_SetWrapObjectCallbacks(rt: *mut JSRuntime,
                                     callbacks: *const JSWrapObjectCallbacks);
    #[link_name = "_Z24JS_SetCompartmentPrivateP13JSCompartmentPv"]
    pub fn JS_SetCompartmentPrivate(compartment: *mut JSCompartment,
                                    data: *mut ::std::os::raw::c_void);
    #[link_name = "_Z24JS_GetCompartmentPrivateP13JSCompartment"]
    pub fn JS_GetCompartmentPrivate(compartment: *mut JSCompartment)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "_Z18JS_SetZoneUserDataPN2JS4ZoneEPv"]
    pub fn JS_SetZoneUserData(zone: *mut Zone,
                              data: *mut ::std::os::raw::c_void);
    #[link_name = "_Z18JS_GetZoneUserDataPN2JS4ZoneE"]
    pub fn JS_GetZoneUserData(zone: *mut Zone) -> *mut ::std::os::raw::c_void;
    #[link_name =
          "_Z13JS_WrapObjectP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
    pub fn JS_WrapObject(cx: *mut JSContext, objp: MutableHandleObject)
     -> bool;
    #[link_name =
          "_Z12JS_WrapValueP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
    pub fn JS_WrapValue(cx: *mut JSContext, vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z19JS_TransplantObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_TransplantObject(cx: *mut JSContext, origobj: HandleObject,
                               target: HandleObject) -> *mut JSObject;
    #[link_name =
          "_Z34JS_RefreshCrossCompartmentWrappersP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut JSContext,
                                              obj: Handle<*mut JSObject>)
     -> bool;
    /** NB: This API is infallible; a nullptr return value does not indicate error. */
    #[link_name = "_Z19JS_EnterCompartmentP9JSContextP8JSObject"]
    pub fn JS_EnterCompartment(cx: *mut JSContext, target: *mut JSObject)
     -> *mut JSCompartment;
    #[link_name = "_Z19JS_LeaveCompartmentP9JSContextP13JSCompartment"]
    pub fn JS_LeaveCompartment(cx: *mut JSContext,
                               oldCompartment: *mut JSCompartment);
    /**
 * This function calls |compartmentCallback| on every compartment. Beware that
 * there is no guarantee that the compartment will survive after the callback
 * returns. Also, barriers are disabled via the TraceSession.
 */
    #[link_name =
          "_Z22JS_IterateCompartmentsP9JSRuntimePvPFvS0_S1_P13JSCompartmentE"]
    pub fn JS_IterateCompartments(rt: *mut JSRuntime,
                                  data: *mut ::std::os::raw::c_void,
                                  compartmentCallback:
                                      JSIterateCompartmentCallback);
    /**
 * Initialize standard JS class constructors, prototypes, and any top-level
 * functions and constants associated with the standard classes (e.g. isNaN
 * for Number).
 *
 * NB: This sets cx's global object to obj if it was null.
 */
    #[link_name =
          "_Z22JS_InitStandardClassesP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_InitStandardClasses(cx: *mut JSContext,
                                  obj: Handle<*mut JSObject>) -> bool;
    /**
 * Resolve id, which must contain either a string or an int, to a standard
 * class name in obj if possible, defining the class's constructor and/or
 * prototype and storing true in *resolved.  If id does not name a standard
 * class or a top-level property induced by initializing a standard class,
 * store false in *resolved and just return true.  Return false on error,
 * as usual for bool result-typed API entry points.
 *
 * This API can be called directly from a global object class's resolve op,
 * to define standard classes lazily.  The class's enumerate op should call
 * JS_EnumerateStandardClasses(cx, obj), to define eagerly during for..in
 * loops any classes not yet resolved lazily.
 */
    #[link_name =
          "_Z23JS_ResolveStandardClassP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEPb"]
    pub fn JS_ResolveStandardClass(cx: *mut JSContext, obj: HandleObject,
                                   id: HandleId, resolved: *mut bool) -> bool;
    #[link_name =
          "_Z26JS_MayResolveStandardClassRK11JSAtomState4jsidP8JSObject"]
    pub fn JS_MayResolveStandardClass(names: *const JSAtomState, id: jsid,
                                      maybeObj: *mut JSObject) -> bool;
    #[link_name =
          "_Z27JS_EnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_EnumerateStandardClasses(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name =
          "_Z17JS_GetClassObjectP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
    pub fn JS_GetClassObject(cx: *mut JSContext, key: JSProtoKey,
                             objp: MutableHandle<*mut JSObject>) -> bool;
    #[link_name =
          "_Z20JS_GetClassPrototypeP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
    pub fn JS_GetClassPrototype(cx: *mut JSContext, key: JSProtoKey,
                                objp: MutableHandle<*mut JSObject>) -> bool;
    #[link_name = "_ZN2JS24IdentifyStandardInstanceEP8JSObject"]
    pub fn IdentifyStandardInstance(obj: *mut JSObject) -> JSProtoKey;
    #[link_name = "_ZN2JS25IdentifyStandardPrototypeEP8JSObject"]
    pub fn IdentifyStandardPrototype(obj: *mut JSObject) -> JSProtoKey;
    #[link_name = "_ZN2JS35IdentifyStandardInstanceOrPrototypeEP8JSObject"]
    pub fn IdentifyStandardInstanceOrPrototype(obj: *mut JSObject)
     -> JSProtoKey;
    #[link_name = "_ZN2JS27IdentifyStandardConstructorEP8JSObject"]
    pub fn IdentifyStandardConstructor(obj: *mut JSObject) -> JSProtoKey;
    #[link_name =
          "_ZN2JS12ProtoKeyToIdEP9JSContext10JSProtoKeyNS_13MutableHandleI4jsidEE"]
    pub fn ProtoKeyToId(cx: *mut JSContext, key: JSProtoKey,
                        idp: MutableHandleId);
    #[link_name = "_Z15JS_IdToProtoKeyP9JSContextN2JS6HandleI4jsidEE"]
    pub fn JS_IdToProtoKey(cx: *mut JSContext, id: HandleId) -> JSProtoKey;
    /**
 * Returns the original value of |Function.prototype| from the global object in
 * which |forObj| was created.
 */
    #[link_name =
          "_Z23JS_GetFunctionPrototypeP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_GetFunctionPrototype(cx: *mut JSContext, forObj: HandleObject)
     -> *mut JSObject;
    /**
 * Returns the original value of |Object.prototype| from the global object in
 * which |forObj| was created.
 */
    #[link_name =
          "_Z21JS_GetObjectPrototypeP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_GetObjectPrototype(cx: *mut JSContext, forObj: HandleObject)
     -> *mut JSObject;
    /**
 * Returns the original value of |Array.prototype| from the global object in
 * which |forObj| was created.
 */
    #[link_name =
          "_Z20JS_GetArrayPrototypeP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_GetArrayPrototype(cx: *mut JSContext, forObj: HandleObject)
     -> *mut JSObject;
    /**
 * Returns the original value of |Error.prototype| from the global
 * object of the current compartment of cx.
 */
    #[link_name = "_Z20JS_GetErrorPrototypeP9JSContext"]
    pub fn JS_GetErrorPrototype(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Returns the %IteratorPrototype% object that all built-in iterator prototype
 * chains go through for the global object of the current compartment of cx.
 */
    #[link_name = "_Z23JS_GetIteratorPrototypeP9JSContext"]
    pub fn JS_GetIteratorPrototype(cx: *mut JSContext) -> *mut JSObject;
    #[link_name = "_Z21JS_GetGlobalForObjectP9JSContextP8JSObject"]
    pub fn JS_GetGlobalForObject(cx: *mut JSContext, obj: *mut JSObject)
     -> *mut JSObject;
    #[link_name = "_Z17JS_IsGlobalObjectP8JSObject"]
    pub fn JS_IsGlobalObject(obj: *mut JSObject) -> bool;
    #[link_name = "_Z21JS_GlobalLexicalScopeP8JSObject"]
    pub fn JS_GlobalLexicalScope(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_Z28JS_HasExtensibleLexicalScopeP8JSObject"]
    pub fn JS_HasExtensibleLexicalScope(obj: *mut JSObject) -> bool;
    #[link_name = "_Z25JS_ExtensibleLexicalScopeP8JSObject"]
    pub fn JS_ExtensibleLexicalScope(obj: *mut JSObject) -> *mut JSObject;
    /**
 * May return nullptr, if |c| never had a global (e.g. the atoms compartment),
 * or if |c|'s global has been collected.
 */
    #[link_name =
          "_Z32JS_GetGlobalForCompartmentOrNullP9JSContextP13JSCompartment"]
    pub fn JS_GetGlobalForCompartmentOrNull(cx: *mut JSContext,
                                            c: *mut JSCompartment)
     -> *mut JSObject;
    #[link_name = "_ZN2JS19CurrentGlobalOrNullEP9JSContext"]
    pub fn CurrentGlobalOrNull(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
 * given global.
 */
    #[link_name =
          "_Z19JS_InitReflectParseP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_InitReflectParse(cx: *mut JSContext, global: HandleObject)
     -> bool;
    /**
 * Add various profiling-related functions as properties of the given object.
 * Defined in builtin/Profilers.cpp.
 */
    #[link_name =
          "_Z27JS_DefineProfilingFunctionsP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_DefineProfilingFunctions(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name =
          "_Z23JS_DefineDebuggerObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_DefineDebuggerObject(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name = "_Z9JS_mallocP9JSContexty"]
    pub fn JS_malloc(cx: *mut JSContext, nbytes: usize)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "_Z10JS_reallocP9JSContextPvyy"]
    pub fn JS_realloc(cx: *mut JSContext, p: *mut ::std::os::raw::c_void,
                      oldBytes: usize, newBytes: usize)
     -> *mut ::std::os::raw::c_void;
    /**
 * A wrapper for js_free(p) that may delay js_free(p) invocation as a
 * performance optimization.
 * cx may be nullptr.
 */
    #[link_name = "_Z7JS_freeP9JSContextPv"]
    pub fn JS_free(cx: *mut JSContext, p: *mut ::std::os::raw::c_void);
    /**
 * A wrapper for js_free(p) that may delay js_free(p) invocation as a
 * performance optimization as specified by the given JSFreeOp instance.
 */
    #[link_name = "_Z9JS_freeopP8JSFreeOpPv"]
    pub fn JS_freeop(fop: *mut JSFreeOp, p: *mut ::std::os::raw::c_void);
    #[link_name = "_Z19JS_GetDefaultFreeOpP9JSRuntime"]
    pub fn JS_GetDefaultFreeOp(rt: *mut JSRuntime) -> *mut JSFreeOp;
    #[link_name = "_Z22JS_updateMallocCounterP9JSContexty"]
    pub fn JS_updateMallocCounter(cx: *mut JSContext, nbytes: usize);
    #[link_name = "_Z9JS_strdupP9JSContextPKc"]
    pub fn JS_strdup(cx: *mut JSContext, s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    /** Duplicate a string.  Does not report an error on failure. */
    #[link_name = "_Z9JS_strdupP9JSRuntimePKc"]
    pub fn JS_strdup1(rt: *mut JSRuntime, s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    /**
 * Register externally maintained GC roots.
 *
 * traceOp: the trace operation. For each root the implementation should call
 *          JS_CallTracer whenever the root contains a traceable thing.
 * data:    the data argument to pass to each invocation of traceOp.
 */
    #[link_name =
          "_Z24JS_AddExtraGCRootsTracerP9JSRuntimePFvP8JSTracerPvES3_"]
    pub fn JS_AddExtraGCRootsTracer(rt: *mut JSRuntime,
                                    traceOp: JSTraceDataOp,
                                    data: *mut ::std::os::raw::c_void)
     -> bool;
    /** Undo a call to JS_AddExtraGCRootsTracer. */
    #[link_name =
          "_Z27JS_RemoveExtraGCRootsTracerP9JSRuntimePFvP8JSTracerPvES3_"]
    pub fn JS_RemoveExtraGCRootsTracer(rt: *mut JSRuntime,
                                       traceOp: JSTraceDataOp,
                                       data: *mut ::std::os::raw::c_void);
    #[link_name = "_Z5JS_GCP9JSRuntime"]
    pub fn JS_GC(rt: *mut JSRuntime);
    #[link_name = "_Z10JS_MaybeGCP9JSContext"]
    pub fn JS_MaybeGC(cx: *mut JSContext);
    #[link_name = "_Z16JS_SetGCCallbackP9JSRuntimePFvS0_10JSGCStatusPvES2_"]
    pub fn JS_SetGCCallback(rt: *mut JSRuntime, cb: JSGCCallback,
                            data: *mut ::std::os::raw::c_void);
    #[link_name = "_Z28JS_SetObjectsTenuredCallbackP9JSRuntimePFvS0_PvES1_"]
    pub fn JS_SetObjectsTenuredCallback(rt: *mut JSRuntime,
                                        cb: JSObjectsTenuredCallback,
                                        data: *mut ::std::os::raw::c_void);
    #[link_name =
          "_Z22JS_AddFinalizeCallbackP9JSRuntimePFvP8JSFreeOp16JSFinalizeStatusbPvES4_"]
    pub fn JS_AddFinalizeCallback(rt: *mut JSRuntime, cb: JSFinalizeCallback,
                                  data: *mut ::std::os::raw::c_void) -> bool;
    #[link_name =
          "_Z25JS_RemoveFinalizeCallbackP9JSRuntimePFvP8JSFreeOp16JSFinalizeStatusbPvE"]
    pub fn JS_RemoveFinalizeCallback(rt: *mut JSRuntime,
                                     cb: JSFinalizeCallback);
    #[link_name =
          "_Z34JS_AddWeakPointerZoneGroupCallbackP9JSRuntimePFvS0_PvES1_"]
    pub fn JS_AddWeakPointerZoneGroupCallback(rt: *mut JSRuntime,
                                              cb:
                                                  JSWeakPointerZoneGroupCallback,
                                              data:
                                                  *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "_Z37JS_RemoveWeakPointerZoneGroupCallbackP9JSRuntimePFvS0_PvE"]
    pub fn JS_RemoveWeakPointerZoneGroupCallback(rt: *mut JSRuntime,
                                                 cb:
                                                     JSWeakPointerZoneGroupCallback);
    #[link_name =
          "_Z36JS_AddWeakPointerCompartmentCallbackP9JSRuntimePFvS0_P13JSCompartmentPvES3_"]
    pub fn JS_AddWeakPointerCompartmentCallback(rt: *mut JSRuntime,
                                                cb:
                                                    JSWeakPointerCompartmentCallback,
                                                data:
                                                    *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "_Z39JS_RemoveWeakPointerCompartmentCallbackP9JSRuntimePFvS0_P13JSCompartmentPvE"]
    pub fn JS_RemoveWeakPointerCompartmentCallback(rt: *mut JSRuntime,
                                                   cb:
                                                       JSWeakPointerCompartmentCallback);
    #[link_name = "_Z27JS_UpdateWeakPointerAfterGCPN2JS4HeapIP8JSObjectEE"]
    pub fn JS_UpdateWeakPointerAfterGC(objp: *mut Heap<*mut JSObject>);
    #[link_name = "_Z38JS_UpdateWeakPointerAfterGCUnbarrieredPP8JSObject"]
    pub fn JS_UpdateWeakPointerAfterGCUnbarriered(objp: *mut *mut JSObject);
    #[link_name = "_Z17JS_SetGCParameterP9JSRuntime12JSGCParamKeyj"]
    pub fn JS_SetGCParameter(rt: *mut JSRuntime, key: JSGCParamKey,
                             value: u32);
    #[link_name = "_Z17JS_GetGCParameterP9JSRuntime12JSGCParamKey"]
    pub fn JS_GetGCParameter(rt: *mut JSRuntime, key: JSGCParamKey) -> u32;
    #[link_name = "_Z40JS_SetGCParametersBasedOnAvailableMemoryP9JSRuntimej"]
    pub fn JS_SetGCParametersBasedOnAvailableMemory(rt: *mut JSRuntime,
                                                    availMem: u32);
    /**
 * Create a new JSString whose chars member refers to external memory, i.e.,
 * memory requiring application-specific finalization.
 */
    #[link_name =
          "_Z20JS_NewExternalStringP9JSContextPKDsyPK17JSStringFinalizer"]
    pub fn JS_NewExternalString(cx: *mut JSContext,
                                chars: *const ::std::os::raw::c_ushort,
                                length: usize, fin: *const JSStringFinalizer)
     -> *mut JSString;
    /**
 * Return whether 'str' was created with JS_NewExternalString or
 * JS_NewExternalStringWithClosure.
 */
    #[link_name = "_Z19JS_IsExternalStringP8JSString"]
    pub fn JS_IsExternalString(str: *mut JSString) -> bool;
    /**
 * Return the 'fin' arg passed to JS_NewExternalString.
 */
    #[link_name = "_Z29JS_GetExternalStringFinalizerP8JSString"]
    pub fn JS_GetExternalStringFinalizer(str: *mut JSString)
     -> *const JSStringFinalizer;
    /**
 * Set the size of the native stack that should not be exceed. To disable
 * stack size checking pass 0.
 *
 * SpiderMonkey allows for a distinction between system code (such as GCs, which
 * may incidentally be triggered by script but are not strictly performed on
 * behalf of such script), trusted script (as determined by JS_SetTrustedPrincipals),
 * and untrusted script. Each kind of code may have a different stack quota,
 * allowing embedders to keep higher-priority machinery running in the face of
 * scripted stack exhaustion by something else.
 *
 * The stack quotas for each kind of code should be monotonically descending,
 * and may be specified with this function. If 0 is passed for a given kind
 * of code, it defaults to the value of the next-highest-priority kind.
 *
 * This function may only be called immediately after the runtime is initialized
 * and before any code is executed and/or interrupts requested.
 */
    #[link_name = "_Z22JS_SetNativeStackQuotaP9JSRuntimeyyy"]
    pub fn JS_SetNativeStackQuota(cx: *mut JSRuntime,
                                  systemCodeStackSize: usize,
                                  trustedScriptStackSize: usize,
                                  untrustedScriptStackSize: usize);
    /************************************************************************/
    #[link_name =
          "_Z12JS_ValueToIdP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleI4jsidEE"]
    pub fn JS_ValueToId(cx: *mut JSContext, v: HandleValue,
                        idp: MutableHandleId) -> bool;
    #[link_name =
          "_Z13JS_StringToIdP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleI4jsidEE"]
    pub fn JS_StringToId(cx: *mut JSContext, s: HandleString,
                         idp: MutableHandleId) -> bool;
    #[link_name =
          "_Z12JS_IdToValueP9JSContext4jsidN2JS13MutableHandleINS2_5ValueEEE"]
    pub fn JS_IdToValue(cx: *mut JSContext, id: jsid,
                        vp: MutableHandle<Value>) -> bool;
    /**
 * Convert obj to a primitive value. On success, store the result in vp and
 * return true.
 *
 * The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_VOID (no
 * hint).
 *
 * Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType]).
 */
    #[link_name =
          "_ZN2JS11ToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
    pub fn ToPrimitive(cx: *mut JSContext, obj: HandleObject, hint: JSType,
                       vp: MutableHandleValue) -> bool;
    /**
 * If args.get(0) is one of the strings "string", "number", or "default", set
 * *result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_VOID accordingly and
 * return true. Otherwise, return false with a TypeError pending.
 *
 * This can be useful in implementing a @@toPrimitive method.
 */
    #[link_name =
          "_ZN2JS26GetFirstArgumentAsTypeHintEP9JSContextNS_8CallArgsEP6JSType"]
    pub fn GetFirstArgumentAsTypeHint(cx: *mut JSContext, args: CallArgs,
                                      result: *mut JSType) -> bool;
    #[link_name =
          "_Z15JS_PropertyStubP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_PropertyStub(cx: *mut JSContext, obj: HandleObject,
                           id: HandleId, vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z21JS_StrictPropertyStubP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS1_13MutableHandleINS1_5ValueEEERNS1_14ObjectOpResultE"]
    pub fn JS_StrictPropertyStub(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId, vp: MutableHandleValue,
                                 result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "_Z12JS_InitClassP9JSContextN2JS6HandleIP8JSObjectEES5_PK7JSClassPFbS0_jPNS1_5ValueEEjPK14JSPropertySpecPK14JSFunctionSpecSF_SI_"]
    pub fn JS_InitClass(cx: *mut JSContext, obj: HandleObject,
                        parent_proto: HandleObject, clasp: *const JSClass,
                        constructor: JSNative, nargs: ::std::os::raw::c_uint,
                        ps: *const JSPropertySpec, fs: *const JSFunctionSpec,
                        static_ps: *const JSPropertySpec,
                        static_fs: *const JSFunctionSpec) -> *mut JSObject;
    /**
 * Set up ctor.prototype = proto and proto.constructor = ctor with the
 * right property flags.
 */
    #[link_name =
          "_Z30JS_LinkConstructorAndPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_LinkConstructorAndPrototype(cx: *mut JSContext,
                                          ctor: Handle<*mut JSObject>,
                                          proto: Handle<*mut JSObject>)
     -> bool;
    #[link_name = "_Z11JS_GetClassP8JSObject"]
    pub fn JS_GetClass(obj: *mut JSObject) -> *const JSClass;
    #[link_name =
          "_Z13JS_InstanceOfP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
    pub fn JS_InstanceOf(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                         clasp: *const JSClass, args: *mut CallArgs) -> bool;
    #[link_name =
          "_Z14JS_HasInstanceP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEEPb"]
    pub fn JS_HasInstance(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                          v: Handle<Value>, bp: *mut bool) -> bool;
    #[link_name = "_Z13JS_GetPrivateP8JSObject"]
    pub fn JS_GetPrivate(obj: *mut JSObject) -> *mut ::std::os::raw::c_void;
    #[link_name = "_Z13JS_SetPrivateP8JSObjectPv"]
    pub fn JS_SetPrivate(obj: *mut JSObject,
                         data: *mut ::std::os::raw::c_void);
    #[link_name =
          "_Z21JS_GetInstancePrivateP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
    pub fn JS_GetInstancePrivate(cx: *mut JSContext,
                                 obj: Handle<*mut JSObject>,
                                 clasp: *const JSClass, args: *mut CallArgs)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "_Z17JS_GetConstructorP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_GetConstructor(cx: *mut JSContext, proto: Handle<*mut JSObject>)
     -> *mut JSObject;
    #[link_name = "_ZN2JS29CompartmentCreationOptionsRefEP13JSCompartment"]
    pub fn CompartmentCreationOptionsRef(compartment: *mut JSCompartment)
     -> *const CompartmentCreationOptions;
    #[link_name = "_ZN2JS29CompartmentCreationOptionsRefEP8JSObject"]
    pub fn CompartmentCreationOptionsRef1(obj: *mut JSObject)
     -> *const CompartmentCreationOptions;
    #[link_name = "_ZN2JS29CompartmentCreationOptionsRefEP9JSContext"]
    pub fn CompartmentCreationOptionsRef2(cx: *mut JSContext)
     -> *const CompartmentCreationOptions;
    #[link_name = "_ZN2JS23CompartmentBehaviorsRefEP13JSCompartment"]
    pub fn CompartmentBehaviorsRef(compartment: *mut JSCompartment)
     -> *mut CompartmentBehaviors;
    #[link_name = "_ZN2JS23CompartmentBehaviorsRefEP8JSObject"]
    pub fn CompartmentBehaviorsRef1(obj: *mut JSObject)
     -> *mut CompartmentBehaviors;
    #[link_name = "_ZN2JS23CompartmentBehaviorsRefEP9JSContext"]
    pub fn CompartmentBehaviorsRef2(cx: *mut JSContext)
     -> *mut CompartmentBehaviors;
    #[link_name =
          "_Z18JS_NewGlobalObjectP9JSContextPK7JSClassP12JSPrincipalsN2JS21OnNewGlobalHookOptionERKNS6_18CompartmentOptionsE"]
    pub fn JS_NewGlobalObject(cx: *mut JSContext, clasp: *const JSClass,
                              principals: *mut JSPrincipals,
                              hookOption: OnNewGlobalHookOption,
                              options: *const CompartmentOptions)
     -> *mut JSObject;
    /**
 * Spidermonkey does not have a good way of keeping track of what compartments should be marked on
 * their own. We can mark the roots unconditionally, but marking GC things only relevant in live
 * compartments is hard. To mitigate this, we create a static trace hook, installed on each global
 * object, from which we can be sure the compartment is relevant, and mark it.
 *
 * It is still possible to specify custom trace hooks for global object classes. They can be
 * provided via the CompartmentOptions passed to JS_NewGlobalObject.
 */
    #[link_name = "_Z24JS_GlobalObjectTraceHookP8JSTracerP8JSObject"]
    pub fn JS_GlobalObjectTraceHook(trc: *mut JSTracer,
                                    global: *mut JSObject);
    #[link_name =
          "_Z24JS_FireOnNewGlobalObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_FireOnNewGlobalObject(cx: *mut JSContext, global: HandleObject);
    #[link_name = "_Z12JS_NewObjectP9JSContextPK7JSClass"]
    pub fn JS_NewObject(cx: *mut JSContext, clasp: *const JSClass)
     -> *mut JSObject;
    #[link_name = "_Z11JS_IsNativeP8JSObject"]
    pub fn JS_IsNative(obj: *mut JSObject) -> bool;
    #[link_name = "_Z19JS_GetObjectRuntimeP8JSObject"]
    pub fn JS_GetObjectRuntime(obj: *mut JSObject) -> *mut JSRuntime;
    /**
 * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
 * proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].
 */
    #[link_name =
          "_Z26JS_NewObjectWithGivenProtoP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewObjectWithGivenProto(cx: *mut JSContext,
                                      clasp: *const JSClass,
                                      proto: Handle<*mut JSObject>)
     -> *mut JSObject;
    /** Creates a new plain object, like `new Object()`, with Object.prototype as [[Prototype]]. */
    #[link_name = "_Z17JS_NewPlainObjectP9JSContext"]
    pub fn JS_NewPlainObject(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Freeze obj, and all objects it refers to, recursively. This will not recurse
 * through non-extensible objects, on the assumption that those are already
 * deep-frozen.
 */
    #[link_name =
          "_Z19JS_DeepFreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_DeepFreezeObject(cx: *mut JSContext, obj: Handle<*mut JSObject>)
     -> bool;
    /**
 * Freezes an object; see ES5's Object.freeze(obj) method.
 */
    #[link_name = "_Z15JS_FreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_FreezeObject(cx: *mut JSContext, obj: Handle<*mut JSObject>)
     -> bool;
    #[link_name =
          "_ZN2JS34ObjectToCompletePropertyDescriptorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleINS_18PropertyDescriptorEEE"]
    pub fn ObjectToCompletePropertyDescriptor(cx: *mut JSContext,
                                              obj: HandleObject,
                                              descriptor: HandleValue,
                                              desc:
                                                  MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "_ZN2JS22FromPropertyDescriptorEP9JSContextNS_6HandleINS_18PropertyDescriptorEEENS_13MutableHandleINS_5ValueEEE"]
    pub fn FromPropertyDescriptor(cx: *mut JSContext,
                                  desc: Handle<PropertyDescriptor>,
                                  vp: MutableHandleValue) -> bool;
    /**
 * Get the prototype of obj, storing it in result.
 *
 * Implements: ES6 [[GetPrototypeOf]] internal method.
 */
    #[link_name =
          "_Z15JS_GetPrototypeP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
    pub fn JS_GetPrototype(cx: *mut JSContext, obj: HandleObject,
                           result: MutableHandleObject) -> bool;
    /**
 * If |obj| (underneath any functionally-transparent wrapper proxies) has as
 * its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined
 * for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype
 * in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both
 * outparams have unspecified value.
 */
    #[link_name =
          "_Z25JS_GetPrototypeIfOrdinaryP9JSContextN2JS6HandleIP8JSObjectEEPbNS1_13MutableHandleIS4_EE"]
    pub fn JS_GetPrototypeIfOrdinary(cx: *mut JSContext, obj: HandleObject,
                                     isOrdinary: *mut bool,
                                     result: MutableHandleObject) -> bool;
    /**
 * Change the prototype of obj.
 *
 * Implements: ES6 [[SetPrototypeOf]] internal method.
 *
 * In cases where ES6 [[SetPrototypeOf]] returns false without an exception,
 * JS_SetPrototype throws a TypeError and returns false.
 *
 * Performance warning: JS_SetPrototype is very bad for performance. It may
 * cause compiled jit-code to be invalidated. It also causes not only obj but
 * all other objects in the same "group" as obj to be permanently deoptimized.
 * It's better to create the object with the right prototype from the start.
 */
    #[link_name = "_Z15JS_SetPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_SetPrototype(cx: *mut JSContext, obj: HandleObject,
                           proto: HandleObject) -> bool;
    /**
 * Determine whether obj is extensible. Extensible objects can have new
 * properties defined on them. Inextensible objects can't, and their
 * [[Prototype]] slot is fixed as well.
 *
 * Implements: ES6 [[IsExtensible]] internal method.
 */
    #[link_name = "_Z15JS_IsExtensibleP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn JS_IsExtensible(cx: *mut JSContext, obj: HandleObject,
                           extensible: *mut bool) -> bool;
    /**
 * Attempt to make |obj| non-extensible.
 *
 * Not all failures are treated as errors. See the comment on
 * JS::ObjectOpResult in js/public/Class.h.
 *
 * Implements: ES6 [[PreventExtensions]] internal method.
 */
    #[link_name =
          "_Z20JS_PreventExtensionsP9JSContextN2JS6HandleIP8JSObjectEERNS1_14ObjectOpResultE"]
    pub fn JS_PreventExtensions(cx: *mut JSContext, obj: HandleObject,
                                result: *mut ObjectOpResult) -> bool;
    /**
 * Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt
 * to modify it will fail.  If an error occurs during the attempt, return false
 * (with a pending exception set, depending upon the nature of the error).  If
 * no error occurs, return true with |*succeeded| set to indicate whether the
 * attempt successfully made the [[Prototype]] immutable.
 *
 * This is a nonstandard internal method.
 */
    #[link_name =
          "_Z24JS_SetImmutablePrototypeP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn JS_SetImmutablePrototype(cx: *mut JSContext, obj: HandleObject,
                                    succeeded: *mut bool) -> bool;
    /**
 * Get a description of one of obj's own properties. If no such property exists
 * on obj, return true with desc.object() set to null.
 *
 * Implements: ES6 [[GetOwnProperty]] internal method.
 */
    #[link_name =
          "_Z31JS_GetOwnPropertyDescriptorByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
    pub fn JS_GetOwnPropertyDescriptorById(cx: *mut JSContext,
                                           obj: HandleObject, id: HandleId,
                                           desc:
                                               MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "_Z27JS_GetOwnPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
    pub fn JS_GetOwnPropertyDescriptor(cx: *mut JSContext, obj: HandleObject,
                                       name: *const ::std::os::raw::c_char,
                                       desc:
                                           MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "_Z29JS_GetOwnUCPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKDsNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
    pub fn JS_GetOwnUCPropertyDescriptor(cx: *mut JSContext,
                                         obj: HandleObject,
                                         name:
                                             *const ::std::os::raw::c_ushort,
                                         desc:
                                             MutableHandle<PropertyDescriptor>)
     -> bool;
    /**
 * Like JS_GetOwnPropertyDescriptorById, but also searches the prototype chain
 * if no own property is found directly on obj. The object on which the
 * property is found is returned in desc.object(). If the property is not found
 * on the prototype chain, this returns true with desc.object() set to null.
 */
    #[link_name =
          "_Z28JS_GetPropertyDescriptorByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
    pub fn JS_GetPropertyDescriptorById(cx: *mut JSContext, obj: HandleObject,
                                        id: HandleId,
                                        desc:
                                            MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "_Z24JS_GetPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
    pub fn JS_GetPropertyDescriptor(cx: *mut JSContext, obj: HandleObject,
                                    name: *const ::std::os::raw::c_char,
                                    desc: MutableHandle<PropertyDescriptor>)
     -> bool;
    /**
 * Define a property on obj.
 *
 * This function uses JS::ObjectOpResult to indicate conditions that ES6
 * specifies as non-error failures. This is inconvenient at best, so use this
 * function only if you are implementing a proxy handler's defineProperty()
 * method. For all other purposes, use one of the many DefineProperty functions
 * below that throw an exception in all failure cases.
 *
 * Implements: ES6 [[DefineOwnProperty]] internal method.
 */
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
    pub fn JS_DefinePropertyById(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId,
                                 desc: Handle<PropertyDescriptor>,
                                 result: *mut ObjectOpResult) -> bool;
    /**
 * Define a property on obj, throwing a TypeError if the attempt fails.
 * This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`.
 */
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_INS1_18PropertyDescriptorEEE"]
    pub fn JS_DefinePropertyById1(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId,
                                  desc: Handle<PropertyDescriptor>) -> bool;
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_INS1_5ValueEEEjPFbS0_jPS8_ESC_"]
    pub fn JS_DefinePropertyById2(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: HandleValue,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEES5_jPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefinePropertyById3(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: HandleObject,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_IP8JSStringEEjPFbS0_jPNS1_5ValueEESE_"]
    pub fn JS_DefinePropertyById4(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: HandleString,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEijPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefinePropertyById5(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: i32,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEjjPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefinePropertyById6(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: u32,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEdjPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefinePropertyById7(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: f64,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEEjPFbS0_jPS8_ESC_"]
    pub fn JS_DefineProperty(cx: *mut JSContext, obj: HandleObject,
                             name: *const ::std::os::raw::c_char,
                             value: HandleValue,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_jPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineProperty1(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char,
                              value: HandleObject,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_IP8JSStringEEjPFbS0_jPNS1_5ValueEESE_"]
    pub fn JS_DefineProperty2(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char,
                              value: HandleString,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcijPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineProperty3(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char, value: i32,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcjjPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineProperty4(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char, value: u32,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcdjPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineProperty5(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char, value: f64,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyNS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
    pub fn JS_DefineUCProperty(cx: *mut JSContext, obj: HandleObject,
                               name: *const ::std::os::raw::c_ushort,
                               namelen: usize,
                               desc: Handle<PropertyDescriptor>,
                               result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyNS2_INS1_18PropertyDescriptorEEE"]
    pub fn JS_DefineUCProperty1(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize,
                                desc: Handle<PropertyDescriptor>) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyNS2_INS1_5ValueEEEjPFbS0_jPS8_ESC_"]
    pub fn JS_DefineUCProperty2(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: HandleValue,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyS5_jPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineUCProperty3(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: HandleObject,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyNS2_IP8JSStringEEjPFbS0_jPNS1_5ValueEESE_"]
    pub fn JS_DefineUCProperty4(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: HandleString,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyijPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineUCProperty5(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: i32,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyjjPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineUCProperty6(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: u32,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsydjPFbS0_jPNS1_5ValueEESB_"]
    pub fn JS_DefineUCProperty7(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: f64,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEEjPFbS0_jPS6_ESA_"]
    pub fn JS_DefineElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                            value: HandleValue, attrs: ::std::os::raw::c_uint,
                            getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_jPFbS0_jPNS1_5ValueEES9_"]
    pub fn JS_DefineElement1(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: HandleObject,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEEjPFbS0_jPNS1_5ValueEESC_"]
    pub fn JS_DefineElement2(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: HandleString,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjijPFbS0_jPNS1_5ValueEES9_"]
    pub fn JS_DefineElement3(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: i32,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjjjPFbS0_jPNS1_5ValueEES9_"]
    pub fn JS_DefineElement4(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: u32,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjdjPFbS0_jPNS1_5ValueEES9_"]
    pub fn JS_DefineElement5(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: f64,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    /**
 * Compute the expression `id in obj`.
 *
 * If obj has an own or inherited property obj[id], set *foundp = true and
 * return true. If not, set *foundp = false and return true. On error, return
 * false with an exception pending.
 *
 * Implements: ES6 [[Has]] internal method.
 */
    #[link_name =
          "_Z18JS_HasPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEPb"]
    pub fn JS_HasPropertyById(cx: *mut JSContext, obj: HandleObject,
                              id: HandleId, foundp: *mut bool) -> bool;
    #[link_name =
          "_Z14JS_HasPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
    pub fn JS_HasProperty(cx: *mut JSContext, obj: HandleObject,
                          name: *const ::std::os::raw::c_char,
                          foundp: *mut bool) -> bool;
    #[link_name =
          "_Z16JS_HasUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyPb"]
    pub fn JS_HasUCProperty(cx: *mut JSContext, obj: HandleObject,
                            name: *const ::std::os::raw::c_ushort,
                            namelen: usize, vp: *mut bool) -> bool;
    #[link_name = "_Z13JS_HasElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
    pub fn JS_HasElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                         foundp: *mut bool) -> bool;
    /**
 * Determine whether obj has an own property with the key `id`.
 *
 * Implements: ES6 7.3.11 HasOwnProperty(O, P).
 */
    #[link_name =
          "_Z21JS_HasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEPb"]
    pub fn JS_HasOwnPropertyById(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId, foundp: *mut bool) -> bool;
    #[link_name =
          "_Z17JS_HasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
    pub fn JS_HasOwnProperty(cx: *mut JSContext, obj: HandleObject,
                             name: *const ::std::os::raw::c_char,
                             foundp: *mut bool) -> bool;
    /**
 * Get the value of the property `obj[id]`, or undefined if no such property
 * exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.
 *
 * Most callers don't need the `receiver` argument. Consider using
 * JS_GetProperty instead. (But if you're implementing a proxy handler's set()
 * method, it's often correct to call this function and pass the receiver
 * through.)
 *
 * Implements: ES6 [[Get]] internal method.
 */
    #[link_name =
          "_Z23JS_ForwardGetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_INS1_5ValueEEENS1_13MutableHandleIS8_EE"]
    pub fn JS_ForwardGetPropertyTo(cx: *mut JSContext, obj: HandleObject,
                                   id: HandleId, receiver: HandleValue,
                                   vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z22JS_ForwardGetElementToP9JSContextN2JS6HandleIP8JSObjectEEjS5_NS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ForwardGetElementTo(cx: *mut JSContext, obj: HandleObject,
                                  index: u32, receiver: HandleObject,
                                  vp: MutableHandleValue) -> bool;
    /**
 * Get the value of the property `obj[id]`, or undefined if no such property
 * exists. The result is stored in vp.
 *
 * Implements: ES6 7.3.1 Get(O, P).
 */
    #[link_name =
          "_Z18JS_GetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_GetPropertyById(cx: *mut JSContext, obj: HandleObject,
                              id: HandleId, vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z14JS_GetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_GetProperty(cx: *mut JSContext, obj: HandleObject,
                          name: *const ::std::os::raw::c_char,
                          vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z16JS_GetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyNS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_GetUCProperty(cx: *mut JSContext, obj: HandleObject,
                            name: *const ::std::os::raw::c_ushort,
                            namelen: usize, vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z13JS_GetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_GetElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                         vp: MutableHandleValue) -> bool;
    /**
 * Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.
 *
 * This function has a `receiver` argument that most callers don't need.
 * Consider using JS_SetProperty instead.
 *
 * Implements: ES6 [[Set]] internal method.
 */
    #[link_name =
          "_Z23JS_ForwardSetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_INS1_5ValueEEES9_RNS1_14ObjectOpResultE"]
    pub fn JS_ForwardSetPropertyTo(cx: *mut JSContext, obj: HandleObject,
                                   id: HandleId, v: HandleValue,
                                   receiver: HandleValue,
                                   result: *mut ObjectOpResult) -> bool;
    /**
 * Perform the assignment `obj[id] = v`.
 *
 * This function performs non-strict assignment, so if the property is
 * read-only, nothing happens and no error is thrown.
 */
    #[link_name =
          "_Z18JS_SetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEENS2_INS1_5ValueEEE"]
    pub fn JS_SetPropertyById(cx: *mut JSContext, obj: HandleObject,
                              id: HandleId, v: HandleValue) -> bool;
    #[link_name =
          "_Z14JS_SetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEE"]
    pub fn JS_SetProperty(cx: *mut JSContext, obj: HandleObject,
                          name: *const ::std::os::raw::c_char, v: HandleValue)
     -> bool;
    #[link_name =
          "_Z16JS_SetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyNS2_INS1_5ValueEEE"]
    pub fn JS_SetUCProperty(cx: *mut JSContext, obj: HandleObject,
                            name: *const ::std::os::raw::c_ushort,
                            namelen: usize, v: HandleValue) -> bool;
    #[link_name =
          "_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEE"]
    pub fn JS_SetElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                         v: HandleValue) -> bool;
    #[link_name = "_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_"]
    pub fn JS_SetElement1(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: HandleObject) -> bool;
    #[link_name =
          "_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEE"]
    pub fn JS_SetElement2(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: HandleString) -> bool;
    #[link_name = "_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_SetElement3(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: i32) -> bool;
    #[link_name = "_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjj"]
    pub fn JS_SetElement4(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: u32) -> bool;
    #[link_name = "_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjd"]
    pub fn JS_SetElement5(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: f64) -> bool;
    /**
 * Delete a property. This is the C++ equivalent of
 * `result = Reflect.deleteProperty(obj, id)`.
 *
 * This function has a `result` out parameter that most callers don't need.
 * Unless you can pass through an ObjectOpResult provided by your caller, it's
 * probably best to use the JS_DeletePropertyById signature with just 3
 * arguments.
 *
 * Implements: ES6 [[Delete]] internal method.
 */
    #[link_name =
          "_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEERNS1_14ObjectOpResultE"]
    pub fn JS_DeletePropertyById(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId, result: *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcRNS1_14ObjectOpResultE"]
    pub fn JS_DeleteProperty(cx: *mut JSContext, obj: HandleObject,
                             name: *const ::std::os::raw::c_char,
                             result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "_Z19JS_DeleteUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyRNS1_14ObjectOpResultE"]
    pub fn JS_DeleteUCProperty(cx: *mut JSContext, obj: HandleObject,
                               name: *const ::std::os::raw::c_ushort,
                               namelen: usize, result: *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEjRNS1_14ObjectOpResultE"]
    pub fn JS_DeleteElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                            result: *mut ObjectOpResult) -> bool;
    /**
 * Delete a property, ignoring strict failures. This is the C++ equivalent of
 * the JS `delete obj[id]` in non-strict mode code.
 */
    #[link_name =
          "_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEE4jsid"]
    pub fn JS_DeletePropertyById1(cx: *mut JSContext, obj: HandleObject,
                                  id: jsid) -> bool;
    #[link_name =
          "_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKc"]
    pub fn JS_DeleteProperty1(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char) -> bool;
    #[link_name = "_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEj"]
    pub fn JS_DeleteElement1(cx: *mut JSContext, obj: HandleObject,
                             index: u32) -> bool;
    /**
 * Return true if the given object is callable. In ES6 terms, an object is
 * callable if it has a [[Call]] internal method.
 *
 * Implements: ES6 7.2.3 IsCallable(argument).
 *
 * Functions are callable. A scripted proxy or wrapper is callable if its
 * target is callable. Most other objects aren't callable.
 */
    #[link_name = "_ZN2JS10IsCallableEP8JSObject"]
    pub fn IsCallable(obj: *mut JSObject) -> bool;
    /**
 * Return true if the given object is a constructor. In ES6 terms, an object is
 * a constructor if it has a [[Construct]] internal method. The expression
 * `new obj()` throws a TypeError if obj is not a constructor.
 *
 * Implements: ES6 7.2.4 IsConstructor(argument).
 *
 * JS functions and classes are constructors. Arrow functions and most builtin
 * functions are not. A scripted proxy or wrapper is a constructor if its
 * target is a constructor.
 */
    #[link_name = "_ZN2JS13IsConstructorEP8JSObject"]
    pub fn IsConstructor(obj: *mut JSObject) -> bool;
    /**
 * Call a function, passing a this-value and arguments. This is the C++
 * equivalent of `rval = Reflect.apply(fun, obj, args)`.
 *
 * Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
 * Use this function to invoke the [[Call]] internal method.
 */
    #[link_name =
          "_Z20JS_CallFunctionValueP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEERKNS1_16HandleValueArrayENS1_13MutableHandleIS6_EE"]
    pub fn JS_CallFunctionValue(cx: *mut JSContext, obj: HandleObject,
                                fval: HandleValue,
                                args: *const HandleValueArray,
                                rval: MutableHandleValue) -> bool;
    #[link_name =
          "_Z15JS_CallFunctionP9JSContextN2JS6HandleIP8JSObjectEENS2_IP10JSFunctionEERKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_CallFunction(cx: *mut JSContext, obj: HandleObject,
                           fun: HandleFunction, args: *const HandleValueArray,
                           rval: MutableHandleValue) -> bool;
    /**
 * Perform the method call `rval = obj[name](args)`.
 */
    #[link_name =
          "_Z19JS_CallFunctionNameP9JSContextN2JS6HandleIP8JSObjectEEPKcRKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_CallFunctionName(cx: *mut JSContext, obj: HandleObject,
                               name: *const ::std::os::raw::c_char,
                               args: *const HandleValueArray,
                               rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS4CallEP9JSContextNS_6HandleINS_5ValueEEES4_RKNS_16HandleValueArrayENS_13MutableHandleIS3_EE"]
    pub fn Call(cx: *mut JSContext, thisv: HandleValue, fun: HandleValue,
                args: *const HandleValueArray, rval: MutableHandleValue)
     -> bool;
    /**
 * Invoke a constructor. This is the C++ equivalent of
 * `rval = Reflect.construct(fun, args, newTarget)`.
 *
 * JS::Construct() takes a `newTarget` argument that most callers don't need.
 * Consider using the four-argument Construct signature instead. (But if you're
 * implementing a subclass or a proxy handler's construct() method, this is the
 * right function to call.)
 *
 * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).
 * Use this function to invoke the [[Construct]] internal method.
 */
    #[link_name =
          "_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEERKNS_16HandleValueArrayENS_13MutableHandleIS6_EE"]
    pub fn Construct(cx: *mut JSContext, fun: HandleValue,
                     newTarget: HandleObject, args: *const HandleValueArray,
                     objp: MutableHandleObject) -> bool;
    /**
 * Invoke a constructor. This is the C++ equivalent of
 * `rval = new fun(...args)`.
 *
 * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when
 * newTarget is omitted.
 */
    #[link_name =
          "_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEERKNS_16HandleValueArrayENS_13MutableHandleIP8JSObjectEE"]
    pub fn Construct1(cx: *mut JSContext, fun: HandleValue,
                      args: *const HandleValueArray,
                      objp: MutableHandleObject) -> bool;
    /**
 * Invoke a constructor, like the JS expression `new ctor(...args)`. Returns
 * the new object, or null on error.
 */
    #[link_name =
          "_Z6JS_NewP9JSContextN2JS6HandleIP8JSObjectEERKNS1_16HandleValueArrayE"]
    pub fn JS_New(cx: *mut JSContext, ctor: HandleObject,
                  args: *const HandleValueArray) -> *mut JSObject;
    /*** Other property-defining functions ***********************************************************/
    #[link_name =
          "_Z15JS_DefineObjectP9JSContextN2JS6HandleIP8JSObjectEEPKcPK7JSClassj"]
    pub fn JS_DefineObject(cx: *mut JSContext, obj: HandleObject,
                           name: *const ::std::os::raw::c_char,
                           clasp: *const JSClass,
                           attrs: ::std::os::raw::c_uint) -> *mut JSObject;
    #[link_name =
          "_Z21JS_DefineConstDoublesP9JSContextN2JS6HandleIP8JSObjectEEPK17JSConstScalarSpecIdE"]
    pub fn JS_DefineConstDoubles(cx: *mut JSContext, obj: HandleObject,
                                 cds: *const JSConstDoubleSpec) -> bool;
    #[link_name =
          "_Z22JS_DefineConstIntegersP9JSContextN2JS6HandleIP8JSObjectEEPK17JSConstScalarSpecIiE"]
    pub fn JS_DefineConstIntegers(cx: *mut JSContext, obj: HandleObject,
                                  cis: *const JSConstIntegerSpec) -> bool;
    #[link_name =
          "_Z19JS_DefinePropertiesP9JSContextN2JS6HandleIP8JSObjectEEPK14JSPropertySpec"]
    pub fn JS_DefineProperties(cx: *mut JSContext, obj: HandleObject,
                               ps: *const JSPropertySpec) -> bool;
    #[link_name =
          "_Z28JS_AlreadyHasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEPb"]
    pub fn JS_AlreadyHasOwnPropertyById(cx: *mut JSContext, obj: HandleObject,
                                        id: HandleId, foundp: *mut bool)
     -> bool;
    #[link_name =
          "_Z24JS_AlreadyHasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
    pub fn JS_AlreadyHasOwnProperty(cx: *mut JSContext, obj: HandleObject,
                                    name: *const ::std::os::raw::c_char,
                                    foundp: *mut bool) -> bool;
    #[link_name =
          "_Z26JS_AlreadyHasOwnUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsyPb"]
    pub fn JS_AlreadyHasOwnUCProperty(cx: *mut JSContext, obj: HandleObject,
                                      name: *const ::std::os::raw::c_ushort,
                                      namelen: usize, foundp: *mut bool)
     -> bool;
    #[link_name =
          "_Z23JS_AlreadyHasOwnElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
    pub fn JS_AlreadyHasOwnElement(cx: *mut JSContext, obj: HandleObject,
                                   index: u32, foundp: *mut bool) -> bool;
    #[link_name = "_Z17JS_NewArrayObjectP9JSContextRKN2JS16HandleValueArrayE"]
    pub fn JS_NewArrayObject(cx: *mut JSContext,
                             contents: *const HandleValueArray)
     -> *mut JSObject;
    #[link_name = "_Z17JS_NewArrayObjectP9JSContexty"]
    pub fn JS_NewArrayObject1(cx: *mut JSContext, length: usize)
     -> *mut JSObject;
    /**
 * Returns true and sets |*isArray| indicating whether |value| is an Array
 * object or a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isArray == false| when passed a proxy whose
 * target is an Array, or when passed a revoked proxy.
 */
    #[link_name =
          "_Z16JS_IsArrayObjectP9JSContextN2JS6HandleINS1_5ValueEEEPb"]
    pub fn JS_IsArrayObject(cx: *mut JSContext, value: HandleValue,
                            isArray: *mut bool) -> bool;
    /**
 * Returns true and sets |*isArray| indicating whether |obj| is an Array object
 * or a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isArray == false| when passed a proxy whose
 * target is an Array, or when passed a revoked proxy.
 */
    #[link_name = "_Z16JS_IsArrayObjectP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn JS_IsArrayObject1(cx: *mut JSContext, obj: HandleObject,
                             isArray: *mut bool) -> bool;
    #[link_name =
          "_Z17JS_GetArrayLengthP9JSContextN2JS6HandleIP8JSObjectEEPj"]
    pub fn JS_GetArrayLength(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                             lengthp: *mut u32) -> bool;
    #[link_name = "_Z17JS_SetArrayLengthP9JSContextN2JS6HandleIP8JSObjectEEj"]
    pub fn JS_SetArrayLength(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                             length: u32) -> bool;
    /**
 * Assign 'undefined' to all of the object's non-reserved slots. Note: this is
 * done for all slots, regardless of the associated property descriptor.
 */
    #[link_name =
          "_Z36JS_SetAllNonReservedSlotsToUndefinedP9JSContextP8JSObject"]
    pub fn JS_SetAllNonReservedSlotsToUndefined(cx: *mut JSContext,
                                                objArg: *mut JSObject);
    /**
 * Create a new array buffer with the given contents. It must be legal to pass
 * these contents to free(). On success, the ownership is transferred to the
 * new array buffer.
 */
    #[link_name = "_Z29JS_NewArrayBufferWithContentsP9JSContextyPv"]
    pub fn JS_NewArrayBufferWithContents(cx: *mut JSContext, nbytes: usize,
                                         contents:
                                             *mut ::std::os::raw::c_void)
     -> *mut JSObject;
    /**
 * Create a new array buffer with the given contents.  The array buffer does not take ownership of
 * contents, and JS_DetachArrayBuffer must be called before the contents are disposed of.
 */
    #[link_name = "_Z37JS_NewArrayBufferWithExternalContentsP9JSContextyPv"]
    pub fn JS_NewArrayBufferWithExternalContents(cx: *mut JSContext,
                                                 nbytes: usize,
                                                 contents:
                                                     *mut ::std::os::raw::c_void)
     -> *mut JSObject;
    /**
 * Steal the contents of the given array buffer. The array buffer has its
 * length set to 0 and its contents array cleared. The caller takes ownership
 * of the return value and must free it or transfer ownership via
 * JS_NewArrayBufferWithContents when done using it.
 */
    #[link_name =
          "_Z27JS_StealArrayBufferContentsP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_StealArrayBufferContents(cx: *mut JSContext, obj: HandleObject)
     -> *mut ::std::os::raw::c_void;
    /**
 * Create a new mapped array buffer with the given memory mapped contents. It
 * must be legal to free the contents pointer by unmapping it. On success,
 * ownership is transferred to the new mapped array buffer.
 */
    #[link_name = "_Z35JS_NewMappedArrayBufferWithContentsP9JSContextyPv"]
    pub fn JS_NewMappedArrayBufferWithContents(cx: *mut JSContext,
                                               nbytes: usize,
                                               contents:
                                                   *mut ::std::os::raw::c_void)
     -> *mut JSObject;
    /**
 * Create memory mapped array buffer contents.
 * Caller must take care of closing fd after calling this function.
 */
    #[link_name = "_Z34JS_CreateMappedArrayBufferContentsiyy"]
    pub fn JS_CreateMappedArrayBufferContents(fd: ::std::os::raw::c_int,
                                              offset: usize, length: usize)
     -> *mut ::std::os::raw::c_void;
    /**
 * Release the allocated resource of mapped array buffer contents before the
 * object is created.
 * If a new object has been created by JS_NewMappedArrayBufferWithContents()
 * with this content, then JS_DetachArrayBuffer() should be used instead to
 * release the resource used by the object.
 */
    #[link_name = "_Z35JS_ReleaseMappedArrayBufferContentsPvy"]
    pub fn JS_ReleaseMappedArrayBufferContents(contents:
                                                   *mut ::std::os::raw::c_void,
                                               length: usize);
    #[link_name = "_Z18JS_GetReservedSlotP8JSObjectj"]
    pub fn JS_GetReservedSlot(obj: *mut JSObject, index: u32) -> Value;
    #[link_name = "_Z18JS_SetReservedSlotP8JSObjectjN2JS5ValueE"]
    pub fn JS_SetReservedSlot(obj: *mut JSObject, index: u32, v: Value);
    /************************************************************************/
    #[link_name = "_Z14JS_NewFunctionP9JSContextPFbS0_jPN2JS5ValueEEjjPKc"]
    pub fn JS_NewFunction(cx: *mut JSContext, call: JSNative,
                          nargs: ::std::os::raw::c_uint,
                          flags: ::std::os::raw::c_uint,
                          name: *const ::std::os::raw::c_char)
     -> *mut JSFunction;
    #[link_name =
          "_ZN2JS21GetSelfHostedFunctionEP9JSContextPKcNS_6HandleI4jsidEEj"]
    pub fn GetSelfHostedFunction(cx: *mut JSContext,
                                 selfHostedName:
                                     *const ::std::os::raw::c_char,
                                 id: HandleId, nargs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    /**
 * Create a new function based on the given JSFunctionSpec, *fs.
 * id is the result of a successful call to
 * `PropertySpecNameToPermanentId(cx, fs->name, &id)`.
 *
 * Unlike JS_DefineFunctions, this does not treat fs as an array.
 * *fs must not be JS_FS_END.
 */
    #[link_name =
          "_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpecNS_6HandleI4jsidEE"]
    pub fn NewFunctionFromSpec(cx: *mut JSContext, fs: *const JSFunctionSpec,
                               id: HandleId) -> *mut JSFunction;
    #[link_name = "_Z20JS_GetFunctionObjectP10JSFunction"]
    pub fn JS_GetFunctionObject(fun: *mut JSFunction) -> *mut JSObject;
    /**
 * Return the function's identifier as a JSString, or null if fun is unnamed.
 * The returned string lives as long as fun, so you don't need to root a saved
 * reference to it if fun is well-connected or rooted, and provided you bound
 * the use of the saved reference by fun's lifetime.
 */
    #[link_name = "_Z16JS_GetFunctionIdP10JSFunction"]
    pub fn JS_GetFunctionId(fun: *mut JSFunction) -> *mut JSString;
    /**
 * Return a function's display name. This is the defined name if one was given
 * where the function was defined, or it could be an inferred name by the JS
 * engine in the case that the function was defined to be anonymous. This can
 * still return nullptr if a useful display name could not be inferred. The
 * same restrictions on rooting as those in JS_GetFunctionId apply.
 */
    #[link_name = "_Z23JS_GetFunctionDisplayIdP10JSFunction"]
    pub fn JS_GetFunctionDisplayId(fun: *mut JSFunction) -> *mut JSString;
    #[link_name = "_Z19JS_GetFunctionArityP10JSFunction"]
    pub fn JS_GetFunctionArity(fun: *mut JSFunction) -> u16;
    /**
 * Infallible predicate to test whether obj is a function object (faster than
 * comparing obj's class name to "Function", but equivalent unless someone has
 * overwritten the "Function" identifier with a different constructor and then
 * created instances using that constructor that might be passed in as obj).
 */
    #[link_name = "_Z19JS_ObjectIsFunctionP9JSContextP8JSObject"]
    pub fn JS_ObjectIsFunction(cx: *mut JSContext, obj: *mut JSObject)
     -> bool;
    #[link_name =
          "_Z19JS_IsNativeFunctionP8JSObjectPFbP9JSContextjPN2JS5ValueEE"]
    pub fn JS_IsNativeFunction(funobj: *mut JSObject, call: JSNative) -> bool;
    /** Return whether the given function is a valid constructor. */
    #[link_name = "_Z16JS_IsConstructorP10JSFunction"]
    pub fn JS_IsConstructor(fun: *mut JSFunction) -> bool;
    #[link_name =
          "_Z18JS_DefineFunctionsP9JSContextN2JS6HandleIP8JSObjectEEPK14JSFunctionSpec"]
    pub fn JS_DefineFunctions(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                              fs: *const JSFunctionSpec) -> bool;
    #[link_name =
          "_Z17JS_DefineFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEEjj"]
    pub fn JS_DefineFunction(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                             name: *const ::std::os::raw::c_char,
                             call: JSNative, nargs: ::std::os::raw::c_uint,
                             attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    #[link_name =
          "_Z19JS_DefineUCFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKDsyPFbS0_jPNS1_5ValueEEjj"]
    pub fn JS_DefineUCFunction(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                               name: *const ::std::os::raw::c_ushort,
                               namelen: usize, call: JSNative,
                               nargs: ::std::os::raw::c_uint,
                               attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    #[link_name =
          "_Z21JS_DefineFunctionByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_I4jsidEEPFbS0_jPNS1_5ValueEEjj"]
    pub fn JS_DefineFunctionById(cx: *mut JSContext,
                                 obj: Handle<*mut JSObject>, id: Handle<jsid>,
                                 call: JSNative,
                                 nargs: ::std::os::raw::c_uint,
                                 attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    /**
 * Clone a top-level function into cx's global. This function will dynamically
 * fail if funobj was lexically nested inside some other function.
 */
    #[link_name =
          "_ZN2JS19CloneFunctionObjectEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn CloneFunctionObject(cx: *mut JSContext, funobj: HandleObject)
     -> *mut JSObject;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the clone's scope chain.
 */
    #[link_name =
          "_ZN2JS19CloneFunctionObjectEP9JSContextNS_6HandleIP8JSObjectEERNS_16AutoVectorRooterIS4_EE"]
    pub fn CloneFunctionObject1(cx: *mut JSContext, funobj: HandleObject,
                                scopeChain: *mut AutoObjectVector)
     -> *mut JSObject;
    /**
 * Given a buffer, return false if the buffer might become a valid
 * javascript statement with the addition of more lines.  Otherwise return
 * true.  The intent is to support interactive compilation - accumulate
 * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
 * the compiler.
 */
    #[link_name =
          "_Z25JS_BufferIsCompilableUnitP9JSContextN2JS6HandleIP8JSObjectEEPKcy"]
    pub fn JS_BufferIsCompilableUnit(cx: *mut JSContext,
                                     obj: Handle<*mut JSObject>,
                                     utf8: *const ::std::os::raw::c_char,
                                     length: usize) -> bool;
    /**
 * |script| will always be set. On failure, it will be set to nullptr.
 */
    #[link_name =
          "_Z16JS_CompileScriptP9JSContextPKcyRKN2JS14CompileOptionsENS3_13MutableHandleIP8JSScriptEE"]
    pub fn JS_CompileScript(cx: *mut JSContext,
                            ascii: *const ::std::os::raw::c_char,
                            length: usize, options: *const CompileOptions,
                            script: MutableHandleScript) -> bool;
    /**
 * |script| will always be set. On failure, it will be set to nullptr.
 */
    #[link_name =
          "_Z18JS_CompileUCScriptP9JSContextPKDsyRKN2JS14CompileOptionsENS3_13MutableHandleIP8JSScriptEE"]
    pub fn JS_CompileUCScript(cx: *mut JSContext,
                              chars: *const ::std::os::raw::c_ushort,
                              length: usize, options: *const CompileOptions,
                              script: MutableHandleScript) -> bool;
    #[link_name = "_Z22JS_GetGlobalFromScriptP8JSScript"]
    pub fn JS_GetGlobalFromScript(script: *mut JSScript) -> *mut JSObject;
    #[link_name = "_Z20JS_GetScriptFilenameP8JSScript"]
    pub fn JS_GetScriptFilename(script: *mut JSScript)
     -> *const ::std::os::raw::c_char;
    #[link_name = "_Z26JS_GetScriptBaseLineNumberP9JSContextP8JSScript"]
    pub fn JS_GetScriptBaseLineNumber(cx: *mut JSContext,
                                      script: *mut JSScript)
     -> ::std::os::raw::c_uint;
    #[link_name =
          "_Z20JS_GetFunctionScriptP9JSContextN2JS6HandleIP10JSFunctionEE"]
    pub fn JS_GetFunctionScript(cx: *mut JSContext, fun: HandleFunction)
     -> *mut JSScript;
    /**
 * |script| will always be set. On failure, it will be set to nullptr.
 */
    #[link_name =
          "_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_18SourceBufferHolderENS_13MutableHandleIP8JSScriptEE"]
    pub fn Compile(cx: *mut JSContext, options: *const ReadOnlyCompileOptions,
                   srcBuf: *mut SourceBufferHolder,
                   script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcyNS_13MutableHandleIP8JSScriptEE"]
    pub fn Compile1(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    bytes: *const ::std::os::raw::c_char, length: usize,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKDsyNS_13MutableHandleIP8JSScriptEE"]
    pub fn Compile2(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    chars: *const ::std::os::raw::c_ushort, length: usize,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsEP6_iobufNS_13MutableHandleIP8JSScriptEE"]
    pub fn Compile3(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions, file: *mut FILE,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleIP8JSScriptEE"]
    pub fn Compile4(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    filename: *const ::std::os::raw::c_char,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_18SourceBufferHolderENS_13MutableHandleIP8JSScriptEE"]
    pub fn CompileForNonSyntacticScope(cx: *mut JSContext,
                                       options: *const ReadOnlyCompileOptions,
                                       srcBuf: *mut SourceBufferHolder,
                                       script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcyNS_13MutableHandleIP8JSScriptEE"]
    pub fn CompileForNonSyntacticScope1(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        bytes: *const ::std::os::raw::c_char,
                                        length: usize,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKDsyNS_13MutableHandleIP8JSScriptEE"]
    pub fn CompileForNonSyntacticScope2(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        chars:
                                            *const ::std::os::raw::c_ushort,
                                        length: usize,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsEP6_iobufNS_13MutableHandleIP8JSScriptEE"]
    pub fn CompileForNonSyntacticScope3(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        file: *mut FILE,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleIP8JSScriptEE"]
    pub fn CompileForNonSyntacticScope4(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        filename:
                                            *const ::std::os::raw::c_char,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "_ZN2JS19CanCompileOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEy"]
    pub fn CanCompileOffThread(cx: *mut JSContext,
                               options: *const ReadOnlyCompileOptions,
                               length: usize) -> bool;
    #[link_name =
          "_ZN2JS16CompileOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKDsyPFvPvS7_ES7_"]
    pub fn CompileOffThread(cx: *mut JSContext,
                            options: *const ReadOnlyCompileOptions,
                            chars: *const ::std::os::raw::c_ushort,
                            length: usize, callback: OffThreadCompileCallback,
                            callbackData: *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name = "_ZN2JS21FinishOffThreadScriptEP9JSContextP9JSRuntimePv"]
    pub fn FinishOffThreadScript(maybecx: *mut JSContext, rt: *mut JSRuntime,
                                 token: *mut ::std::os::raw::c_void)
     -> *mut JSScript;
    #[link_name =
          "_ZN2JS22CompileOffThreadModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKDsyPFvPvS7_ES7_"]
    pub fn CompileOffThreadModule(cx: *mut JSContext,
                                  options: *const ReadOnlyCompileOptions,
                                  chars: *const ::std::os::raw::c_ushort,
                                  length: usize,
                                  callback: OffThreadCompileCallback,
                                  callbackData: *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name = "_ZN2JS21FinishOffThreadModuleEP9JSContextP9JSRuntimePv"]
    pub fn FinishOffThreadModule(maybecx: *mut JSContext, rt: *mut JSRuntime,
                                 token: *mut ::std::os::raw::c_void)
     -> *mut JSObject;
    /**
 * Compile a function with scopeChain plus the global as its scope chain.
 * scopeChain must contain objects in the current compartment of cx.  The actual
 * scope chain used for the function will consist of With wrappers for those
 * objects, followed by the current global of the compartment cx is in.  This
 * global must not be explicitly included in the scope chain.
 */
    #[link_name =
          "_ZN2JS15CompileFunctionEP9JSContextRNS_16AutoVectorRooterIP8JSObjectEERKNS_22ReadOnlyCompileOptionsEPKcjPKSB_PKDsyNS_13MutableHandleIP10JSFunctionEE"]
    pub fn CompileFunction(cx: *mut JSContext,
                           scopeChain: *mut AutoObjectVector,
                           options: *const ReadOnlyCompileOptions,
                           name: *const ::std::os::raw::c_char,
                           nargs: ::std::os::raw::c_uint,
                           argnames: *const *const ::std::os::raw::c_char,
                           chars: *const ::std::os::raw::c_ushort,
                           length: usize, fun: MutableHandleFunction) -> bool;
    /**
 * Same as above, but taking a SourceBufferHolder for the function body.
 */
    #[link_name =
          "_ZN2JS15CompileFunctionEP9JSContextRNS_16AutoVectorRooterIP8JSObjectEERKNS_22ReadOnlyCompileOptionsEPKcjPKSB_RNS_18SourceBufferHolderENS_13MutableHandleIP10JSFunctionEE"]
    pub fn CompileFunction1(cx: *mut JSContext,
                            scopeChain: *mut AutoObjectVector,
                            options: *const ReadOnlyCompileOptions,
                            name: *const ::std::os::raw::c_char,
                            nargs: ::std::os::raw::c_uint,
                            argnames: *const *const ::std::os::raw::c_char,
                            srcBuf: *mut SourceBufferHolder,
                            fun: MutableHandleFunction) -> bool;
    /**
 * Same as above, but taking a const char * for the function body.
 */
    #[link_name =
          "_ZN2JS15CompileFunctionEP9JSContextRNS_16AutoVectorRooterIP8JSObjectEERKNS_22ReadOnlyCompileOptionsEPKcjPKSB_SB_yNS_13MutableHandleIP10JSFunctionEE"]
    pub fn CompileFunction2(cx: *mut JSContext,
                            scopeChain: *mut AutoObjectVector,
                            options: *const ReadOnlyCompileOptions,
                            name: *const ::std::os::raw::c_char,
                            nargs: ::std::os::raw::c_uint,
                            argnames: *const *const ::std::os::raw::c_char,
                            bytes: *const ::std::os::raw::c_char,
                            length: usize, fun: MutableHandleFunction)
     -> bool;
    #[link_name =
          "_Z18JS_DecompileScriptP9JSContextN2JS6HandleIP8JSScriptEEPKcj"]
    pub fn JS_DecompileScript(cx: *mut JSContext,
                              script: Handle<*mut JSScript>,
                              name: *const ::std::os::raw::c_char,
                              indent: ::std::os::raw::c_uint)
     -> *mut JSString;
    #[link_name =
          "_Z20JS_DecompileFunctionP9JSContextN2JS6HandleIP10JSFunctionEEj"]
    pub fn JS_DecompileFunction(cx: *mut JSContext,
                                fun: Handle<*mut JSFunction>,
                                indent: ::std::os::raw::c_uint)
     -> *mut JSString;
    /**
 * Evaluate a script in the scope of the current global of cx.
 */
    #[link_name =
          "_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ExecuteScript(cx: *mut JSContext, script: HandleScript,
                            rval: MutableHandleValue) -> bool;
    #[link_name = "_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
    pub fn JS_ExecuteScript1(cx: *mut JSContext, script: HandleScript)
     -> bool;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the script's scope chain.
 */
    #[link_name =
          "_Z16JS_ExecuteScriptP9JSContextRN2JS16AutoVectorRooterIP8JSObjectEENS1_6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ExecuteScript2(cx: *mut JSContext,
                             scopeChain: *mut AutoObjectVector,
                             script: HandleScript, rval: MutableHandleValue)
     -> bool;
    #[link_name =
          "_Z16JS_ExecuteScriptP9JSContextRN2JS16AutoVectorRooterIP8JSObjectEENS1_6HandleIP8JSScriptEE"]
    pub fn JS_ExecuteScript3(cx: *mut JSContext,
                             scopeChain: *mut AutoObjectVector,
                             script: HandleScript) -> bool;
    /**
 * Like the above, but handles a cross-compartment script. If the script is
 * cross-compartment, it is cloned into the current compartment before executing.
 */
    #[link_name =
          "_ZN2JS21CloneAndExecuteScriptEP9JSContextNS_6HandleIP8JSScriptEE"]
    pub fn CloneAndExecuteScript(cx: *mut JSContext,
                                 script: Handle<*mut JSScript>) -> bool;
    /**
 * Evaluate the given source buffer in the scope of the current global of cx.
 */
    #[link_name =
          "_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_18SourceBufferHolderENS_13MutableHandleINS_5ValueEEE"]
    pub fn Evaluate(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    srcBuf: *mut SourceBufferHolder, rval: MutableHandleValue)
     -> bool;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the script's scope chain.
 */
    #[link_name =
          "_ZN2JS8EvaluateEP9JSContextRNS_16AutoVectorRooterIP8JSObjectEERKNS_22ReadOnlyCompileOptionsERNS_18SourceBufferHolderENS_13MutableHandleINS_5ValueEEE"]
    pub fn Evaluate1(cx: *mut JSContext, scopeChain: *mut AutoObjectVector,
                     options: *const ReadOnlyCompileOptions,
                     srcBuf: *mut SourceBufferHolder,
                     rval: MutableHandleValue) -> bool;
    /**
 * Evaluate the given character buffer in the scope of the current global of cx.
 */
    #[link_name =
          "_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKDsyNS_13MutableHandleINS_5ValueEEE"]
    pub fn Evaluate2(cx: *mut JSContext,
                     options: *const ReadOnlyCompileOptions,
                     chars: *const ::std::os::raw::c_ushort, length: usize,
                     rval: MutableHandleValue) -> bool;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the script's scope chain.
 */
    #[link_name =
          "_ZN2JS8EvaluateEP9JSContextRNS_16AutoVectorRooterIP8JSObjectEERKNS_22ReadOnlyCompileOptionsEPKDsyNS_13MutableHandleINS_5ValueEEE"]
    pub fn Evaluate3(cx: *mut JSContext, scopeChain: *mut AutoObjectVector,
                     options: *const ReadOnlyCompileOptions,
                     chars: *const ::std::os::raw::c_ushort, length: usize,
                     rval: MutableHandleValue) -> bool;
    /**
 * Evaluate the given byte buffer in the scope of the current global of cx.
 */
    #[link_name =
          "_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcyNS_13MutableHandleINS_5ValueEEE"]
    pub fn Evaluate4(cx: *mut JSContext,
                     options: *const ReadOnlyCompileOptions,
                     bytes: *const ::std::os::raw::c_char, length: usize,
                     rval: MutableHandleValue) -> bool;
    /**
 * Evaluate the given file in the scope of the current global of cx.
 */
    #[link_name =
          "_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleINS_5ValueEEE"]
    pub fn Evaluate5(cx: *mut JSContext,
                     options: *const ReadOnlyCompileOptions,
                     filename: *const ::std::os::raw::c_char,
                     rval: MutableHandleValue) -> bool;
    /**
 * Get the HostResolveImportedModule hook for a global.
 */
    #[link_name = "_ZN2JS20GetModuleResolveHookEP9JSContext"]
    pub fn GetModuleResolveHook(cx: *mut JSContext) -> *mut JSFunction;
    /**
 * Set the HostResolveImportedModule hook for a global to the given function.
 */
    #[link_name =
          "_ZN2JS20SetModuleResolveHookEP9JSContextNS_6HandleIP10JSFunctionEE"]
    pub fn SetModuleResolveHook(cx: *mut JSContext, func: HandleFunction);
    /**
 * Parse the given source buffer as a module in the scope of the current global
 * of cx and return a source text module record.
 */
    #[link_name =
          "_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_18SourceBufferHolderENS_13MutableHandleIP8JSObjectEE"]
    pub fn CompileModule(cx: *mut JSContext,
                         options: *const ReadOnlyCompileOptions,
                         srcBuf: *mut SourceBufferHolder,
                         moduleRecord: MutableHandleObject) -> bool;
    /**
 * Set the [[HostDefined]] field of a source text module record to the given
 * value.
 */
    #[link_name = "_ZN2JS25SetModuleHostDefinedFieldEP8JSObjectNS_5ValueE"]
    pub fn SetModuleHostDefinedField(module: *mut JSObject, value: Value);
    /**
 * Get the [[HostDefined]] field of a source text module record.
 */
    #[link_name = "_ZN2JS25GetModuleHostDefinedFieldEP8JSObject"]
    pub fn GetModuleHostDefinedField(module: *mut JSObject) -> Value;
    #[link_name =
          "_ZN2JS30ModuleDeclarationInstantiationEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn ModuleDeclarationInstantiation(cx: *mut JSContext,
                                          moduleRecord: HandleObject) -> bool;
    #[link_name =
          "_ZN2JS16ModuleEvaluationEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn ModuleEvaluation(cx: *mut JSContext, moduleRecord: HandleObject)
     -> bool;
    #[link_name =
          "_ZN2JS19GetRequestedModulesEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn GetRequestedModules(cx: *mut JSContext, moduleRecord: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_ZN2JS15GetModuleScriptEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn GetModuleScript(cx: *mut JSContext, moduleRecord: HandleObject)
     -> *mut JSScript;
    #[link_name = "_Z20JS_CheckForInterruptP9JSContext"]
    pub fn JS_CheckForInterrupt(cx: *mut JSContext) -> bool;
    #[link_name = "_Z23JS_SetInterruptCallbackP9JSRuntimePFbP9JSContextE"]
    pub fn JS_SetInterruptCallback(rt: *mut JSRuntime,
                                   callback: JSInterruptCallback)
     -> JSInterruptCallback;
    #[link_name = "_Z23JS_GetInterruptCallbackP9JSRuntime"]
    pub fn JS_GetInterruptCallback(rt: *mut JSRuntime) -> JSInterruptCallback;
    #[link_name = "_Z27JS_RequestInterruptCallbackP9JSRuntime"]
    pub fn JS_RequestInterruptCallback(rt: *mut JSRuntime);
    /**
 * Sets the callback that's invoked whenever a Promise job should be enqeued.
 *
 * SpiderMonkey doesn't schedule Promise resolution jobs itself; instead,
 * using this function the embedding can provide a callback to do that
 * scheduling. The provided `callback` is invoked with the promise job,
 * the corresponding Promise's allocation stack, and the `data` pointer
 * passed here as arguments.
 */
    #[link_name =
          "_ZN2JS28SetEnqueuePromiseJobCallbackEP9JSRuntimePFbP9JSContextNS_6HandleIP8JSObjectEES7_PvES8_"]
    pub fn SetEnqueuePromiseJobCallback(rt: *mut JSRuntime,
                                        callback: JSEnqueuePromiseJobCallback,
                                        data: *mut ::std::os::raw::c_void);
    /**
 * Sets the callback that's invoked whenever a Promise is rejected without
 * a rejection handler, and when a Promise that was previously rejected
 * without a handler gets a handler attached.
 */
    #[link_name =
          "_ZN2JS34SetPromiseRejectionTrackerCallbackEP9JSRuntimePFvP9JSContextNS_6HandleIP8JSObjectEE29PromiseRejectionHandlingStatePvES9_"]
    pub fn SetPromiseRejectionTrackerCallback(rt: *mut JSRuntime,
                                              callback:
                                                  JSPromiseRejectionTrackerCallback,
                                              data:
                                                  *mut ::std::os::raw::c_void);
    /**
 * Returns a new instance of the Promise builtin class in the current
 * compartment, with the right slot layout. If a `proto` is passed, that gets
 * set as the instance's [[Prototype]] instead of the original value of
 * `Promise.prototype`.
 */
    #[link_name =
          "_ZN2JS16NewPromiseObjectEP9JSContextNS_6HandleIP8JSObjectEES5_"]
    pub fn NewPromiseObject(cx: *mut JSContext, executor: HandleObject,
                            proto: HandleObject) -> *mut JSObject;
    /**
 * Returns true if the given object is an unwrapped PromiseObject, false
 * otherwise.
 */
    #[link_name = "_ZN2JS15IsPromiseObjectENS_6HandleIP8JSObjectEE"]
    pub fn IsPromiseObject(obj: HandleObject) -> bool;
    /**
 * Returns the current compartment's original Promise constructor.
 */
    #[link_name = "_ZN2JS21GetPromiseConstructorEP9JSContext"]
    pub fn GetPromiseConstructor(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Returns the current compartment's original Promise.prototype.
 */
    #[link_name = "_ZN2JS19GetPromisePrototypeEP9JSContext"]
    pub fn GetPromisePrototype(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Returns the given Promise's state as a JS::PromiseState enum value.
 */
    #[link_name = "_ZN2JS15GetPromiseStateENS_6HandleIP8JSObjectEE"]
    pub fn GetPromiseState(promise: HandleObject) -> PromiseState;
    /**
 * Returns the given Promise's process-unique ID.
 */
    #[link_name = "_ZN2JS12GetPromiseIDENS_6HandleIP8JSObjectEE"]
    pub fn GetPromiseID(promise: HandleObject) -> u64;
    /**
 * Returns the given Promise's result: either the resolution value for
 * fulfilled promises, or the rejection reason for rejected ones.
 */
    #[link_name = "_ZN2JS16GetPromiseResultENS_6HandleIP8JSObjectEE"]
    pub fn GetPromiseResult(promise: HandleObject) -> Value;
    /**
 * Returns a js::SavedFrame linked list of the stack that lead to the given
 * Promise's allocation.
 */
    #[link_name = "_ZN2JS24GetPromiseAllocationSiteENS_6HandleIP8JSObjectEE"]
    pub fn GetPromiseAllocationSite(promise: HandleObject) -> *mut JSObject;
    #[link_name = "_ZN2JS24GetPromiseResolutionSiteENS_6HandleIP8JSObjectEE"]
    pub fn GetPromiseResolutionSite(promise: HandleObject) -> *mut JSObject;
    /**
 * Calls the current compartment's original Promise.resolve on the original
 * Promise constructor, with `resolutionValue` passed as an argument.
 */
    #[link_name =
          "_ZN2JS26CallOriginalPromiseResolveEP9JSContextNS_6HandleINS_5ValueEEE"]
    pub fn CallOriginalPromiseResolve(cx: *mut JSContext,
                                      resolutionValue: HandleValue)
     -> *mut JSObject;
    /**
 * Calls the current compartment's original Promise.reject on the original
 * Promise constructor, with `resolutionValue` passed as an argument.
 */
    #[link_name =
          "_ZN2JS25CallOriginalPromiseRejectEP9JSContextNS_6HandleINS_5ValueEEE"]
    pub fn CallOriginalPromiseReject(cx: *mut JSContext,
                                     rejectionValue: HandleValue)
     -> *mut JSObject;
    /**
 * Resolves the given Promise with the given `resolutionValue`.
 *
 * Calls the `resolve` function that was passed to the executor function when
 * the Promise was created.
 */
    #[link_name =
          "_ZN2JS14ResolvePromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
    pub fn ResolvePromise(cx: *mut JSContext, promise: HandleObject,
                          resolutionValue: HandleValue) -> bool;
    /**
 * Rejects the given `promise` with the given `rejectionValue`.
 *
 * Calls the `reject` function that was passed to the executor function when
 * the Promise was created.
 */
    #[link_name =
          "_ZN2JS13RejectPromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
    pub fn RejectPromise(cx: *mut JSContext, promise: HandleObject,
                         rejectionValue: HandleValue) -> bool;
    /**
 * Calls the current compartment's original Promise.prototype.then on the
 * given `promise`, with `onResolve` and `onReject` passed as arguments.
 *
 * Asserts if the passed-in `promise` object isn't an unwrapped instance of
 * `Promise` or a subclass or `onResolve` and `onReject` aren't both either
 * `nullptr` or callable objects.
 */
    #[link_name =
          "_ZN2JS23CallOriginalPromiseThenEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
    pub fn CallOriginalPromiseThen(cx: *mut JSContext, promise: HandleObject,
                                   onResolve: HandleObject,
                                   onReject: HandleObject) -> *mut JSObject;
    /**
 * Unforgeable, optimized version of the JS builtin Promise.prototype.then.
 *
 * Takes a Promise instance and `onResolve`, `onReject` callables to enqueue
 * as reactions for that promise. In difference to Promise.prototype.then,
 * this doesn't create and return a new Promise instance.
 *
 * Asserts if the passed-in `promise` object isn't an unwrapped instance of
 * `Promise` or a subclass or `onResolve` and `onReject` aren't both callable
 * objects.
 */
    #[link_name =
          "_ZN2JS19AddPromiseReactionsEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
    pub fn AddPromiseReactions(cx: *mut JSContext, promise: HandleObject,
                               onResolve: HandleObject,
                               onReject: HandleObject) -> bool;
    /**
 * Unforgeable version of the JS builtin Promise.all.
 *
 * Takes an AutoObjectVector of Promise objects and returns a promise that's
 * resolved with an array of resolution values when all those promises ahve
 * been resolved, or rejected with the rejection value of the first rejected
 * promise.
 *
 * Asserts if the array isn't dense or one of the entries isn't an unwrapped
 * instance of Promise or a subclass.
 */
    #[link_name =
          "_ZN2JS20GetWaitForAllPromiseEP9JSContextRKNS_16AutoVectorRooterIP8JSObjectEE"]
    pub fn GetWaitForAllPromise(cx: *mut JSContext,
                                promises: *const AutoObjectVector)
     -> *mut JSObject;
    #[link_name = "_Z12JS_IsRunningP9JSContext"]
    pub fn JS_IsRunning(cx: *mut JSContext) -> bool;
    #[link_name = "_Z17JS_NewStringCopyNP9JSContextPKcy"]
    pub fn JS_NewStringCopyN(cx: *mut JSContext,
                             s: *const ::std::os::raw::c_char, n: usize)
     -> *mut JSString;
    #[link_name = "_Z17JS_NewStringCopyZP9JSContextPKc"]
    pub fn JS_NewStringCopyZ(cx: *mut JSContext,
                             s: *const ::std::os::raw::c_char)
     -> *mut JSString;
    #[link_name =
          "_Z24JS_AtomizeAndPinJSStringP9JSContextN2JS6HandleIP8JSStringEE"]
    pub fn JS_AtomizeAndPinJSString(cx: *mut JSContext, str: HandleString)
     -> *mut JSString;
    #[link_name = "_Z17JS_AtomizeStringNP9JSContextPKcy"]
    pub fn JS_AtomizeStringN(cx: *mut JSContext,
                             s: *const ::std::os::raw::c_char, length: usize)
     -> *mut JSString;
    #[link_name = "_Z16JS_AtomizeStringP9JSContextPKc"]
    pub fn JS_AtomizeString(cx: *mut JSContext,
                            s: *const ::std::os::raw::c_char)
     -> *mut JSString;
    #[link_name = "_Z23JS_AtomizeAndPinStringNP9JSContextPKcy"]
    pub fn JS_AtomizeAndPinStringN(cx: *mut JSContext,
                                   s: *const ::std::os::raw::c_char,
                                   length: usize) -> *mut JSString;
    #[link_name = "_Z22JS_AtomizeAndPinStringP9JSContextPKc"]
    pub fn JS_AtomizeAndPinString(cx: *mut JSContext,
                                  s: *const ::std::os::raw::c_char)
     -> *mut JSString;
    #[link_name = "_Z14JS_NewUCStringP9JSContextPDsy"]
    pub fn JS_NewUCString(cx: *mut JSContext,
                          chars: *mut ::std::os::raw::c_ushort, length: usize)
     -> *mut JSString;
    #[link_name = "_Z19JS_NewUCStringCopyNP9JSContextPKDsy"]
    pub fn JS_NewUCStringCopyN(cx: *mut JSContext,
                               s: *const ::std::os::raw::c_ushort, n: usize)
     -> *mut JSString;
    #[link_name = "_Z19JS_NewUCStringCopyZP9JSContextPKDs"]
    pub fn JS_NewUCStringCopyZ(cx: *mut JSContext,
                               s: *const ::std::os::raw::c_ushort)
     -> *mut JSString;
    #[link_name = "_Z19JS_AtomizeUCStringNP9JSContextPKDsy"]
    pub fn JS_AtomizeUCStringN(cx: *mut JSContext,
                               s: *const ::std::os::raw::c_ushort,
                               length: usize) -> *mut JSString;
    #[link_name = "_Z18JS_AtomizeUCStringP9JSContextPKDs"]
    pub fn JS_AtomizeUCString(cx: *mut JSContext,
                              s: *const ::std::os::raw::c_ushort)
     -> *mut JSString;
    #[link_name = "_Z25JS_AtomizeAndPinUCStringNP9JSContextPKDsy"]
    pub fn JS_AtomizeAndPinUCStringN(cx: *mut JSContext,
                                     s: *const ::std::os::raw::c_ushort,
                                     length: usize) -> *mut JSString;
    #[link_name = "_Z24JS_AtomizeAndPinUCStringP9JSContextPKDs"]
    pub fn JS_AtomizeAndPinUCString(cx: *mut JSContext,
                                    s: *const ::std::os::raw::c_ushort)
     -> *mut JSString;
    #[link_name = "_Z17JS_CompareStringsP9JSContextP8JSStringS2_Pi"]
    pub fn JS_CompareStrings(cx: *mut JSContext, str1: *mut JSString,
                             str2: *mut JSString, result: *mut i32) -> bool;
    #[link_name = "_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcPb"]
    pub fn JS_StringEqualsAscii(cx: *mut JSContext, str: *mut JSString,
                                asciiBytes: *const ::std::os::raw::c_char,
                                match_: *mut bool) -> bool;
    #[link_name = "_Z19JS_PutEscapedStringP9JSContextPcyP8JSStringc"]
    pub fn JS_PutEscapedString(cx: *mut JSContext,
                               buffer: *mut ::std::os::raw::c_char,
                               size: usize, str: *mut JSString,
                               quote: ::std::os::raw::c_char) -> usize;
    #[link_name = "_Z20JS_FileEscapedStringP6_iobufP8JSStringc"]
    pub fn JS_FileEscapedString(fp: *mut FILE, str: *mut JSString,
                                quote: ::std::os::raw::c_char) -> bool;
    #[link_name = "_Z18JS_GetStringLengthP8JSString"]
    pub fn JS_GetStringLength(str: *mut JSString) -> usize;
    #[link_name = "_Z15JS_StringIsFlatP8JSString"]
    pub fn JS_StringIsFlat(str: *mut JSString) -> bool;
    /** Returns true iff the string's characters are stored as Latin1. */
    #[link_name = "_Z23JS_StringHasLatin1CharsP8JSString"]
    pub fn JS_StringHasLatin1Chars(str: *mut JSString) -> bool;
    #[link_name =
          "_Z32JS_GetLatin1StringCharsAndLengthP9JSContextRKN2JS17AutoCheckCannotGCEP8JSStringPy"]
    pub fn JS_GetLatin1StringCharsAndLength(cx: *mut JSContext,
                                            nogc: *const AutoCheckCannotGC,
                                            str: *mut JSString,
                                            length: *mut usize)
     -> *const Latin1Char;
    #[link_name =
          "_Z33JS_GetTwoByteStringCharsAndLengthP9JSContextRKN2JS17AutoCheckCannotGCEP8JSStringPy"]
    pub fn JS_GetTwoByteStringCharsAndLength(cx: *mut JSContext,
                                             nogc: *const AutoCheckCannotGC,
                                             str: *mut JSString,
                                             length: *mut usize)
     -> *const ::std::os::raw::c_ushort;
    #[link_name = "_Z18JS_GetStringCharAtP9JSContextP8JSStringyPDs"]
    pub fn JS_GetStringCharAt(cx: *mut JSContext, str: *mut JSString,
                              index: usize,
                              res: *mut ::std::os::raw::c_ushort) -> bool;
    #[link_name = "_Z22JS_GetFlatStringCharAtP12JSFlatStringy"]
    pub fn JS_GetFlatStringCharAt(str: *mut JSFlatString, index: usize)
     -> ::std::os::raw::c_ushort;
    #[link_name = "_Z32JS_GetTwoByteExternalStringCharsP8JSString"]
    pub fn JS_GetTwoByteExternalStringChars(str: *mut JSString)
     -> *const ::std::os::raw::c_ushort;
    #[link_name =
          "_Z18JS_CopyStringCharsP9JSContextN7mozilla5RangeIDsEEP8JSString"]
    pub fn JS_CopyStringChars(cx: *mut JSContext,
                              dest: Range<::std::os::raw::c_ushort>,
                              str: *mut JSString) -> bool;
    #[link_name = "_Z16JS_FlattenStringP9JSContextP8JSString"]
    pub fn JS_FlattenString(cx: *mut JSContext, str: *mut JSString)
     -> *mut JSFlatString;
    #[link_name =
          "_Z27JS_GetLatin1FlatStringCharsRKN2JS17AutoCheckCannotGCEP12JSFlatString"]
    pub fn JS_GetLatin1FlatStringChars(nogc: *const AutoCheckCannotGC,
                                       str: *mut JSFlatString)
     -> *const Latin1Char;
    #[link_name =
          "_Z28JS_GetTwoByteFlatStringCharsRKN2JS17AutoCheckCannotGCEP12JSFlatString"]
    pub fn JS_GetTwoByteFlatStringChars(nogc: *const AutoCheckCannotGC,
                                        str: *mut JSFlatString)
     -> *const ::std::os::raw::c_ushort;
    #[link_name = "_Z24JS_FlatStringEqualsAsciiP12JSFlatStringPKc"]
    pub fn JS_FlatStringEqualsAscii(str: *mut JSFlatString,
                                    asciiBytes: *const ::std::os::raw::c_char)
     -> bool;
    #[link_name = "_Z23JS_PutEscapedFlatStringPcyP12JSFlatStringc"]
    pub fn JS_PutEscapedFlatString(buffer: *mut ::std::os::raw::c_char,
                                   size: usize, str: *mut JSFlatString,
                                   quote: ::std::os::raw::c_char) -> usize;
    /**
 * Create a dependent string, i.e., a string that owns no character storage,
 * but that refers to a slice of another string's chars.  Dependent strings
 * are mutable by definition, so the thread safety comments above apply.
 */
    #[link_name =
          "_Z21JS_NewDependentStringP9JSContextN2JS6HandleIP8JSStringEEyy"]
    pub fn JS_NewDependentString(cx: *mut JSContext, str: HandleString,
                                 start: usize, length: usize)
     -> *mut JSString;
    /**
 * Concatenate two strings, possibly resulting in a rope.
 * See above for thread safety comments.
 */
    #[link_name =
          "_Z16JS_ConcatStringsP9JSContextN2JS6HandleIP8JSStringEES5_"]
    pub fn JS_ConcatStrings(cx: *mut JSContext, left: HandleString,
                            right: HandleString) -> *mut JSString;
    /**
 * For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before
 * the call; on return, *dstlenp contains the number of characters actually
 * stored. To determine the necessary destination buffer size, make a sizing
 * call that passes nullptr for dst.
 *
 * On errors, the functions report the error. In that case, *dstlenp contains
 * the number of characters or bytes transferred so far.  If cx is nullptr, no
 * error is reported on failure, and the functions simply return false.
 *
 * NB: This function does not store an additional zero byte or char16_t after the
 * transcoded string.
 */
    #[link_name = "_Z14JS_DecodeBytesP9JSContextPKcyPDsPy"]
    pub fn JS_DecodeBytes(cx: *mut JSContext,
                          src: *const ::std::os::raw::c_char, srclen: usize,
                          dst: *mut ::std::os::raw::c_ushort,
                          dstlenp: *mut usize) -> bool;
    /**
 * A variation on JS_EncodeCharacters where a null terminated string is
 * returned that you are expected to call JS_free on when done.
 */
    #[link_name = "_Z15JS_EncodeStringP9JSContextP8JSString"]
    pub fn JS_EncodeString(cx: *mut JSContext, str: *mut JSString)
     -> *mut ::std::os::raw::c_char;
    /**
 * Same behavior as JS_EncodeString(), but encode into UTF-8 string
 */
    #[link_name =
          "_Z21JS_EncodeStringToUTF8P9JSContextN2JS6HandleIP8JSStringEE"]
    pub fn JS_EncodeStringToUTF8(cx: *mut JSContext, str: HandleString)
     -> *mut ::std::os::raw::c_char;
    /**
 * Get number of bytes in the string encoding (without accounting for a
 * terminating zero bytes. The function returns (size_t) -1 if the string
 * can not be encoded into bytes and reports an error using cx accordingly.
 */
    #[link_name = "_Z26JS_GetStringEncodingLengthP9JSContextP8JSString"]
    pub fn JS_GetStringEncodingLength(cx: *mut JSContext, str: *mut JSString)
     -> usize;
    /**
 * Encode string into a buffer. The function does not stores an additional
 * zero byte. The function returns (size_t) -1 if the string can not be
 * encoded into bytes with no error reported. Otherwise it returns the number
 * of bytes that are necessary to encode the string. If that exceeds the
 * length parameter, the string will be cut and only length bytes will be
 * written into the buffer.
 */
    #[link_name = "_Z23JS_EncodeStringToBufferP9JSContextP8JSStringPcy"]
    pub fn JS_EncodeStringToBuffer(cx: *mut JSContext, str: *mut JSString,
                                   buffer: *mut ::std::os::raw::c_char,
                                   length: usize) -> usize;
    #[link_name = "_ZN2JS10NewAddonIdEP9JSContextNS_6HandleIP8JSStringEE"]
    pub fn NewAddonId(cx: *mut JSContext, str: HandleString)
     -> *mut JSAddonId;
    #[link_name = "_ZN2JS15StringOfAddonIdEP9JSAddonId"]
    pub fn StringOfAddonId(id: *mut JSAddonId) -> *mut JSString;
    #[link_name = "_ZN2JS15AddonIdOfObjectEP8JSObject"]
    pub fn AddonIdOfObject(obj: *mut JSObject) -> *mut JSAddonId;
    /**
 * Create a new Symbol with the given description. This function never returns
 * a Symbol that is in the Runtime-wide symbol registry.
 *
 * If description is null, the new Symbol's [[Description]] attribute is
 * undefined.
 */
    #[link_name = "_ZN2JS9NewSymbolEP9JSContextNS_6HandleIP8JSStringEE"]
    pub fn NewSymbol(cx: *mut JSContext, description: HandleString)
     -> *mut Symbol;
    /**
 * Symbol.for as specified in ES6.
 *
 * Get a Symbol with the description 'key' from the Runtime-wide symbol registry.
 * If there is not already a Symbol with that description in the registry, a new
 * Symbol is created and registered. 'key' must not be null.
 */
    #[link_name = "_ZN2JS12GetSymbolForEP9JSContextNS_6HandleIP8JSStringEE"]
    pub fn GetSymbolFor(cx: *mut JSContext, key: HandleString) -> *mut Symbol;
    /**
 * Get the [[Description]] attribute of the given symbol.
 *
 * This function is infallible. If it returns null, that means the symbol's
 * [[Description]] is undefined.
 */
    #[link_name = "_ZN2JS20GetSymbolDescriptionENS_6HandleIPNS_6SymbolEEE"]
    pub fn GetSymbolDescription(symbol: HandleSymbol) -> *mut JSString;
    /**
 * Return the SymbolCode telling what sort of symbol `symbol` is.
 *
 * A symbol's SymbolCode never changes once it is created.
 */
    #[link_name = "_ZN2JS13GetSymbolCodeENS_6HandleIPNS_6SymbolEEE"]
    pub fn GetSymbolCode(symbol: Handle<*mut Symbol>) -> SymbolCode;
    /**
 * Get one of the well-known symbols defined by ES6. A single set of well-known
 * symbols is shared by all compartments in a JSRuntime.
 *
 * `which` must be in the range [0, WellKnownSymbolLimit).
 */
    #[link_name = "_ZN2JS18GetWellKnownSymbolEP9JSContextNS_10SymbolCodeE"]
    pub fn GetWellKnownSymbol(cx: *mut JSContext, which: SymbolCode)
     -> *mut Symbol;
    #[link_name = "_ZN2JS24PropertySpecNameEqualsIdEPKcNS_6HandleI4jsidEE"]
    pub fn PropertySpecNameEqualsId(name: *const ::std::os::raw::c_char,
                                    id: HandleId) -> bool;
    /**
 * Create a jsid that does not need to be marked for GC.
 *
 * 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The
 * resulting jsid, on success, is either an interned string or a well-known
 * symbol; either way it is immune to GC so there is no need to visit *idp
 * during GC marking.
 */
    #[link_name =
          "_ZN2JS29PropertySpecNameToPermanentIdEP9JSContextPKcP4jsid"]
    pub fn PropertySpecNameToPermanentId(cx: *mut JSContext,
                                         name: *const ::std::os::raw::c_char,
                                         idp: *mut jsid) -> bool;
    /**
 * JSON.stringify as specified by ES5.
 */
    #[link_name =
          "_Z12JS_StringifyP9JSContextN2JS13MutableHandleINS1_5ValueEEENS1_6HandleIP8JSObjectEENS5_IS3_EEPFbPKDsjPvESC_"]
    pub fn JS_Stringify(cx: *mut JSContext, value: MutableHandleValue,
                        replacer: HandleObject, space: HandleValue,
                        callback: JSONWriteCallback,
                        data: *mut ::std::os::raw::c_void) -> bool;
    /**
 * An API akin to JS_Stringify but with the goal of not having observable
 * side-effects when the stringification is performed.  This means it does not
 * allow a replacer or a custom space, and has the following constraints on its
 * input:
 *
 * 1) The input must be a plain object or array, not an abitrary value.
 * 2) Every value in the graph reached by the algorithm starting with this
 *    object must be one of the following: null, undefined, a string (NOT a
 *    string object!), a boolean, a finite number (i.e. no NaN or Infinity or
 *    -Infinity), a plain object with no accessor properties, or an Array with
 *    no holes.
 *
 * The actual behavior differs from JS_Stringify only in asserting the above and
 * NOT attempting to get the "toJSON" property from things, since that could
 * clearly have side-effects.
 */
    #[link_name =
          "_ZN2JS17ToJSONMaybeSafelyEP9JSContextNS_6HandleIP8JSObjectEEPFbPKDsjPvES8_"]
    pub fn ToJSONMaybeSafely(cx: *mut JSContext, input: HandleObject,
                             callback: JSONWriteCallback,
                             data: *mut ::std::os::raw::c_void) -> bool;
    /**
 * JSON.parse as specified by ES5.
 */
    #[link_name =
          "_Z12JS_ParseJSONP9JSContextPKDsjN2JS13MutableHandleINS3_5ValueEEE"]
    pub fn JS_ParseJSON(cx: *mut JSContext,
                        chars: *const ::std::os::raw::c_ushort, len: u32,
                        vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z12JS_ParseJSONP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ParseJSON1(cx: *mut JSContext, str: HandleString,
                         vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z23JS_ParseJSONWithReviverP9JSContextPKDsjN2JS6HandleINS3_5ValueEEENS3_13MutableHandleIS5_EE"]
    pub fn JS_ParseJSONWithReviver(cx: *mut JSContext,
                                   chars: *const ::std::os::raw::c_ushort,
                                   len: u32, reviver: HandleValue,
                                   vp: MutableHandleValue) -> bool;
    #[link_name =
          "_Z23JS_ParseJSONWithReviverP9JSContextN2JS6HandleIP8JSStringEENS2_INS1_5ValueEEENS1_13MutableHandleIS6_EE"]
    pub fn JS_ParseJSONWithReviver1(cx: *mut JSContext, str: HandleString,
                                    reviver: HandleValue,
                                    vp: MutableHandleValue) -> bool;
    /**
 * The default locale for the ECMAScript Internationalization API
 * (Intl.Collator, Intl.NumberFormat, Intl.DateTimeFormat).
 * Note that the Internationalization API encourages clients to
 * specify their own locales.
 * The locale string remains owned by the caller.
 */
    #[link_name = "_Z19JS_SetDefaultLocaleP9JSRuntimePKc"]
    pub fn JS_SetDefaultLocale(rt: *mut JSRuntime,
                               locale: *const ::std::os::raw::c_char) -> bool;
    /**
 * Reset the default locale to OS defaults.
 */
    #[link_name = "_Z21JS_ResetDefaultLocaleP9JSRuntime"]
    pub fn JS_ResetDefaultLocale(rt: *mut JSRuntime);
    /**
 * Establish locale callbacks. The pointer must persist as long as the
 * JSRuntime.  Passing nullptr restores the default behaviour.
 */
    #[link_name = "_Z21JS_SetLocaleCallbacksP9JSRuntimePK17JSLocaleCallbacks"]
    pub fn JS_SetLocaleCallbacks(rt: *mut JSRuntime,
                                 callbacks: *const JSLocaleCallbacks);
    /**
 * Return the address of the current locale callbacks struct, which may
 * be nullptr.
 */
    #[link_name = "_Z21JS_GetLocaleCallbacksP9JSRuntime"]
    pub fn JS_GetLocaleCallbacks(rt: *mut JSRuntime)
     -> *const JSLocaleCallbacks;
    /**
 * Report an exception represented by the sprintf-like conversion of format
 * and its arguments.
 */
    #[link_name = "_Z14JS_ReportErrorP9JSContextPKcz"]
    pub fn JS_ReportError(cx: *mut JSContext,
                          format: *const ::std::os::raw::c_char, ...);
    #[link_name =
          "_Z20JS_ReportErrorNumberP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
    pub fn JS_ReportErrorNumber(cx: *mut JSContext,
                                errorCallback: JSErrorCallback,
                                userRef: *mut ::std::os::raw::c_void,
                                errorNumber: ::std::os::raw::c_uint, ...);
    #[link_name =
          "_Z22JS_ReportErrorNumberUCP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
    pub fn JS_ReportErrorNumberUC(cx: *mut JSContext,
                                  errorCallback: JSErrorCallback,
                                  userRef: *mut ::std::os::raw::c_void,
                                  errorNumber: ::std::os::raw::c_uint, ...);
    #[link_name =
          "_Z27JS_ReportErrorNumberUCArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKDs"]
    pub fn JS_ReportErrorNumberUCArray(cx: *mut JSContext,
                                       errorCallback: JSErrorCallback,
                                       userRef: *mut ::std::os::raw::c_void,
                                       errorNumber: ::std::os::raw::c_uint,
                                       args:
                                           *mut *const ::std::os::raw::c_ushort);
    /**
 * As above, but report a warning instead (JSREPORT_IS_WARNING(report.flags)).
 * Return true if there was no error trying to issue the warning, and if the
 * warning was not converted into an error due to the JSOPTION_WERROR option
 * being set, false otherwise.
 */
    #[link_name = "_Z16JS_ReportWarningP9JSContextPKcz"]
    pub fn JS_ReportWarning(cx: *mut JSContext,
                            format: *const ::std::os::raw::c_char, ...)
     -> bool;
    #[link_name =
          "_Z28JS_ReportErrorFlagsAndNumberP9JSContextjPFPK19JSErrorFormatStringPvjES4_jz"]
    pub fn JS_ReportErrorFlagsAndNumber(cx: *mut JSContext,
                                        flags: ::std::os::raw::c_uint,
                                        errorCallback: JSErrorCallback,
                                        userRef: *mut ::std::os::raw::c_void,
                                        errorNumber:
                                            ::std::os::raw::c_uint, ...)
     -> bool;
    #[link_name =
          "_Z30JS_ReportErrorFlagsAndNumberUCP9JSContextjPFPK19JSErrorFormatStringPvjES4_jz"]
    pub fn JS_ReportErrorFlagsAndNumberUC(cx: *mut JSContext,
                                          flags: ::std::os::raw::c_uint,
                                          errorCallback: JSErrorCallback,
                                          userRef:
                                              *mut ::std::os::raw::c_void,
                                          errorNumber:
                                              ::std::os::raw::c_uint, ...)
     -> bool;
    /**
 * Complain when out of memory.
 */
    #[link_name = "_Z20JS_ReportOutOfMemoryP9JSContext"]
    pub fn JS_ReportOutOfMemory(cx: *mut JSContext);
    /**
 * Complain when an allocation size overflows the maximum supported limit.
 */
    #[link_name = "_Z27JS_ReportAllocationOverflowP9JSContext"]
    pub fn JS_ReportAllocationOverflow(cx: *mut JSContext);
    #[link_name =
          "_ZN2JS18SetWarningReporterEP9JSRuntimePFvP9JSContextPKcP13JSErrorReportE"]
    pub fn SetWarningReporter(rt: *mut JSRuntime, reporter: WarningReporter)
     -> WarningReporter;
    #[link_name = "_ZN2JS18GetWarningReporterEP9JSRuntime"]
    pub fn GetWarningReporter(rt: *mut JSRuntime) -> WarningReporter;
    #[link_name =
          "_ZN2JS11CreateErrorEP9JSContext9JSExnTypeNS_6HandleIP8JSObjectEENS3_IP8JSStringEEjjP13JSErrorReportS9_NS_13MutableHandleINS_5ValueEEE"]
    pub fn CreateError(cx: *mut JSContext, type_: JSExnType,
                       stack: HandleObject, fileName: HandleString,
                       lineNumber: u32, columnNumber: u32,
                       report: *mut JSErrorReport, message: HandleString,
                       rval: MutableHandleValue) -> bool;
    /************************************************************************/
    #[link_name = "_ZN2JS16NewWeakMapObjectEP9JSContext"]
    pub fn NewWeakMapObject(cx: *mut JSContext) -> *mut JSObject;
    #[link_name = "_ZN2JS15IsWeakMapObjectEP8JSObject"]
    pub fn IsWeakMapObject(obj: *mut JSObject) -> bool;
    #[link_name =
          "_ZN2JS15GetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEES5_NS_13MutableHandleINS_5ValueEEE"]
    pub fn GetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject,
                           key: HandleObject, val: MutableHandleValue)
     -> bool;
    #[link_name =
          "_ZN2JS15SetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEES5_NS2_INS_5ValueEEE"]
    pub fn SetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject,
                           key: HandleObject, val: HandleValue) -> bool;
    #[link_name = "_ZN2JS12NewMapObjectEP9JSContext"]
    pub fn NewMapObject(cx: *mut JSContext) -> *mut JSObject;
    #[link_name = "_ZN2JS7MapSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn MapSize(cx: *mut JSContext, obj: HandleObject) -> u32;
    #[link_name =
          "_ZN2JS6MapGetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
    pub fn MapGet(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS6MapHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
    pub fn MapHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  rval: *mut bool) -> bool;
    #[link_name =
          "_ZN2JS6MapSetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
    pub fn MapSet(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  val: HandleValue) -> bool;
    #[link_name =
          "_ZN2JS9MapDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
    pub fn MapDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                     rval: *mut bool) -> bool;
    #[link_name = "_ZN2JS8MapClearEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn MapClear(cx: *mut JSContext, obj: HandleObject) -> bool;
    #[link_name =
          "_ZN2JS7MapKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
    pub fn MapKeys(cx: *mut JSContext, obj: HandleObject,
                   rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS9MapValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
    pub fn MapValues(cx: *mut JSContext, obj: HandleObject,
                     rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS10MapEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
    pub fn MapEntries(cx: *mut JSContext, obj: HandleObject,
                      rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS10MapForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
    pub fn MapForEach(cx: *mut JSContext, obj: HandleObject,
                      callbackFn: HandleValue, thisVal: HandleValue) -> bool;
    #[link_name = "_ZN2JS12NewSetObjectEP9JSContext"]
    pub fn NewSetObject(cx: *mut JSContext) -> *mut JSObject;
    #[link_name = "_ZN2JS7SetSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn SetSize(cx: *mut JSContext, obj: HandleObject) -> u32;
    #[link_name =
          "_ZN2JS6SetHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
    pub fn SetHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  rval: *mut bool) -> bool;
    #[link_name =
          "_ZN2JS9SetDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
    pub fn SetDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                     rval: *mut bool) -> bool;
    #[link_name =
          "_ZN2JS6SetAddEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
    pub fn SetAdd(cx: *mut JSContext, obj: HandleObject, key: HandleValue)
     -> bool;
    #[link_name = "_ZN2JS8SetClearEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn SetClear(cx: *mut JSContext, obj: HandleObject) -> bool;
    #[link_name =
          "_ZN2JS7SetKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
    pub fn SetKeys(cx: *mut JSContext, obj: HandleObject,
                   rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS9SetValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
    pub fn SetValues(cx: *mut JSContext, obj: HandleObject,
                     rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS10SetEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
    pub fn SetEntries(cx: *mut JSContext, obj: HandleObject,
                      rval: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2JS10SetForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
    pub fn SetForEach(cx: *mut JSContext, obj: HandleObject,
                      callbackFn: HandleValue, thisVal: HandleValue) -> bool;
    #[link_name = "_Z16JS_NewDateObjectP9JSContextiiiiii"]
    pub fn JS_NewDateObject(cx: *mut JSContext, year: ::std::os::raw::c_int,
                            mon: ::std::os::raw::c_int,
                            mday: ::std::os::raw::c_int,
                            hour: ::std::os::raw::c_int,
                            min: ::std::os::raw::c_int,
                            sec: ::std::os::raw::c_int) -> *mut JSObject;
    /**
 * Returns true and sets |*isDate| indicating whether |obj| is a Date object or
 * a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isDate == false| when passed a proxy whose
 * target is a Date, or when passed a revoked proxy.
 */
    #[link_name = "_Z15JS_ObjectIsDateP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn JS_ObjectIsDate(cx: *mut JSContext, obj: HandleObject,
                           isDate: *mut bool) -> bool;
    #[link_name = "_Z18JS_NewRegExpObjectP9JSContextPKcyj"]
    pub fn JS_NewRegExpObject(cx: *mut JSContext,
                              bytes: *const ::std::os::raw::c_char,
                              length: usize, flags: ::std::os::raw::c_uint)
     -> *mut JSObject;
    #[link_name = "_Z20JS_NewUCRegExpObjectP9JSContextPKDsyj"]
    pub fn JS_NewUCRegExpObject(cx: *mut JSContext,
                                chars: *const ::std::os::raw::c_ushort,
                                length: usize, flags: ::std::os::raw::c_uint)
     -> *mut JSObject;
    #[link_name =
          "_Z17JS_SetRegExpInputP9JSContextN2JS6HandleIP8JSObjectEENS2_IP8JSStringEE"]
    pub fn JS_SetRegExpInput(cx: *mut JSContext, obj: HandleObject,
                             input: HandleString) -> bool;
    #[link_name =
          "_Z21JS_ClearRegExpStaticsP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_ClearRegExpStatics(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name =
          "_Z16JS_ExecuteRegExpP9JSContextN2JS6HandleIP8JSObjectEES5_PDsyPybNS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ExecuteRegExp(cx: *mut JSContext, obj: HandleObject,
                            reobj: HandleObject,
                            chars: *mut ::std::os::raw::c_ushort,
                            length: usize, indexp: *mut usize, test: bool,
                            rval: MutableHandleValue) -> bool;
    #[link_name =
          "_Z25JS_ExecuteRegExpNoStaticsP9JSContextN2JS6HandleIP8JSObjectEEPDsyPybNS1_13MutableHandleINS1_5ValueEEE"]
    pub fn JS_ExecuteRegExpNoStatics(cx: *mut JSContext, reobj: HandleObject,
                                     chars: *mut ::std::os::raw::c_ushort,
                                     length: usize, indexp: *mut usize,
                                     test: bool, rval: MutableHandleValue)
     -> bool;
    /**
 * Returns true and sets |*isRegExp| indicating whether |obj| is a RegExp
 * object or a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isRegExp == false| when passed a proxy whose
 * target is a RegExp, or when passed a revoked proxy.
 */
    #[link_name =
          "_Z17JS_ObjectIsRegExpP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn JS_ObjectIsRegExp(cx: *mut JSContext, obj: HandleObject,
                             isRegExp: *mut bool) -> bool;
    #[link_name = "_Z17JS_GetRegExpFlagsP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_GetRegExpFlags(cx: *mut JSContext, obj: HandleObject)
     -> ::std::os::raw::c_uint;
    #[link_name = "_Z18JS_GetRegExpSourceP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_GetRegExpSource(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSString;
    /************************************************************************/
    #[link_name = "_Z21JS_IsExceptionPendingP9JSContext"]
    pub fn JS_IsExceptionPending(cx: *mut JSContext) -> bool;
    #[link_name =
          "_Z22JS_GetPendingExceptionP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
    pub fn JS_GetPendingException(cx: *mut JSContext, vp: MutableHandleValue)
     -> bool;
    #[link_name =
          "_Z22JS_SetPendingExceptionP9JSContextN2JS6HandleINS1_5ValueEEE"]
    pub fn JS_SetPendingException(cx: *mut JSContext, v: HandleValue);
    #[link_name = "_Z24JS_ClearPendingExceptionP9JSContext"]
    pub fn JS_ClearPendingException(cx: *mut JSContext);
    #[link_name = "_Z21JS_SaveExceptionStateP9JSContext"]
    pub fn JS_SaveExceptionState(cx: *mut JSContext) -> *mut JSExceptionState;
    #[link_name =
          "_Z24JS_RestoreExceptionStateP9JSContextP16JSExceptionState"]
    pub fn JS_RestoreExceptionState(cx: *mut JSContext,
                                    state: *mut JSExceptionState);
    #[link_name = "_Z21JS_DropExceptionStateP9JSContextP16JSExceptionState"]
    pub fn JS_DropExceptionState(cx: *mut JSContext,
                                 state: *mut JSExceptionState);
    /**
 * If the given object is an exception object, the exception will have (or be
 * able to lazily create) an error report struct, and this function will return
 * the address of that struct.  Otherwise, it returns nullptr. The lifetime
 * of the error report struct that might be returned is the same as the
 * lifetime of the exception object.
 */
    #[link_name =
          "_Z21JS_ErrorFromExceptionP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_ErrorFromException(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSErrorReport;
    /**
 * If the given object is an exception object (or an unwrappable
 * cross-compartment wrapper for one), return the stack for that exception, if
 * any.  Will return null if the given object is not an exception object
 * (including if it's null or a security wrapper that can't be unwrapped) or if
 * the exception has no stack.
 */
    #[link_name = "_Z20ExceptionStackOrNullN2JS6HandleIP8JSObjectEE"]
    pub fn ExceptionStackOrNull(obj: HandleObject) -> *mut JSObject;
    #[link_name = "_Z21JS_ThrowStopIterationP9JSContext"]
    pub fn JS_ThrowStopIteration(cx: *mut JSContext) -> bool;
    #[link_name = "_Z18JS_IsStopIterationN2JS5ValueE"]
    pub fn JS_IsStopIteration(v: Value) -> bool;
    #[link_name = "_Z19JS_GetCurrentThreadv"]
    pub fn JS_GetCurrentThread() -> isize;
    /**
 * A JS runtime always has an "owner thread". The owner thread is set when the
 * runtime is created (to the current thread) and practically all entry points
 * into the JS engine check that a runtime (or anything contained in the
 * runtime: context, compartment, object, etc) is only touched by its owner
 * thread. Embeddings may check this invariant outside the JS engine by calling
 * JS_AbortIfWrongThread (which will abort if not on the owner thread, even for
 * non-debug builds).
 */
    #[link_name = "_Z21JS_AbortIfWrongThreadP9JSRuntime"]
    pub fn JS_AbortIfWrongThread(rt: *mut JSRuntime);
    /**
 * A constructor can request that the JS engine create a default new 'this'
 * object of the given class, using the callee to determine parentage and
 * [[Prototype]].
 */
    #[link_name =
          "_Z26JS_NewObjectForConstructorP9JSContextPK7JSClassRKN2JS8CallArgsE"]
    pub fn JS_NewObjectForConstructor(cx: *mut JSContext,
                                      clasp: *const JSClass,
                                      args: *const CallArgs) -> *mut JSObject;
    #[link_name = "_Z16JS_GetGCZealBitsP9JSContextPjS1_S1_"]
    pub fn JS_GetGCZealBits(cx: *mut JSContext, zealBits: *mut u32,
                            frequency: *mut u32, nextScheduled: *mut u32);
    #[link_name = "_Z12JS_SetGCZealP9JSRuntimehj"]
    pub fn JS_SetGCZeal(rt: *mut JSRuntime, zeal: u8, frequency: u32);
    #[link_name = "_Z13JS_ScheduleGCP9JSContextj"]
    pub fn JS_ScheduleGC(cx: *mut JSContext, count: u32);
    #[link_name = "_Z28JS_SetParallelParsingEnabledP9JSRuntimeb"]
    pub fn JS_SetParallelParsingEnabled(rt: *mut JSRuntime, enabled: bool);
    #[link_name = "_Z36JS_SetOffthreadIonCompilationEnabledP9JSRuntimeb"]
    pub fn JS_SetOffthreadIonCompilationEnabled(rt: *mut JSRuntime,
                                                enabled: bool);
    #[link_name =
          "_Z29JS_SetGlobalJitCompilerOptionP9JSRuntime19JSJitCompilerOptionj"]
    pub fn JS_SetGlobalJitCompilerOption(rt: *mut JSRuntime,
                                         opt: JSJitCompilerOption,
                                         value: u32);
    #[link_name =
          "_Z29JS_GetGlobalJitCompilerOptionP9JSRuntime19JSJitCompilerOption"]
    pub fn JS_GetGlobalJitCompilerOption(rt: *mut JSRuntime,
                                         opt: JSJitCompilerOption)
     -> ::std::os::raw::c_int;
    /**
 * Convert a uint32_t index into a jsid.
 */
    #[link_name = "_Z12JS_IndexToIdP9JSContextjN2JS13MutableHandleI4jsidEE"]
    pub fn JS_IndexToId(cx: *mut JSContext, index: u32, arg1: MutableHandleId)
     -> bool;
    /**
 * Convert chars into a jsid.
 *
 * |chars| may not be an index.
 */
    #[link_name =
          "_Z12JS_CharsToIdP9JSContextN2JS12TwoByteCharsENS1_13MutableHandleI4jsidEE"]
    pub fn JS_CharsToId(cx: *mut JSContext, chars: TwoByteChars,
                        arg1: MutableHandleId) -> bool;
    /**
 *  Test if the given string is a valid ECMAScript identifier
 */
    #[link_name = "_Z15JS_IsIdentifierP9JSContextN2JS6HandleIP8JSStringEEPb"]
    pub fn JS_IsIdentifier(cx: *mut JSContext, str: HandleString,
                           isIdentifier: *mut bool) -> bool;
    /**
 * Test whether the given chars + length are a valid ECMAScript identifier.
 * This version is infallible, so just returns whether the chars are an
 * identifier.
 */
    #[link_name = "_Z15JS_IsIdentifierPKDsy"]
    pub fn JS_IsIdentifier1(chars: *const ::std::os::raw::c_ushort,
                            length: usize) -> bool;
    /**
 * Return the current filename, line number and column number of the most
 * currently running frame. Returns true if a scripted frame was found, false
 * otherwise.
 *
 * If a the embedding has hidden the scripted caller for the topmost activation
 * record, this will also return false.
 */
    #[link_name =
          "_ZN2JS22DescribeScriptedCallerEP9JSContextPNS_12AutoFilenameEPjS4_"]
    pub fn DescribeScriptedCaller(cx: *mut JSContext,
                                  filename: *mut AutoFilename,
                                  lineno: *mut ::std::os::raw::c_uint,
                                  column: *mut ::std::os::raw::c_uint)
     -> bool;
    #[link_name = "_ZN2JS23GetScriptedCallerGlobalEP9JSContext"]
    pub fn GetScriptedCallerGlobal(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Informs the JS engine that the scripted caller should be hidden. This can be
 * used by the embedding to maintain an override of the scripted caller in its
 * calculations, by hiding the scripted caller in the JS engine and pushing data
 * onto a separate stack, which it inspects when DescribeScriptedCaller returns
 * null.
 *
 * We maintain a counter on each activation record. Add() increments the counter
 * of the topmost activation, and Remove() decrements it. The count may never
 * drop below zero, and must always be exactly zero when the activation is
 * popped from the stack.
 */
    #[link_name = "_ZN2JS18HideScriptedCallerEP9JSContext"]
    pub fn HideScriptedCaller(cx: *mut JSContext);
    #[link_name = "_ZN2JS20UnhideScriptedCallerEP9JSContext"]
    pub fn UnhideScriptedCaller(cx: *mut JSContext);
    #[link_name = "_Z15JS_EncodeScriptP9JSContextN2JS6HandleIP8JSScriptEEPj"]
    pub fn JS_EncodeScript(cx: *mut JSContext, script: HandleScript,
                           lengthp: *mut u32) -> *mut ::std::os::raw::c_void;
    #[link_name =
          "_Z28JS_EncodeInterpretedFunctionP9JSContextN2JS6HandleIP8JSObjectEEPj"]
    pub fn JS_EncodeInterpretedFunction(cx: *mut JSContext,
                                        funobj: HandleObject,
                                        lengthp: *mut u32)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "_Z15JS_DecodeScriptP9JSContextPKvj"]
    pub fn JS_DecodeScript(cx: *mut JSContext,
                           data: *const ::std::os::raw::c_void, length: u32)
     -> *mut JSScript;
    #[link_name = "_Z28JS_DecodeInterpretedFunctionP9JSContextPKvj"]
    pub fn JS_DecodeInterpretedFunction(cx: *mut JSContext,
                                        data: *const ::std::os::raw::c_void,
                                        length: u32) -> *mut JSObject;
    #[link_name = "_ZN2JS16SetAsmJSCacheOpsEP9JSRuntimePKNS_13AsmJSCacheOpsE"]
    pub fn SetAsmJSCacheOps(rt: *mut JSRuntime,
                            callbacks: *const AsmJSCacheOps);
    #[link_name =
          "_ZN2JS12SetBuildIdOpEP9JSRuntimePFbPN7mozilla6VectorIcLy0EN2js17SystemAllocPolicyEEEE"]
    pub fn SetBuildIdOp(rt: *mut JSRuntime, buildIdOp: BuildIdOp);
    #[link_name =
          "_ZN2JS33SetLargeAllocationFailureCallbackEP9JSRuntimePFvPvES2_"]
    pub fn SetLargeAllocationFailureCallback(rt: *mut JSRuntime,
                                             afc:
                                                 LargeAllocationFailureCallback,
                                             data:
                                                 *mut ::std::os::raw::c_void);
    #[link_name =
          "_ZN2JS22SetOutOfMemoryCallbackEP9JSRuntimePFvP9JSContextPvES4_"]
    pub fn SetOutOfMemoryCallback(rt: *mut JSRuntime, cb: OutOfMemoryCallback,
                                  data: *mut ::std::os::raw::c_void);
    /**
 * Capture the current call stack as a chain of SavedFrame JSObjects, and set
 * |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there
 * are no JS frames on the stack. If |maxFrameCount| is non-zero, capture at
 * most the youngest |maxFrameCount| frames.
 */
    #[link_name =
          "_ZN2JS19CaptureCurrentStackEP9JSContextNS_13MutableHandleIP8JSObjectEEj"]
    pub fn CaptureCurrentStack(cx: *mut JSContext,
                               stackp: MutableHandleObject,
                               maxFrameCount: ::std::os::raw::c_uint) -> bool;
    #[link_name =
          "_ZN2JS14CopyAsyncStackEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEENS_13MutableHandleIS4_EEj"]
    pub fn CopyAsyncStack(cx: *mut JSContext, asyncStack: HandleObject,
                          asyncCause: HandleString,
                          stackp: MutableHandleObject,
                          maxFrameCount: ::std::os::raw::c_uint) -> bool;
    /**
 * Given a SavedFrame JSObject, get its source property. Defaults to the empty
 * string.
 */
    #[link_name =
          "_ZN2JS19GetSavedFrameSourceEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameSource(cx: *mut JSContext, savedFrame: HandleObject,
                               sourcep: MutableHandleString,
                               selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its line property. Defaults to 0.
 */
    #[link_name =
          "_ZN2JS17GetSavedFrameLineEP9JSContextNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameLine(cx: *mut JSContext, savedFrame: HandleObject,
                             linep: *mut u32,
                             selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its column property. Defaults to 0.
 */
    #[link_name =
          "_ZN2JS19GetSavedFrameColumnEP9JSContextNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameColumn(cx: *mut JSContext, savedFrame: HandleObject,
                               columnp: *mut u32,
                               selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr
 * if SpiderMonkey was unable to infer a name for the captured frame's
 * function. Defaults to nullptr.
 */
    #[link_name =
          "_ZN2JS32GetSavedFrameFunctionDisplayNameEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameFunctionDisplayName(cx: *mut JSContext,
                                            savedFrame: HandleObject,
                                            namep: MutableHandleString,
                                            selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr.
 */
    #[link_name =
          "_ZN2JS23GetSavedFrameAsyncCauseEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameAsyncCause(cx: *mut JSContext,
                                   savedFrame: HandleObject,
                                   asyncCausep: MutableHandleString,
                                   selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr
 * if there is no asyncParent. The `asyncParentp` out parameter is _NOT_
 * guaranteed to be in the cx's compartment. Defaults to nullptr.
 */
    #[link_name =
          "_ZN2JS24GetSavedFrameAsyncParentEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIS4_EENS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameAsyncParent(cx: *mut JSContext,
                                    savedFrame: HandleObject,
                                    asyncParentp: MutableHandleObject,
                                    selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if
 * it is the oldest frame in the stack. The `parentp` out parameter is _NOT_
 * guaranteed to be in the cx's compartment. Defaults to nullptr.
 */
    #[link_name =
          "_ZN2JS19GetSavedFrameParentEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIS4_EENS_20SavedFrameSelfHostedE"]
    pub fn GetSavedFrameParent(cx: *mut JSContext, savedFrame: HandleObject,
                               parentp: MutableHandleObject,
                               selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject stack, stringify it in the same format as
 * Error.prototype.stack. The stringified stack out parameter is placed in the
 * cx's compartment. Defaults to the empty string.
 *
 * The same notes above about SavedFrame accessors applies here as well: cx
 * doesn't need to be in stack's compartment, and stack can be null, a
 * SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.
 *
 * Optional indent parameter specifies the number of white spaces to indent
 * each line.
 */
    #[link_name =
          "_ZN2JS16BuildStackStringEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEEy"]
    pub fn BuildStackString(cx: *mut JSContext, stack: HandleObject,
                            stringp: MutableHandleString, indent: usize)
     -> bool;
    /**
 * Return true iff the given object is either a SavedFrame object or wrapper
 * around a SavedFrame object, and it is not the SavedFrame.prototype object.
 */
    #[link_name = "_ZN2JS12IsSavedFrameEP8JSObject"]
    pub fn IsSavedFrame(obj: *mut JSObject) -> bool;
    /**
 * Commit any Performance Monitoring data.
 *
 * Until `FlushMonitoring` has been called, all PerformanceMonitoring data is invisible
 * to the outside world and can cancelled with a call to `ResetMonitoring`.
 */
    #[link_name = "_ZN2js26FlushPerformanceMonitoringEP9JSRuntime"]
    pub fn FlushPerformanceMonitoring(arg1: *mut JSRuntime) -> bool;
    /**
 * Cancel any measurement that hasn't been committed.
 */
    #[link_name = "_ZN2js26ResetPerformanceMonitoringEP9JSRuntime"]
    pub fn ResetPerformanceMonitoring(arg1: *mut JSRuntime);
    /**
 * Cleanup any memory used by performance monitoring.
 */
    #[link_name = "_ZN2js28DisposePerformanceMonitoringEP9JSRuntime"]
    pub fn DisposePerformanceMonitoring(arg1: *mut JSRuntime);
    /**
 * Turn on/off stopwatch-based CPU monitoring.
 *
 * `SetStopwatchIsMonitoringCPOW` or `SetStopwatchIsMonitoringJank`
 * may return `false` if monitoring could not be activated, which may
 * happen if we are out of memory.
 */
    #[link_name = "_ZN2js28SetStopwatchIsMonitoringCPOWEP9JSRuntimeb"]
    pub fn SetStopwatchIsMonitoringCPOW(arg1: *mut JSRuntime, arg2: bool)
     -> bool;
    #[link_name = "_ZN2js28GetStopwatchIsMonitoringCPOWEP9JSRuntime"]
    pub fn GetStopwatchIsMonitoringCPOW(arg1: *mut JSRuntime) -> bool;
    #[link_name = "_ZN2js28SetStopwatchIsMonitoringJankEP9JSRuntimeb"]
    pub fn SetStopwatchIsMonitoringJank(arg1: *mut JSRuntime, arg2: bool)
     -> bool;
    #[link_name = "_ZN2js28GetStopwatchIsMonitoringJankEP9JSRuntime"]
    pub fn GetStopwatchIsMonitoringJank(arg1: *mut JSRuntime) -> bool;
    #[link_name = "_ZN2js17IsStopwatchActiveEP9JSRuntime"]
    pub fn IsStopwatchActive(arg1: *mut JSRuntime) -> bool;
    #[link_name =
          "_ZN2js36GetPerfMonitoringTestCpuReschedulingEP9JSRuntimePyS2_"]
    pub fn GetPerfMonitoringTestCpuRescheduling(arg1: *mut JSRuntime,
                                                stayed: *mut u64,
                                                moved: *mut u64);
    /**
 * Add a number of microseconds to the time spent waiting on CPOWs
 * since process start.
 */
    #[link_name = "_ZN2js23AddCPOWPerformanceDeltaEP9JSRuntimey"]
    pub fn AddCPOWPerformanceDelta(arg1: *mut JSRuntime, delta: u64);
    #[link_name = "_ZN2js25SetStopwatchStartCallbackEP9JSRuntimePFbyPvES2_"]
    pub fn SetStopwatchStartCallback(arg1: *mut JSRuntime,
                                     arg2: StopwatchStartCallback,
                                     arg3: *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "_ZN2JS6detail19CallMethodIfWrappedEP9JSContextPFbNS_6HandleINS_5ValueEEEEPFbS2_RKNS_8CallArgsEESA_"]
    pub fn CallMethodIfWrapped(cx: *mut JSContext, test: IsAcceptableThis,
                               impl_: NativeImpl, args: *const CallArgs)
     -> bool;
    #[link_name = "_Z23JS_SetGrayGCRootsTracerP9JSRuntimePFvP8JSTracerPvES3_"]
    pub fn JS_SetGrayGCRootsTracer(rt: *mut JSRuntime, traceOp: JSTraceDataOp,
                                   data: *mut ::std::os::raw::c_void);
    #[link_name =
          "_Z23JS_FindCompilationScopeP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_FindCompilationScope(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSObject;
    #[link_name = "_Z20JS_GetObjectFunctionP8JSObject"]
    pub fn JS_GetObjectFunction(obj: *mut JSObject) -> *mut JSFunction;
    #[link_name =
          "_Z18JS_SplicePrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_SplicePrototype(cx: *mut JSContext, obj: HandleObject,
                              proto: HandleObject) -> bool;
    #[link_name =
          "_Z26JS_NewObjectWithUniqueTypeP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewObjectWithUniqueType(cx: *mut JSContext,
                                      clasp: *const JSClass,
                                      proto: HandleObject) -> *mut JSObject;
    /**
 * Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but
 * without invoking the metadata callback on it.  This allows creation of
 * internal bookkeeping objects that are guaranteed to not have metadata
 * attached to them.
 */
    #[link_name =
          "_Z27JS_NewObjectWithoutMetadataP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewObjectWithoutMetadata(cx: *mut JSContext,
                                       clasp: *const JSClass,
                                       proto: Handle<*mut JSObject>)
     -> *mut JSObject;
    #[link_name = "_Z26JS_ObjectCountDynamicSlotsN2JS6HandleIP8JSObjectEE"]
    pub fn JS_ObjectCountDynamicSlots(obj: HandleObject) -> u32;
    #[link_name = "_Z17JS_SetProtoCalledP9JSContext"]
    pub fn JS_SetProtoCalled(cx: *mut JSContext) -> usize;
    #[link_name = "_Z29JS_ImmutablePrototypesEnabledv"]
    pub fn JS_ImmutablePrototypesEnabled() -> bool;
    #[link_name = "_Z25JS_GetCustomIteratorCountP9JSContext"]
    pub fn JS_GetCustomIteratorCount(cx: *mut JSContext) -> usize;
    #[link_name =
          "_Z33JS_NondeterministicGetWeakMapKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
    pub fn JS_NondeterministicGetWeakMapKeys(cx: *mut JSContext,
                                             obj: HandleObject,
                                             ret: MutableHandleObject)
     -> bool;
    #[link_name =
          "_Z33JS_NondeterministicGetWeakSetKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
    pub fn JS_NondeterministicGetWeakSetKeys(cx: *mut JSContext,
                                             obj: HandleObject,
                                             ret: MutableHandleObject)
     -> bool;
    #[link_name = "_Z17JS_PCToLineNumberP8JSScriptPhPj"]
    pub fn JS_PCToLineNumber(script: *mut JSScript, pc: *mut jsbytecode,
                             columnp: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
    /**
 * Determine whether the given object is backed by a DeadObjectProxy.
 *
 * Such objects hold no other objects (they have no outgoing reference edges)
 * and will throw if you touch them (e.g. by reading/writing a property).
 */
    #[link_name = "_Z16JS_IsDeadWrapperP8JSObject"]
    pub fn JS_IsDeadWrapper(obj: *mut JSObject) -> bool;
    #[link_name =
          "_Z35JS_TraceShapeCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
    pub fn JS_TraceShapeCycleCollectorChildren(trc: *mut CallbackTracer,
                                               shape: GCCellPtr);
    #[link_name =
          "_Z41JS_TraceObjectGroupCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
    pub fn JS_TraceObjectGroupCycleCollectorChildren(trc: *mut CallbackTracer,
                                                     group: GCCellPtr);
    #[link_name = "_Z33JS_SetAccumulateTelemetryCallbackP9JSRuntimePFvijPKcE"]
    pub fn JS_SetAccumulateTelemetryCallback(rt: *mut JSRuntime,
                                             callback:
                                                 JSAccumulateTelemetryDataCallback);
    #[link_name = "_Z21JS_GetIsSecureContextP13JSCompartment"]
    pub fn JS_GetIsSecureContext(compartment: *mut JSCompartment) -> bool;
    #[link_name = "_Z27JS_GetCompartmentPrincipalsP13JSCompartment"]
    pub fn JS_GetCompartmentPrincipals(compartment: *mut JSCompartment)
     -> *mut JSPrincipals;
    #[link_name =
          "_Z27JS_SetCompartmentPrincipalsP13JSCompartmentP12JSPrincipals"]
    pub fn JS_SetCompartmentPrincipals(compartment: *mut JSCompartment,
                                       principals: *mut JSPrincipals);
    #[link_name = "_Z22JS_GetScriptPrincipalsP8JSScript"]
    pub fn JS_GetScriptPrincipals(script: *mut JSScript) -> *mut JSPrincipals;
    #[link_name = "_Z23JS_ScriptHasMutedErrorsP8JSScript"]
    pub fn JS_ScriptHasMutedErrors(script: *mut JSScript) -> bool;
    #[link_name = "_Z14JS_CloneObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_CloneObject(cx: *mut JSContext, obj: HandleObject,
                          proto: HandleObject) -> *mut JSObject;
    /**
 * Copy the own properties of src to dst in a fast way.  src and dst must both
 * be native and must be in the compartment of cx.  They must have the same
 * class, the same parent, and the same prototype.  Class reserved slots will
 * NOT be copied.
 *
 * dst must not have any properties on it before this function is called.
 *
 * src must have been allocated via JS_NewObjectWithoutMetadata so that we can
 * be sure it has no metadata that needs copying to dst.  This also means that
 * dst needs to have the compartment global as its parent.  This function will
 * preserve the existing metadata on dst, if any.
 */
    #[link_name =
          "_Z49JS_InitializePropertiesFromCompatibleNativeObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_InitializePropertiesFromCompatibleNativeObject(cx:
                                                                 *mut JSContext,
                                                             dst:
                                                                 HandleObject,
                                                             src:
                                                                 HandleObject)
     -> bool;
    #[link_name =
          "_Z22JS_BasicObjectToStringP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_BasicObjectToString(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSString;
    #[link_name =
          "_ZN2js15GetBuiltinClassEP9JSContextN2JS6HandleIP8JSObjectEEPNS_7ESClassE"]
    pub fn GetBuiltinClass(cx: *mut JSContext, obj: HandleObject,
                           cls: *mut ESClass) -> bool;
    #[link_name =
          "_ZN2js15ObjectClassNameEP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn ObjectClassName(cx: *mut JSContext, obj: HandleObject)
     -> *const ::std::os::raw::c_char;
    #[link_name = "_ZN2js18ReportOverRecursedEP9JSContext"]
    pub fn ReportOverRecursed(maybecx: *mut JSContext);
    #[link_name = "_ZN2js15AddRawValueRootEP9JSContextPN2JS5ValueEPKc"]
    pub fn AddRawValueRoot(cx: *mut JSContext, vp: *mut Value,
                           name: *const ::std::os::raw::c_char) -> bool;
    #[link_name = "_ZN2js18RemoveRawValueRootEP9JSContextPN2JS5ValueE"]
    pub fn RemoveRawValueRoot(cx: *mut JSContext, vp: *mut Value);
    #[link_name = "_ZN2js21GetPropertyNameFromPCEP8JSScriptPh"]
    pub fn GetPropertyNameFromPC(script: *mut JSScript, pc: *mut jsbytecode)
     -> *mut JSAtom;
    #[link_name = "_ZN2js10DumpStringEP8JSStringP6_iobuf"]
    pub fn DumpString(str: *mut JSString, fp: *mut FILE);
    #[link_name = "_ZN2js8DumpAtomEP6JSAtomP6_iobuf"]
    pub fn DumpAtom(atom: *mut JSAtom, fp: *mut FILE);
    #[link_name = "_ZN2js10DumpObjectEP8JSObjectP6_iobuf"]
    pub fn DumpObject(obj: *mut JSObject, fp: *mut FILE);
    #[link_name = "_ZN2js9DumpCharsEPKDsyP6_iobuf"]
    pub fn DumpChars(s: *const ::std::os::raw::c_ushort, n: usize,
                     fp: *mut FILE);
    #[link_name = "_ZN2js9DumpValueERKN2JS5ValueEP6_iobuf"]
    pub fn DumpValue(val: *const Value, fp: *mut FILE);
    #[link_name = "_ZN2js6DumpIdE4jsidP6_iobuf"]
    pub fn DumpId(id: jsid, fp: *mut FILE);
    #[link_name =
          "_ZN2js20DumpInterpreterFrameEP9JSContextP6_iobufPNS_16InterpreterFrameE"]
    pub fn DumpInterpreterFrame(cx: *mut JSContext, fp: *mut FILE,
                                start: *mut InterpreterFrame);
    #[link_name = "_ZN2js6DumpPCEP9JSContextP6_iobuf"]
    pub fn DumpPC(cx: *mut JSContext, fp: *mut FILE) -> bool;
    #[link_name = "_ZN2js10DumpScriptEP9JSContextP8JSScriptP6_iobuf"]
    pub fn DumpScript(cx: *mut JSContext, scriptArg: *mut JSScript,
                      fp: *mut FILE) -> bool;
    #[link_name = "_ZN2js10DumpStringEP8JSString"]
    pub fn DumpString1(str: *mut JSString);
    #[link_name = "_ZN2js8DumpAtomEP6JSAtom"]
    pub fn DumpAtom1(atom: *mut JSAtom);
    #[link_name = "_ZN2js10DumpObjectEP8JSObject"]
    pub fn DumpObject1(obj: *mut JSObject);
    #[link_name = "_ZN2js9DumpCharsEPKDsy"]
    pub fn DumpChars1(s: *const ::std::os::raw::c_ushort, n: usize);
    #[link_name = "_ZN2js9DumpValueERKN2JS5ValueE"]
    pub fn DumpValue1(val: *const Value);
    #[link_name = "_ZN2js6DumpIdE4jsid"]
    pub fn DumpId1(id: jsid);
    #[link_name =
          "_ZN2js20DumpInterpreterFrameEP9JSContextPNS_16InterpreterFrameE"]
    pub fn DumpInterpreterFrame1(cx: *mut JSContext,
                                 start: *mut InterpreterFrame);
    #[link_name = "_ZN2js6DumpPCEP9JSContext"]
    pub fn DumpPC1(cx: *mut JSContext) -> bool;
    #[link_name = "_ZN2js10DumpScriptEP9JSContextP8JSScript"]
    pub fn DumpScript1(cx: *mut JSContext, scriptArg: *mut JSScript) -> bool;
    #[link_name = "_ZN2js13DumpBacktraceEP9JSContextP6_iobuf"]
    pub fn DumpBacktrace(cx: *mut JSContext, fp: *mut FILE);
    #[link_name = "_ZN2js13DumpBacktraceEP9JSContext"]
    pub fn DumpBacktrace1(cx: *mut JSContext);
    /** Exposed for DumpJSStack */
    #[link_name = "_ZN2JS15FormatStackDumpEP9JSContextPcbbb"]
    pub fn FormatStackDump(cx: *mut JSContext,
                           buf: *mut ::std::os::raw::c_char, showArgs: bool,
                           showLocals: bool, showThisProps: bool)
     -> *mut ::std::os::raw::c_char;
    /**
 * Set all of the uninitialized lexicals on an object to undefined. Return
 * true if any lexicals were initialized and false otherwise.
 * */
    #[link_name =
          "_ZN2JS26ForceLexicalInitializationEP9JSContextNS_6HandleIP8JSObjectEE"]
    pub fn ForceLexicalInitialization(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    /**
 * Copies all own properties from |obj| to |target|. |obj| must be a "native"
 * object (that is to say, normal-ish - not an Array or a Proxy).
 *
 * This function immediately enters a compartment, and does not impose any
 * restrictions on the compartment of |cx|.
 */
    #[link_name =
          "_Z21JS_CopyPropertiesFromP9JSContextN2JS6HandleIP8JSObjectEES5_"]
    pub fn JS_CopyPropertiesFrom(cx: *mut JSContext, target: HandleObject,
                                 obj: HandleObject) -> bool;
    #[link_name =
          "_Z19JS_CopyPropertyFromP9JSContextN2JS6HandleI4jsidEENS2_IP8JSObjectEES7_20PropertyCopyBehavior"]
    pub fn JS_CopyPropertyFrom(cx: *mut JSContext, id: HandleId,
                               target: HandleObject, obj: HandleObject,
                               copyBehavior: PropertyCopyBehavior) -> bool;
    #[link_name =
          "_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleINS1_18PropertyDescriptorEEE"]
    pub fn JS_WrapPropertyDescriptor(cx: *mut JSContext,
                                     desc: MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "_Z26JS_DefineFunctionsWithHelpP9JSContextN2JS6HandleIP8JSObjectEEPK22JSFunctionSpecWithHelp"]
    pub fn JS_DefineFunctionsWithHelp(cx: *mut JSContext, obj: HandleObject,
                                      fs: *const JSFunctionSpecWithHelp)
     -> bool;
    #[link_name =
          "_ZN2js20proxy_LookupPropertyEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEENS2_13MutableHandleIS5_EENS9_IPNS_5ShapeEEE"]
    pub fn proxy_LookupProperty(cx: *mut JSContext, obj: HandleObject,
                                id: HandleId, objp: MutableHandleObject,
                                propp: MutableHandle<*mut Shape>) -> bool;
    #[link_name =
          "_ZN2js20proxy_DefinePropertyEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEENS3_INS2_18PropertyDescriptorEEERNS2_14ObjectOpResultE"]
    pub fn proxy_DefineProperty(cx: *mut JSContext, obj: HandleObject,
                                id: HandleId,
                                desc: Handle<PropertyDescriptor>,
                                result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "_ZN2js17proxy_HasPropertyEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEEPb"]
    pub fn proxy_HasProperty(cx: *mut JSContext, obj: HandleObject,
                             id: HandleId, foundp: *mut bool) -> bool;
    #[link_name =
          "_ZN2js17proxy_GetPropertyEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_5ValueEEENS3_I4jsidEENS2_13MutableHandleIS7_EE"]
    pub fn proxy_GetProperty(cx: *mut JSContext, obj: HandleObject,
                             receiver: HandleValue, id: HandleId,
                             vp: MutableHandleValue) -> bool;
    #[link_name =
          "_ZN2js17proxy_SetPropertyEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEENS3_INS2_5ValueEEESA_RNS2_14ObjectOpResultE"]
    pub fn proxy_SetProperty(cx: *mut JSContext, obj: HandleObject,
                             id: HandleId, bp: HandleValue,
                             receiver: HandleValue,
                             result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "_ZN2js30proxy_GetOwnPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEENS2_13MutableHandleINS2_18PropertyDescriptorEEE"]
    pub fn proxy_GetOwnPropertyDescriptor(cx: *mut JSContext,
                                          obj: HandleObject, id: HandleId,
                                          desc:
                                              MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "_ZN2js20proxy_DeletePropertyEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEERNS2_14ObjectOpResultE"]
    pub fn proxy_DeleteProperty(cx: *mut JSContext, obj: HandleObject,
                                id: HandleId, result: *mut ObjectOpResult)
     -> bool;
    #[link_name = "_ZN2js11proxy_TraceEP8JSTracerP8JSObject"]
    pub fn proxy_Trace(trc: *mut JSTracer, obj: *mut JSObject);
    #[link_name = "_ZN2js24proxy_WeakmapKeyDelegateEP8JSObject"]
    pub fn proxy_WeakmapKeyDelegate(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "_ZN2js13proxy_ConvertEP9JSContextN2JS6HandleIP8JSObjectEE6JSTypeNS2_13MutableHandleINS2_5ValueEEE"]
    pub fn proxy_Convert(cx: *mut JSContext, proxy: HandleObject,
                         hint: JSType, vp: MutableHandleValue) -> bool;
    #[link_name = "_ZN2js14proxy_FinalizeEPNS_6FreeOpEP8JSObject"]
    pub fn proxy_Finalize(fop: *mut FreeOp, obj: *mut JSObject);
    #[link_name = "_ZN2js17proxy_ObjectMovedEP8JSObjectPKS0_"]
    pub fn proxy_ObjectMoved(obj: *mut JSObject, old: *const JSObject);
    #[link_name =
          "_ZN2js17proxy_HasInstanceEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleINS2_5ValueEEEPb"]
    pub fn proxy_HasInstance(cx: *mut JSContext, proxy: HandleObject,
                             v: MutableHandleValue, bp: *mut bool) -> bool;
    #[link_name = "_ZN2js10proxy_CallEP9JSContextjPN2JS5ValueE"]
    pub fn proxy_Call(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                      vp: *mut Value) -> bool;
    #[link_name = "_ZN2js15proxy_ConstructEP9JSContextjPN2JS5ValueE"]
    pub fn proxy_Construct(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                           vp: *mut Value) -> bool;
    #[link_name = "_ZN2js17proxy_innerObjectEP8JSObject"]
    pub fn proxy_innerObject(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "_ZN2js11proxy_WatchEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEES6_"]
    pub fn proxy_Watch(cx: *mut JSContext, obj: HandleObject, id: HandleId,
                       callable: HandleObject) -> bool;
    #[link_name =
          "_ZN2js13proxy_UnwatchEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEE"]
    pub fn proxy_Unwatch(cx: *mut JSContext, obj: HandleObject, id: HandleId)
     -> bool;
    #[link_name =
          "_ZN2js17proxy_GetElementsEP9JSContextN2JS6HandleIP8JSObjectEEjjPNS_12ElementAdderE"]
    pub fn proxy_GetElements(cx: *mut JSContext, proxy: HandleObject,
                             begin: u32, end: u32, adder: *mut ElementAdder)
     -> bool;
    #[link_name =
          "_ZN2js17proxy_FunToStringEP9JSContextN2JS6HandleIP8JSObjectEEj"]
    pub fn proxy_FunToString(cx: *mut JSContext, proxy: HandleObject,
                             indent: ::std::os::raw::c_uint) -> *mut JSString;
    #[link_name = "_ZN2js18GetCompartmentZoneEP13JSCompartment"]
    pub fn GetCompartmentZone(comp: *mut JSCompartment) -> *mut Zone;
    /**
  * Dump the complete object graph of heap-allocated things.
  * fp is the file for the dump output.
  */
    #[link_name =
          "_ZN2js8DumpHeapEP9JSRuntimeP6_iobufNS_24DumpHeapNurseryBehaviourE"]
    pub fn DumpHeap(rt: *mut JSRuntime, fp: *mut FILE,
                    nurseryBehaviour: DumpHeapNurseryBehaviour);
    #[link_name = "_ZN2js16obj_defineGetterEP9JSContextjPN2JS5ValueE"]
    pub fn obj_defineGetter(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                            vp: *mut Value) -> bool;
    #[link_name = "_ZN2js16obj_defineSetterEP9JSContextjPN2JS5ValueE"]
    pub fn obj_defineSetter(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                            vp: *mut Value) -> bool;
    #[link_name = "_ZN2js19IsSystemCompartmentEP13JSCompartment"]
    pub fn IsSystemCompartment(comp: *mut JSCompartment) -> bool;
    #[link_name = "_ZN2js12IsSystemZoneEPN2JS4ZoneE"]
    pub fn IsSystemZone(zone: *mut Zone) -> bool;
    #[link_name = "_ZN2js18IsAtomsCompartmentEP13JSCompartment"]
    pub fn IsAtomsCompartment(comp: *mut JSCompartment) -> bool;
    #[link_name = "_ZN2js11IsAtomsZoneEPN2JS4ZoneE"]
    pub fn IsAtomsZone(zone: *mut Zone) -> bool;
    #[link_name = "_ZN2js13TraceWeakMapsEPNS_13WeakMapTracerE"]
    pub fn TraceWeakMaps(trc: *mut WeakMapTracer);
    #[link_name = "_ZN2js18AreGCGrayBitsValidEP9JSRuntime"]
    pub fn AreGCGrayBitsValid(rt: *mut JSRuntime) -> bool;
    #[link_name = "_ZN2js21ZoneGlobalsAreAllGrayEPN2JS4ZoneE"]
    pub fn ZoneGlobalsAreAllGray(zone: *mut Zone) -> bool;
    #[link_name =
          "_ZN2js23VisitGrayWrapperTargetsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrEES3_"]
    pub fn VisitGrayWrapperTargets(zone: *mut Zone, callback: GCThingCallback,
                                   closure: *mut ::std::os::raw::c_void);
    #[link_name = "_ZN2js21GetWeakmapKeyDelegateEP8JSObject"]
    pub fn GetWeakmapKeyDelegate(key: *mut JSObject) -> *mut JSObject;
    /**
 * Invoke cellCallback on every gray JS_OBJECT in the given zone.
 */
    #[link_name =
          "_ZN2js18IterateGrayObjectsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrEES3_"]
    pub fn IterateGrayObjects(zone: *mut Zone, cellCallback: GCThingCallback,
                              data: *mut ::std::os::raw::c_void);
    #[link_name = "_ZN2js23GetAnyCompartmentInZoneEPN2JS4ZoneE"]
    pub fn GetAnyCompartmentInZone(zone: *mut Zone) -> *mut JSCompartment;
    #[link_name = "_ZN2js15ProtoKeyToClassE10JSProtoKey"]
    pub fn ProtoKeyToClass(key: JSProtoKey) -> *const Class;
    #[link_name = "_ZN2js16IsFunctionObjectEP8JSObject"]
    pub fn IsFunctionObject(obj: *mut JSObject) -> bool;
    #[link_name = "_ZN2js34GetGlobalForObjectCrossCompartmentEP8JSObject"]
    pub fn GetGlobalForObjectCrossCompartment(obj: *mut JSObject)
     -> *mut JSObject;
    #[link_name = "_ZN2js19GetPrototypeNoProxyEP8JSObject"]
    pub fn GetPrototypeNoProxy(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js21AssertSameCompartmentEP9JSContextP8JSObject"]
    pub fn AssertSameCompartment(cx: *mut JSContext, obj: *mut JSObject);
    #[link_name = "_ZN2js21AssertSameCompartmentEP8JSObjectS1_"]
    pub fn AssertSameCompartment1(objA: *mut JSObject, objB: *mut JSObject);
    #[link_name = "_ZN2js23NotifyAnimationActivityEP8JSObject"]
    pub fn NotifyAnimationActivity(obj: *mut JSObject);
    /**
 * Return the outermost enclosing function (script) of the scripted caller.
 * This function returns nullptr in several cases:
 *  - no script is running on the context
 *  - the caller is in global or eval code
 * In particular, this function will "stop" its outermost search at eval() and
 * thus it will really return the outermost enclosing function *since the
 * innermost eval*.
 */
    #[link_name =
          "_ZN2js45GetOutermostEnclosingFunctionOfScriptedCallerEP9JSContext"]
    pub fn GetOutermostEnclosingFunctionOfScriptedCaller(cx: *mut JSContext)
     -> *mut JSFunction;
    #[link_name =
          "_ZN2js26DefineFunctionWithReservedEP9JSContextP8JSObjectPKcPFbS1_jPN2JS5ValueEEjj"]
    pub fn DefineFunctionWithReserved(cx: *mut JSContext, obj: *mut JSObject,
                                      name: *const ::std::os::raw::c_char,
                                      call: JSNative,
                                      nargs: ::std::os::raw::c_uint,
                                      attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    #[link_name =
          "_ZN2js23NewFunctionWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjPKc"]
    pub fn NewFunctionWithReserved(cx: *mut JSContext, call: JSNative,
                                   nargs: ::std::os::raw::c_uint,
                                   flags: ::std::os::raw::c_uint,
                                   name: *const ::std::os::raw::c_char)
     -> *mut JSFunction;
    #[link_name =
          "_ZN2js27NewFunctionByIdWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjj4jsid"]
    pub fn NewFunctionByIdWithReserved(cx: *mut JSContext, native: JSNative,
                                       nargs: ::std::os::raw::c_uint,
                                       flags: ::std::os::raw::c_uint,
                                       id: jsid) -> *mut JSFunction;
    #[link_name = "_ZN2js25GetFunctionNativeReservedEP8JSObjecty"]
    pub fn GetFunctionNativeReserved(fun: *mut JSObject, which: usize)
     -> *const Value;
    #[link_name =
          "_ZN2js25SetFunctionNativeReservedEP8JSObjectyRKN2JS5ValueE"]
    pub fn SetFunctionNativeReserved(fun: *mut JSObject, which: usize,
                                     val: *const Value);
    #[link_name = "_ZN2js25FunctionHasNativeReservedEP8JSObject"]
    pub fn FunctionHasNativeReserved(fun: *mut JSObject) -> bool;
    #[link_name =
          "_ZN2js14GetObjectProtoEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleIS5_EE"]
    pub fn GetObjectProto(cx: *mut JSContext, obj: HandleObject,
                          proto: MutableHandleObject) -> bool;
    #[link_name = "_ZN2js18GetStaticPrototypeEP8JSObject"]
    pub fn GetStaticPrototype(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "_ZN2js15GetOriginalEvalEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleIS5_EE"]
    pub fn GetOriginalEval(cx: *mut JSContext, scope: HandleObject,
                           eval: MutableHandleObject) -> bool;
    #[link_name =
          "_ZN2js40SetReservedOrProxyPrivateSlotWithBarrierEP8JSObjectyRKN2JS5ValueE"]
    pub fn SetReservedOrProxyPrivateSlotWithBarrier(obj: *mut JSObject,
                                                    slot: usize,
                                                    value: *const Value);
    #[link_name = "_ZN2js17GetObjectSlotSpanEP8JSObject"]
    pub fn GetObjectSlotSpan(obj: *mut JSObject) -> u32;
    #[link_name = "_ZN2js24StringToLinearStringSlowEP9JSContextP8JSString"]
    pub fn StringToLinearStringSlow(cx: *mut JSContext, str: *mut JSString)
     -> *mut JSLinearString;
    /**
 * Add some or all property keys of obj to the id vector *props.
 *
 * The flags parameter controls which property keys are added. Pass a
 * combination of the following bits:
 *
 *     JSITER_OWNONLY - Don't also search the prototype chain; only consider
 *       obj's own properties.
 *
 *     JSITER_HIDDEN - Include nonenumerable properties.
 *
 *     JSITER_SYMBOLS - Include property keys that are symbols. The default
 *       behavior is to filter out symbols.
 *
 *     JSITER_SYMBOLSONLY - Exclude non-symbol property keys.
 *
 * This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or
 * equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass
 * `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get
 * results that match the output of Reflect.ownKeys.
 */
    #[link_name =
          "_ZN2js15GetPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEEjPNS2_16AutoVectorRooterI4jsidEE"]
    pub fn GetPropertyKeys(cx: *mut JSContext, obj: HandleObject,
                           flags: ::std::os::raw::c_uint,
                           props: *mut AutoIdVector) -> bool;
    #[link_name =
          "_ZN2js12AppendUniqueEP9JSContextRN2JS16AutoVectorRooterI4jsidEES6_"]
    pub fn AppendUnique(cx: *mut JSContext, base: *mut AutoIdVector,
                        others: *mut AutoIdVector) -> bool;
    #[link_name = "_ZN2js18StringIsArrayIndexEP14JSLinearStringPj"]
    pub fn StringIsArrayIndex(str: *mut JSLinearString, indexp: *mut u32)
     -> bool;
    #[link_name =
          "_ZN2js26SetPreserveWrapperCallbackEP9JSRuntimePFbP9JSContextP8JSObjectE"]
    pub fn SetPreserveWrapperCallback(rt: *mut JSRuntime,
                                      callback: PreserveWrapperCallback);
    #[link_name =
          "_ZN2js28IsObjectInContextCompartmentEP8JSObjectPK9JSContext"]
    pub fn IsObjectInContextCompartment(obj: *mut JSObject,
                                        cx: *const JSContext) -> bool;
    #[link_name = "_ZN2js28RunningWithTrustedPrincipalsEP9JSContext"]
    pub fn RunningWithTrustedPrincipals(cx: *mut JSContext) -> bool;
    #[link_name = "_ZN2js21StartPCCountProfilingEP9JSContext"]
    pub fn StartPCCountProfiling(cx: *mut JSContext);
    #[link_name = "_ZN2js20StopPCCountProfilingEP9JSContext"]
    pub fn StopPCCountProfiling(cx: *mut JSContext);
    #[link_name = "_ZN2js13PurgePCCountsEP9JSContext"]
    pub fn PurgePCCounts(cx: *mut JSContext);
    #[link_name = "_ZN2js21GetPCCountScriptCountEP9JSContext"]
    pub fn GetPCCountScriptCount(cx: *mut JSContext) -> usize;
    #[link_name = "_ZN2js23GetPCCountScriptSummaryEP9JSContexty"]
    pub fn GetPCCountScriptSummary(cx: *mut JSContext, script: usize)
     -> *mut JSString;
    #[link_name = "_ZN2js24GetPCCountScriptContentsEP9JSContexty"]
    pub fn GetPCCountScriptContents(cx: *mut JSContext, script: usize)
     -> *mut JSString;
    /**
 * Generate lcov trace file content for the current compartment, and allocate a
 * new buffer and return the content in it, the size of the newly allocated
 * content within the buffer would be set to the length out-param.
 *
 * In case of out-of-memory, this function returns nullptr and does not set any
 * value to the length out-param.
 */
    #[link_name = "_ZN2js22GetCodeCoverageSummaryEP9JSContextPy"]
    pub fn GetCodeCoverageSummary(cx: *mut JSContext, length: *mut usize)
     -> *mut ::std::os::raw::c_char;
    /**
 * Sets a callback that is run whenever the runtime goes idle - the
 * last active request ceases - and begins activity - when it was
 * idle and a request begins.
 */
    #[link_name = "_ZN2js19SetActivityCallbackEP9JSRuntimePFvPvbES2_"]
    pub fn SetActivityCallback(rt: *mut JSRuntime, cb: ActivityCallback,
                               arg: *mut ::std::os::raw::c_void);
    #[link_name = "_ZN2js15SetDOMCallbacksEP9JSRuntimePKNS_14JSDOMCallbacksE"]
    pub fn SetDOMCallbacks(rt: *mut JSRuntime,
                           callbacks: *const DOMCallbacks);
    #[link_name = "_ZN2js15GetDOMCallbacksEP9JSRuntime"]
    pub fn GetDOMCallbacks(rt: *mut JSRuntime) -> *const DOMCallbacks;
    #[link_name = "_ZN2js19GetTestingFunctionsEP9JSContext"]
    pub fn GetTestingFunctions(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Get an error type name from a JSExnType constant.
 * Returns nullptr for invalid arguments and JSEXN_INTERNALERR
 */
    #[link_name = "_ZN2js16GetErrorTypeNameEP9JSRuntimes"]
    pub fn GetErrorTypeName(rt: *mut JSRuntime, exnType: i16)
     -> *mut JSFlatString;
    #[link_name = "_ZN2js24GetEnterCompartmentDepthEP9JSContext"]
    pub fn GetEnterCompartmentDepth(cx: *mut JSContext)
     -> ::std::os::raw::c_uint;
    #[link_name =
          "_ZN2js23RegExpToSharedNonInlineEP9JSContextN2JS6HandleIP8JSObjectEEPNS_11RegExpGuardE"]
    pub fn RegExpToSharedNonInline(cx: *mut JSContext, regexp: HandleObject,
                                   shared: *mut RegExpGuard) -> bool;
    #[link_name =
          "_ZN2js28NukeCrossCompartmentWrappersEP9JSContextRKNS_17CompartmentFilterES4_NS_22NukeReferencesToWindowE"]
    pub fn NukeCrossCompartmentWrappers(cx: *mut JSContext,
                                        sourceFilter:
                                            *const CompartmentFilter,
                                        targetFilter:
                                            *const CompartmentFilter,
                                        nukeReferencesToWindow:
                                            NukeReferencesToWindow) -> bool;
    #[link_name =
          "_ZN2js22SetDOMProxyInformationEPKvjPFNS_21DOMProxyShadowsResultEP9JSContextN2JS6HandleIP8JSObjectEENS6_I4jsidEEE"]
    pub fn SetDOMProxyInformation(domProxyHandlerFamily:
                                      *const ::std::os::raw::c_void,
                                  domProxyExpandoSlot: u32,
                                  domProxyShadowsCheck: DOMProxyShadowsCheck);
    #[link_name = "_ZN2js24GetDOMProxyHandlerFamilyEv"]
    pub fn GetDOMProxyHandlerFamily() -> *const ::std::os::raw::c_void;
    #[link_name = "_ZN2js22GetDOMProxyExpandoSlotEv"]
    pub fn GetDOMProxyExpandoSlot() -> u32;
    #[link_name = "_ZN2js23GetDOMProxyShadowsCheckEv"]
    pub fn GetDOMProxyShadowsCheck() -> DOMProxyShadowsCheck;
    /** Detect whether the internal date value is NaN. */
    #[link_name = "_ZN2js11DateIsValidEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn DateIsValid(cx: *mut JSContext, obj: HandleObject,
                       isValid: *mut bool) -> bool;
    #[link_name =
          "_ZN2js21DateGetMsecSinceEpochEP9JSContextN2JS6HandleIP8JSObjectEEPd"]
    pub fn DateGetMsecSinceEpoch(cx: *mut JSContext, obj: HandleObject,
                                 msecSinceEpoch: *mut f64) -> bool;
    #[link_name = "_ZN2js15GetErrorMessageEPvj"]
    pub fn GetErrorMessage(userRef: *mut ::std::os::raw::c_void,
                           errorNumber: ::std::os::raw::c_uint)
     -> *const JSErrorFormatString;
    #[link_name = "_ZN2js11GetSCOffsetEP23JSStructuredCloneWriter"]
    pub fn GetSCOffset(writer: *mut JSStructuredCloneWriter) -> u64;
    #[link_name = "_Z15JS_NewInt8ArrayP9JSContextj"]
    pub fn JS_NewInt8Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z16JS_NewUint8ArrayP9JSContextj"]
    pub fn JS_NewUint8Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z23JS_NewUint8ClampedArrayP9JSContextj"]
    pub fn JS_NewUint8ClampedArray(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z16JS_NewInt16ArrayP9JSContextj"]
    pub fn JS_NewInt16Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z17JS_NewUint16ArrayP9JSContextj"]
    pub fn JS_NewUint16Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z16JS_NewInt32ArrayP9JSContextj"]
    pub fn JS_NewInt32Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z17JS_NewUint32ArrayP9JSContextj"]
    pub fn JS_NewUint32Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z18JS_NewFloat32ArrayP9JSContextj"]
    pub fn JS_NewFloat32Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "_Z18JS_NewFloat64ArrayP9JSContextj"]
    pub fn JS_NewFloat64Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name =
          "_Z24JS_NewInt8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewInt8ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z25JS_NewUint8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewUint8ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z32JS_NewUint8ClampedArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewUint8ClampedArrayFromArray(cx: *mut JSContext,
                                            array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z25JS_NewInt16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewInt16ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z26JS_NewUint16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewUint16ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z25JS_NewInt32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewInt32ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z26JS_NewUint32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewUint32ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "_Z27JS_NewFloat32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewFloat32ArrayFromArray(cx: *mut JSContext,
                                       array: HandleObject) -> *mut JSObject;
    #[link_name =
          "_Z27JS_NewFloat64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
    pub fn JS_NewFloat64ArrayFromArray(cx: *mut JSContext,
                                       array: HandleObject) -> *mut JSObject;
    #[link_name =
          "_Z25JS_NewInt8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewInt8ArrayWithBuffer(cx: *mut JSContext,
                                     arrayBuffer: HandleObject,
                                     byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z26JS_NewUint8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewUint8ArrayWithBuffer(cx: *mut JSContext,
                                      arrayBuffer: HandleObject,
                                      byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z33JS_NewUint8ClampedArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewUint8ClampedArrayWithBuffer(cx: *mut JSContext,
                                             arrayBuffer: HandleObject,
                                             byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z26JS_NewInt16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewInt16ArrayWithBuffer(cx: *mut JSContext,
                                      arrayBuffer: HandleObject,
                                      byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z27JS_NewUint16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewUint16ArrayWithBuffer(cx: *mut JSContext,
                                       arrayBuffer: HandleObject,
                                       byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z26JS_NewInt32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewInt32ArrayWithBuffer(cx: *mut JSContext,
                                      arrayBuffer: HandleObject,
                                      byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z27JS_NewUint32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewUint32ArrayWithBuffer(cx: *mut JSContext,
                                       arrayBuffer: HandleObject,
                                       byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z28JS_NewFloat32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewFloat32ArrayWithBuffer(cx: *mut JSContext,
                                        arrayBuffer: HandleObject,
                                        byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "_Z28JS_NewFloat64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewFloat64ArrayWithBuffer(cx: *mut JSContext,
                                        arrayBuffer: HandleObject,
                                        byteOffset: u32, length: i32)
     -> *mut JSObject;
    /**
 * Create a new SharedArrayBuffer with the given byte length.  This
 * may only be called if
 * JS::CompartmentCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is
 * true.
 */
    #[link_name = "_Z23JS_NewSharedArrayBufferP9JSContextj"]
    pub fn JS_NewSharedArrayBuffer(cx: *mut JSContext, nbytes: u32)
     -> *mut JSObject;
    /**
 * Create a new ArrayBuffer with the given byte length.
 */
    #[link_name = "_Z17JS_NewArrayBufferP9JSContextj"]
    pub fn JS_NewArrayBuffer(cx: *mut JSContext, nbytes: u32)
     -> *mut JSObject;
    /**
 * Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
 * false if a security wrapper is encountered that denies the unwrapping. If
 * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
 * the various accessor JSAPI calls defined below.
 */
    #[link_name = "_Z21JS_IsTypedArrayObjectP8JSObject"]
    pub fn JS_IsTypedArrayObject(obj: *mut JSObject) -> bool;
    /**
 * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
 * return false if a security wrapper is encountered that denies the
 * unwrapping. If this test or one of the more specific tests succeeds, then it
 * is safe to call the various ArrayBufferView accessor JSAPI calls defined
 * below.
 */
    #[link_name = "_Z26JS_IsArrayBufferViewObjectP8JSObject"]
    pub fn JS_IsArrayBufferViewObject(obj: *mut JSObject) -> bool;
    #[link_name = "_Z14JS_IsInt8ArrayP8JSObject"]
    pub fn JS_IsInt8Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z15JS_IsUint8ArrayP8JSObject"]
    pub fn JS_IsUint8Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z22JS_IsUint8ClampedArrayP8JSObject"]
    pub fn JS_IsUint8ClampedArray(obj: *mut JSObject) -> bool;
    #[link_name = "_Z15JS_IsInt16ArrayP8JSObject"]
    pub fn JS_IsInt16Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z16JS_IsUint16ArrayP8JSObject"]
    pub fn JS_IsUint16Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z15JS_IsInt32ArrayP8JSObject"]
    pub fn JS_IsInt32Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z16JS_IsUint32ArrayP8JSObject"]
    pub fn JS_IsUint32Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z17JS_IsFloat32ArrayP8JSObject"]
    pub fn JS_IsFloat32Array(obj: *mut JSObject) -> bool;
    #[link_name = "_Z17JS_IsFloat64ArrayP8JSObject"]
    pub fn JS_IsFloat64Array(obj: *mut JSObject) -> bool;
    /**
 * Return the isShared flag of a typed array, which denotes whether
 * the underlying buffer is a SharedArrayBuffer.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "_Z26JS_GetTypedArraySharednessP8JSObject"]
    pub fn JS_GetTypedArraySharedness(obj: *mut JSObject) -> bool;
    #[link_name = "_ZN2js15UnwrapInt8ArrayEP8JSObject"]
    pub fn UnwrapInt8Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js16UnwrapUint8ArrayEP8JSObject"]
    pub fn UnwrapUint8Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js23UnwrapUint8ClampedArrayEP8JSObject"]
    pub fn UnwrapUint8ClampedArray(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js16UnwrapInt16ArrayEP8JSObject"]
    pub fn UnwrapInt16Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js17UnwrapUint16ArrayEP8JSObject"]
    pub fn UnwrapUint16Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js16UnwrapInt32ArrayEP8JSObject"]
    pub fn UnwrapInt32Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js17UnwrapUint32ArrayEP8JSObject"]
    pub fn UnwrapUint32Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js18UnwrapFloat32ArrayEP8JSObject"]
    pub fn UnwrapFloat32Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js18UnwrapFloat64ArrayEP8JSObject"]
    pub fn UnwrapFloat64Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js17UnwrapArrayBufferEP8JSObject"]
    pub fn UnwrapArrayBuffer(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js21UnwrapArrayBufferViewEP8JSObject"]
    pub fn UnwrapArrayBufferView(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js23UnwrapSharedArrayBufferEP8JSObject"]
    pub fn UnwrapSharedArrayBuffer(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js31GetArrayBufferViewLengthAndDataEP8JSObjectPjPbPPh"]
    pub fn GetArrayBufferViewLengthAndData(obj: *mut JSObject,
                                           length: *mut u32,
                                           isSharedMemory: *mut bool,
                                           data: *mut *mut u8);
    #[link_name = "_ZN2js27GetArrayBufferLengthAndDataEP8JSObjectPjPbPPh"]
    pub fn GetArrayBufferLengthAndData(obj: *mut JSObject, length: *mut u32,
                                       isSharedMemory: *mut bool,
                                       data: *mut *mut u8);
    #[link_name =
          "_ZN2js33GetSharedArrayBufferLengthAndDataEP8JSObjectPjPbPPh"]
    pub fn GetSharedArrayBufferLengthAndData(obj: *mut JSObject,
                                             length: *mut u32,
                                             isSharedMemory: *mut bool,
                                             data: *mut *mut u8);
    #[link_name =
          "_Z27JS_GetSharedArrayBufferDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetSharedArrayBufferData(obj: *mut JSObject,
                                       isSharedMemory: *mut bool,
                                       arg1: *const AutoCheckCannotGC)
     -> *mut u8;
    #[link_name = "_Z23JS_GetObjectAsInt8ArrayP8JSObjectPjPbPPa"]
    pub fn JS_GetObjectAsInt8Array(obj: *mut JSObject, length: *mut u32,
                                   isSharedMemory: *mut bool,
                                   data: *mut *mut i8) -> *mut JSObject;
    #[link_name = "_Z24JS_GetObjectAsUint8ArrayP8JSObjectPjPbPPh"]
    pub fn JS_GetObjectAsUint8Array(obj: *mut JSObject, length: *mut u32,
                                    isSharedMemory: *mut bool,
                                    data: *mut *mut u8) -> *mut JSObject;
    #[link_name = "_Z31JS_GetObjectAsUint8ClampedArrayP8JSObjectPjPbPPh"]
    pub fn JS_GetObjectAsUint8ClampedArray(obj: *mut JSObject,
                                           length: *mut u32,
                                           isSharedMemory: *mut bool,
                                           data: *mut *mut u8)
     -> *mut JSObject;
    #[link_name = "_Z24JS_GetObjectAsInt16ArrayP8JSObjectPjPbPPs"]
    pub fn JS_GetObjectAsInt16Array(obj: *mut JSObject, length: *mut u32,
                                    isSharedMemory: *mut bool,
                                    data: *mut *mut i16) -> *mut JSObject;
    #[link_name = "_Z25JS_GetObjectAsUint16ArrayP8JSObjectPjPbPPt"]
    pub fn JS_GetObjectAsUint16Array(obj: *mut JSObject, length: *mut u32,
                                     isSharedMemory: *mut bool,
                                     data: *mut *mut u16) -> *mut JSObject;
    #[link_name = "_Z24JS_GetObjectAsInt32ArrayP8JSObjectPjPbPPi"]
    pub fn JS_GetObjectAsInt32Array(obj: *mut JSObject, length: *mut u32,
                                    isSharedMemory: *mut bool,
                                    data: *mut *mut i32) -> *mut JSObject;
    #[link_name = "_Z25JS_GetObjectAsUint32ArrayP8JSObjectPjPbPS1_"]
    pub fn JS_GetObjectAsUint32Array(obj: *mut JSObject, length: *mut u32,
                                     isSharedMemory: *mut bool,
                                     data: *mut *mut u32) -> *mut JSObject;
    #[link_name = "_Z26JS_GetObjectAsFloat32ArrayP8JSObjectPjPbPPf"]
    pub fn JS_GetObjectAsFloat32Array(obj: *mut JSObject, length: *mut u32,
                                      isSharedMemory: *mut bool,
                                      data: *mut *mut f32) -> *mut JSObject;
    #[link_name = "_Z26JS_GetObjectAsFloat64ArrayP8JSObjectPjPbPPd"]
    pub fn JS_GetObjectAsFloat64Array(obj: *mut JSObject, length: *mut u32,
                                      isSharedMemory: *mut bool,
                                      data: *mut *mut f64) -> *mut JSObject;
    #[link_name = "_Z29JS_GetObjectAsArrayBufferViewP8JSObjectPjPbPPh"]
    pub fn JS_GetObjectAsArrayBufferView(obj: *mut JSObject, length: *mut u32,
                                         isSharedMemory: *mut bool,
                                         data: *mut *mut u8) -> *mut JSObject;
    #[link_name = "_Z25JS_GetObjectAsArrayBufferP8JSObjectPjPPh"]
    pub fn JS_GetObjectAsArrayBuffer(obj: *mut JSObject, length: *mut u32,
                                     data: *mut *mut u8) -> *mut JSObject;
    #[link_name = "_Z25JS_GetArrayBufferViewTypeP8JSObject"]
    pub fn JS_GetArrayBufferViewType(obj: *mut JSObject) -> Type;
    #[link_name = "_Z31JS_GetSharedArrayBufferViewTypeP8JSObject"]
    pub fn JS_GetSharedArrayBufferViewType(obj: *mut JSObject) -> Type;
    #[link_name = "_Z22JS_IsArrayBufferObjectP8JSObject"]
    pub fn JS_IsArrayBufferObject(obj: *mut JSObject) -> bool;
    #[link_name = "_Z28JS_IsSharedArrayBufferObjectP8JSObject"]
    pub fn JS_IsSharedArrayBufferObject(obj: *mut JSObject) -> bool;
    /**
 * Return the available byte length of an array buffer.
 *
 * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 * ArrayBuffer, and the unwrapping will succeed.
 */
    #[link_name = "_Z27JS_GetArrayBufferByteLengthP8JSObject"]
    pub fn JS_GetArrayBufferByteLength(obj: *mut JSObject) -> u32;
    #[link_name = "_Z33JS_GetSharedArrayBufferByteLengthP8JSObject"]
    pub fn JS_GetSharedArrayBufferByteLength(obj: *mut JSObject) -> u32;
    /**
 * Return true if the arrayBuffer contains any data. This will return false for
 * ArrayBuffer.prototype and detached ArrayBuffers.
 *
 * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 * ArrayBuffer, and the unwrapping will succeed.
 */
    #[link_name = "_Z21JS_ArrayBufferHasDataP8JSObject"]
    pub fn JS_ArrayBufferHasData(obj: *mut JSObject) -> bool;
    /**
 * Return a pointer to the start of the data referenced by a typed array. The
 * data is still owned by the typed array, and should not be modified on
 * another thread. Furthermore, the pointer can become invalid on GC (if the
 * data is small and fits inside the array's GC header), so callers must take
 * care not to hold on across anything that could GC.
 *
 * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 * ArrayBuffer, and the unwrapping will succeed.
 *
 * *isSharedMemory will be set to false, the argument is present to simplify
 * its use from code that also interacts with SharedArrayBuffer.
 */
    #[link_name =
          "_Z21JS_GetArrayBufferDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetArrayBufferData(obj: *mut JSObject,
                                 isSharedMemory: *mut bool,
                                 arg1: *const AutoCheckCannotGC) -> *mut u8;
    /**
 * Check whether the obj is ArrayBufferObject and memory mapped. Note that this
 * may return false if a security wrapper is encountered that denies the
 * unwrapping.
 */
    #[link_name = "_Z28JS_IsMappedArrayBufferObjectP8JSObject"]
    pub fn JS_IsMappedArrayBufferObject(obj: *mut JSObject) -> bool;
    /**
 * Return the number of elements in a typed array.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "_Z22JS_GetTypedArrayLengthP8JSObject"]
    pub fn JS_GetTypedArrayLength(obj: *mut JSObject) -> u32;
    /**
 * Return the byte offset from the start of an array buffer to the start of a
 * typed array view.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "_Z26JS_GetTypedArrayByteOffsetP8JSObject"]
    pub fn JS_GetTypedArrayByteOffset(obj: *mut JSObject) -> u32;
    /**
 * Return the byte length of a typed array.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "_Z26JS_GetTypedArrayByteLengthP8JSObject"]
    pub fn JS_GetTypedArrayByteLength(obj: *mut JSObject) -> u32;
    /**
 * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
 */
    #[link_name = "_Z31JS_GetArrayBufferViewByteLengthP8JSObject"]
    pub fn JS_GetArrayBufferViewByteLength(obj: *mut JSObject) -> u32;
    #[link_name =
          "_Z19JS_GetInt8ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetInt8ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                               arg1: *const AutoCheckCannotGC) -> *mut i8;
    #[link_name =
          "_Z20JS_GetUint8ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetUint8ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                                arg1: *const AutoCheckCannotGC) -> *mut u8;
    #[link_name =
          "_Z27JS_GetUint8ClampedArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetUint8ClampedArrayData(obj: *mut JSObject,
                                       isSharedMemory: *mut bool,
                                       arg1: *const AutoCheckCannotGC)
     -> *mut u8;
    #[link_name =
          "_Z20JS_GetInt16ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetInt16ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                                arg1: *const AutoCheckCannotGC) -> *mut i16;
    #[link_name =
          "_Z21JS_GetUint16ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetUint16ArrayData(obj: *mut JSObject,
                                 isSharedMemory: *mut bool,
                                 arg1: *const AutoCheckCannotGC) -> *mut u16;
    #[link_name =
          "_Z20JS_GetInt32ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetInt32ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                                arg1: *const AutoCheckCannotGC) -> *mut i32;
    #[link_name =
          "_Z21JS_GetUint32ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetUint32ArrayData(obj: *mut JSObject,
                                 isSharedMemory: *mut bool,
                                 arg1: *const AutoCheckCannotGC) -> *mut u32;
    #[link_name =
          "_Z22JS_GetFloat32ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetFloat32ArrayData(obj: *mut JSObject,
                                  isSharedMemory: *mut bool,
                                  arg1: *const AutoCheckCannotGC) -> *mut f32;
    #[link_name =
          "_Z22JS_GetFloat64ArrayDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetFloat64ArrayData(obj: *mut JSObject,
                                  isSharedMemory: *mut bool,
                                  arg1: *const AutoCheckCannotGC) -> *mut f64;
    /**
 * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
 * versions when possible.
 */
    #[link_name =
          "_Z25JS_GetArrayBufferViewDataP8JSObjectPbRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetArrayBufferViewData(obj: *mut JSObject,
                                     isSharedMemory: *mut bool,
                                     arg1: *const AutoCheckCannotGC)
     -> *mut ::std::os::raw::c_void;
    /**
 * Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.
 * This may return a detached buffer.  |obj| must be an object that would
 * return true for JS_IsArrayBufferViewObject().
 */
    #[link_name =
          "_Z27JS_GetArrayBufferViewBufferP9JSContextN2JS6HandleIP8JSObjectEEPb"]
    pub fn JS_GetArrayBufferViewBuffer(cx: *mut JSContext, obj: HandleObject,
                                       isSharedMemory: *mut bool)
     -> *mut JSObject;
    /**
 * Detach an ArrayBuffer, causing all associated views to no longer refer to
 * the ArrayBuffer's original attached memory.
 *
 * The |changeData| argument is a hint to inform internal behavior with respect
 * to the ArrayBuffer's internal pointer to associated data.  |ChangeData|
 * attempts to set the internal pointer to fresh memory of the same size as the
 * original memory; |KeepData| attempts to preserve the original pointer, even
 * while the ArrayBuffer appears observably detached.  There is no guarantee
 * this parameter is respected -- it's only a hint.
 */
    #[link_name =
          "_Z20JS_DetachArrayBufferP9JSContextN2JS6HandleIP8JSObjectEE21DetachDataDisposition"]
    pub fn JS_DetachArrayBuffer(cx: *mut JSContext, obj: HandleObject,
                                changeData: DetachDataDisposition) -> bool;
    /**
 * Check whether the obj is a detached ArrayBufferObject. Note that this may
 * return false if a security wrapper is encountered that denies the
 * unwrapping.
 */
    #[link_name = "_Z30JS_IsDetachedArrayBufferObjectP8JSObject"]
    pub fn JS_IsDetachedArrayBufferObject(obj: *mut JSObject) -> bool;
    /**
 * Check whether obj supports JS_GetDataView* APIs.
 */
    #[link_name = "_Z19JS_IsDataViewObjectP8JSObject"]
    pub fn JS_IsDataViewObject(obj: *mut JSObject) -> bool;
    /**
 * Create a new DataView using the given ArrayBuffer for storage. The given
 * buffer must be an ArrayBuffer (or a cross-compartment wrapper of an
 * ArrayBuffer), and the offset and length must fit within the bounds of the
 * arrayBuffer. Currently, nullptr will be returned and an exception will be
 * thrown if these conditions do not hold, but do not depend on that behavior.
 */
    #[link_name = "_Z14JS_NewDataViewP9JSContextN2JS6HandleIP8JSObjectEEji"]
    pub fn JS_NewDataView(cx: *mut JSContext, arrayBuffer: HandleObject,
                          byteOffset: u32, byteLength: i32) -> *mut JSObject;
    /**
 * Return the byte offset of a data view into its array buffer. |obj| must be a
 * DataView.
 *
 * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 * it would pass such a test: it is a data view or a wrapper of a data view,
 * and the unwrapping will succeed.
 */
    #[link_name = "_Z24JS_GetDataViewByteOffsetP8JSObject"]
    pub fn JS_GetDataViewByteOffset(obj: *mut JSObject) -> u32;
    /**
 * Return the byte length of a data view.
 *
 * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 * it would pass such a test: it is a data view or a wrapper of a data view,
 * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
 * unable to assert when unwrapping should be disallowed.
 */
    #[link_name = "_Z24JS_GetDataViewByteLengthP8JSObject"]
    pub fn JS_GetDataViewByteLength(obj: *mut JSObject) -> u32;
    /**
 * Return a pointer to the beginning of the data referenced by a DataView.
 *
 * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 * it would pass such a test: it is a data view or a wrapper of a data view,
 * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
 * unable to assert when unwrapping should be disallowed.
 */
    #[link_name =
          "_Z18JS_GetDataViewDataP8JSObjectRKN2JS17AutoCheckCannotGCE"]
    pub fn JS_GetDataViewData(obj: *mut JSObject,
                              arg1: *const AutoCheckCannotGC)
     -> *mut ::std::os::raw::c_void;
    /**
 * Add a watchpoint -- in the Object.prototype.watch sense -- to |obj| for the
 * property |id|, using the callable object |callable| as the function to be
 * called for notifications.
 *
 * This is an internal function exposed -- temporarily -- only so that DOM
 * proxies can be watchable.  Don't use it!  We'll soon kill off the
 * Object.prototype.{,un}watch functions, at which point this will go too.
 */
    #[link_name =
          "_ZN2js9WatchGutsEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEES6_"]
    pub fn WatchGuts(cx: *mut JSContext, obj: HandleObject, id: HandleId,
                     callable: HandleObject) -> bool;
    /**
 * Remove a watchpoint -- in the Object.prototype.watch sense -- from |obj| for
 * the property |id|.
 *
 * This is an internal function exposed -- temporarily -- only so that DOM
 * proxies can be watchable.  Don't use it!  We'll soon kill off the
 * Object.prototype.{,un}watch functions, at which point this will go too.
 */
    #[link_name =
          "_ZN2js11UnwatchGutsEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEE"]
    pub fn UnwatchGuts(cx: *mut JSContext, obj: HandleObject, id: HandleId)
     -> bool;
    #[link_name = "_ZN2js6detail13IdMatchesAtomE4jsidP6JSAtom"]
    pub fn IdMatchesAtom(id: jsid, atom: *mut JSAtom) -> bool;
    #[link_name =
          "_ZN2js33PrepareScriptEnvironmentAndInvokeEP9JSContextN2JS6HandleIP8JSObjectEERNS_25ScriptEnvironmentPreparer7ClosureE"]
    pub fn PrepareScriptEnvironmentAndInvoke(cx: *mut JSContext,
                                             scope: HandleObject,
                                             closure:
                                                 *mut ScriptEnvironmentPreparer_Closure);
    #[link_name =
          "_ZN2js28SetScriptEnvironmentPreparerEP9JSRuntimePNS_25ScriptEnvironmentPreparerE"]
    pub fn SetScriptEnvironmentPreparer(rt: *mut JSRuntime,
                                        preparer:
                                            *mut ScriptEnvironmentPreparer);
    /**
 * Sets a callback that is run whenever js-ctypes is about to be used when
 * calling into C.
 */
    #[link_name =
          "_ZN2js25SetCTypesActivityCallbackEP9JSRuntimePFvP9JSContextNS_18CTypesActivityTypeEE"]
    pub fn SetCTypesActivityCallback(rt: *mut JSRuntime,
                                     cb: CTypesActivityCallback);
    /**
 * Specify a callback to invoke when creating each JS object in the current
 * compartment, which may return a metadata object to associate with the
 * object.
 */
    #[link_name =
          "_ZN2js28SetAllocationMetadataBuilderEP9JSContextPKNS_25AllocationMetadataBuilderE"]
    pub fn SetAllocationMetadataBuilder(cx: *mut JSContext,
                                        callback:
                                            *const AllocationMetadataBuilder);
    /** Get the metadata associated with an object. */
    #[link_name = "_ZN2js21GetAllocationMetadataEP8JSObject"]
    pub fn GetAllocationMetadata(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "_ZN2js20GetElementsWithAdderEP9JSContextN2JS6HandleIP8JSObjectEES6_jjPNS_12ElementAdderE"]
    pub fn GetElementsWithAdder(cx: *mut JSContext, obj: HandleObject,
                                receiver: HandleObject, begin: u32, end: u32,
                                adder: *mut ElementAdder) -> bool;
    #[link_name =
          "_ZN2js15ForwardToNativeEP9JSContextPFbS1_jPN2JS5ValueEERKNS2_8CallArgsE"]
    pub fn ForwardToNative(cx: *mut JSContext, native: JSNative,
                           args: *const CallArgs) -> bool;
    /**
 * Helper function for HTMLDocument and HTMLFormElement.
 *
 * These are the only two interfaces that have [OverrideBuiltins], a named
 * getter, and no named setter. They're implemented as proxies with a custom
 * getOwnPropertyDescriptor() method. Unfortunately, overriding
 * getOwnPropertyDescriptor() automatically affects the behavior of set(),
 * which normally is just common sense but is *not* desired for these two
 * interfaces.
 *
 * The fix is for these two interfaces to override set() to ignore the
 * getOwnPropertyDescriptor() override.
 *
 * SetPropertyIgnoringNamedGetter is exposed to make it easier to override
 * set() in this way.  It carries out all the steps of BaseProxyHandler::set()
 * except the initial getOwnPropertyDescriptor() call.  The caller must supply
 * that descriptor as the 'ownDesc' parameter.
 *
 * Implemented in proxy/BaseProxyHandler.cpp.
 */
    #[link_name =
          "_ZN2js30SetPropertyIgnoringNamedGetterEP9JSContextN2JS6HandleIP8JSObjectEENS3_I4jsidEENS3_INS2_5ValueEEESA_NS3_INS2_18PropertyDescriptorEEERNS2_14ObjectOpResultE"]
    pub fn SetPropertyIgnoringNamedGetter(cx: *mut JSContext,
                                          obj: HandleObject, id: HandleId,
                                          v: HandleValue,
                                          receiver: HandleValue,
                                          ownDesc: Handle<PropertyDescriptor>,
                                          result: *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "_ZN2js17ReportErrorWithIdEP9JSContextPKcN2JS6HandleI4jsidEE"]
    pub fn ReportErrorWithId(cx: *mut JSContext,
                             msg: *const ::std::os::raw::c_char,
                             id: HandleId);
    #[link_name =
          "_ZN2js29ExecuteInGlobalAndReturnScopeEP9JSContextN2JS6HandleIP8JSObjectEENS3_IP8JSScriptEENS2_13MutableHandleIS5_EE"]
    pub fn ExecuteInGlobalAndReturnScope(cx: *mut JSContext,
                                         obj: HandleObject,
                                         script: HandleScript,
                                         scope: MutableHandleObject) -> bool;
    /**
 * Get the nearest enclosing with scope object for a given function. If the
 * function is not scripted or is not enclosed by a with scope, returns the
 * global.
 */
    #[link_name =
          "_ZN2js45GetNearestEnclosingWithScopeObjectForFunctionEP10JSFunction"]
    pub fn GetNearestEnclosingWithScopeObjectForFunction(fun: *mut JSFunction)
     -> *mut JSObject;
    /**
 * Get the first SavedFrame object in this SavedFrame stack whose principals are
 * subsumed by the cx's principals. If there is no such frame, return nullptr.
 *
 * Do NOT pass a non-SavedFrame object here.
 *
 * The savedFrame and cx do not need to be in the same compartment.
 */
    #[link_name =
          "_ZN2js26GetFirstSubsumedSavedFrameEP9JSContextN2JS6HandleIP8JSObjectEENS2_20SavedFrameSelfHostedE"]
    pub fn GetFirstSubsumedSavedFrame(cx: *mut JSContext,
                                      savedFrame: HandleObject,
                                      selfHosted: SavedFrameSelfHosted)
     -> *mut JSObject;
    #[link_name =
          "_ZN2js19ReportIsNotFunctionEP9JSContextN2JS6HandleINS2_5ValueEEE"]
    pub fn ReportIsNotFunction(cx: *mut JSContext, v: HandleValue) -> bool;
    #[link_name = "_ZN2js18ConvertArgsToArrayEP9JSContextRKN2JS8CallArgsE"]
    pub fn ConvertArgsToArray(cx: *mut JSContext, args: *const CallArgs)
     -> *mut JSObject;
    /**
 * Tell the JS engine which Class is used for WindowProxy objects. Used by the
 * functions below.
 */
    #[link_name = "_ZN2js19SetWindowProxyClassEP9JSRuntimePKNS_5ClassE"]
    pub fn SetWindowProxyClass(rt: *mut JSRuntime, clasp: *const Class);
    /**
 * Associates a WindowProxy with a Window (global object). `windowProxy` must
 * have the Class set by SetWindowProxyClass.
 */
    #[link_name =
          "_ZN2js14SetWindowProxyEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
    pub fn SetWindowProxy(cx: *mut JSContext, global: HandleObject,
                          windowProxy: HandleObject);
    #[link_name = "_ZN2js6detail12IsWindowSlowEP8JSObject"]
    pub fn IsWindowSlow(obj: *mut JSObject) -> bool;
    /**
 * Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass).
 */
    #[link_name = "_ZN2js13IsWindowProxyEP8JSObject"]
    pub fn IsWindowProxy(obj: *mut JSObject) -> bool;
    /**
 * If `obj` is a Window, get its associated WindowProxy (or a CCW or dead
 * wrapper if the page was navigated away from), else return `obj`. This
 * function is infallible and never returns nullptr.
 */
    #[link_name = "_ZN2js21ToWindowProxyIfWindowEP8JSObject"]
    pub fn ToWindowProxyIfWindow(obj: *mut JSObject) -> *mut JSObject;
    /**
 * If `obj` is a WindowProxy, get its associated Window (the compartment's
 * global), else return `obj`. This function is infallible and never returns
 * nullptr.
 */
    #[link_name = "_ZN2js21ToWindowIfWindowProxyEP8JSObject"]
    pub fn ToWindowIfWindowProxy(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "_ZN2js13ToBooleanSlowEN2JS6HandleINS0_5ValueEEE"]
    pub fn ToBooleanSlow(v: HandleValue) -> bool;
    #[link_name = "_ZN2js12ToNumberSlowEP9JSContextN2JS5ValueEPd"]
    pub fn ToNumberSlow(cx: *mut JSContext, v: Value, dp: *mut f64) -> bool;
    #[link_name = "_ZN2js10ToInt8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPa"]
    pub fn ToInt8Slow(cx: *mut JSContext, v: HandleValue, out: *mut i8)
     -> bool;
    #[link_name =
          "_ZN2js11ToUint8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPh"]
    pub fn ToUint8Slow(cx: *mut JSContext, v: HandleValue, out: *mut u8)
     -> bool;
    #[link_name =
          "_ZN2js11ToInt16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPs"]
    pub fn ToInt16Slow(cx: *mut JSContext, v: HandleValue, out: *mut i16)
     -> bool;
    #[link_name =
          "_ZN2js11ToInt32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPi"]
    pub fn ToInt32Slow(cx: *mut JSContext, v: HandleValue, out: *mut i32)
     -> bool;
    #[link_name =
          "_ZN2js12ToUint32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPj"]
    pub fn ToUint32Slow(cx: *mut JSContext, v: HandleValue, out: *mut u32)
     -> bool;
    #[link_name =
          "_ZN2js12ToUint16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPt"]
    pub fn ToUint16Slow(cx: *mut JSContext, v: HandleValue, out: *mut u16)
     -> bool;
    #[link_name =
          "_ZN2js11ToInt64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPx"]
    pub fn ToInt64Slow(cx: *mut JSContext, v: HandleValue, out: *mut i64)
     -> bool;
    #[link_name =
          "_ZN2js12ToUint64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPy"]
    pub fn ToUint64Slow(cx: *mut JSContext, v: HandleValue, out: *mut u64)
     -> bool;
    #[link_name = "_ZN2js12ToStringSlowEP9JSContextN2JS6HandleINS2_5ValueEEE"]
    pub fn ToStringSlow(cx: *mut JSContext, v: HandleValue) -> *mut JSString;
    #[link_name =
          "_ZN2js12ToObjectSlowEP9JSContextN2JS6HandleINS2_5ValueEEEb"]
    pub fn ToObjectSlow(cx: *mut JSContext, v: HandleValue,
                        reportScanStack: bool) -> *mut JSObject;
    /**
 * Assert that we're not doing GC on cx, that we're in a request as
 * needed, and that the compartments for cx and v are correct.
 * Also check that GC would be safe at this point.
 */
    #[link_name =
          "_ZN2JS6detail22AssertArgumentsAreSaneEP9JSContextNS_6HandleINS_5ValueEEE"]
    pub fn AssertArgumentsAreSane(cx: *mut JSContext, v: HandleValue);
    /**
 * ES6 draft 20141224, 7.1.1, second algorithm.
 *
 * Most users shouldn't call this -- use JS::ToBoolean, ToNumber, or ToString
 * instead.  This will typically only be called from custom convert hooks that
 * wish to fall back to the ES6 default conversion behavior shared by most
 * objects in JS, codified as OrdinaryToPrimitive.
 */
    #[link_name =
          "_ZN2JS19OrdinaryToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
    pub fn OrdinaryToPrimitive(cx: *mut JSContext, obj: HandleObject,
                               type_: JSType, vp: MutableHandleValue) -> bool;
    /**
 * This function can be used to track memory used by ICU.  If it is called, it
 * *must* be called before JS_Init.  Don't use it unless you know what you're
 * doing!
 */
    #[link_name = "_Z24JS_SetICUMemoryFunctionsPFPvPKvyEPFS_S1_S_yEPFvS1_S_E"]
    pub fn JS_SetICUMemoryFunctions(allocFn: JS_ICUAllocFn,
                                    reallocFn: JS_ICUReallocFn,
                                    freeFn: JS_ICUFreeFn) -> bool;
    /**
 * Initialize SpiderMonkey, returning true only if initialization succeeded.
 * Once this method has succeeded, it is safe to call JS_NewRuntime and other
 * JSAPI methods.
 *
 * This method must be called before any other JSAPI method is used on any
 * thread.  Once it has been used, it is safe to call any JSAPI method, and it
 * remains safe to do so until JS_ShutDown is correctly called.
 *
 * It is currently not possible to initialize SpiderMonkey multiple times (that
 * is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
 * again).  This restriction may eventually be lifted.
 */
    #[link_name = "_Z7JS_Initv"]
    pub fn JS_Init() -> bool;
    /**
 * A variant of JS_Init. On success it returns nullptr. On failure it returns a
 * pointer to a string literal that describes how initialization failed, which
 * can be useful for debugging purposes.
 */
    #[link_name = "_Z28JS_InitWithFailureDiagnosticv"]
    pub fn JS_InitWithFailureDiagnostic() -> *const ::std::os::raw::c_char;
    /**
 * Destroy free-standing resources allocated by SpiderMonkey, not associated
 * with any runtime, context, or other structure.
 *
 * This method should be called after all other JSAPI data has been properly
 * cleaned up: every new runtime must have been destroyed, every new context
 * must have been destroyed, and so on.  Calling this method before all other
 * resources have been destroyed has undefined behavior.
 *
 * Failure to call this method, at present, has no adverse effects other than
 * leaking memory.  This may not always be the case; it's recommended that all
 * embedders call this method when all other JSAPI operations have completed.
 *
 * It is currently not possible to initialize SpiderMonkey multiple times (that
 * is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
 * again).  This restriction may eventually be lifted.
 */
    #[link_name = "_Z11JS_ShutDownv"]
    pub fn JS_ShutDown();
    /**
 * In memory reporting, we have concept of "sundries", line items which are too
 * small to be worth reporting individually.  Under some circumstances, a memory
 * reporter gets tossed into the sundries bucket if it's smaller than
 * MemoryReportingSundriesThreshold() bytes.
 *
 * We need to define this value here, rather than in the code which actually
 * generates the memory reports, because NotableStringInfo uses this value.
 */
    #[link_name = "_ZN2js32MemoryReportingSundriesThresholdEv"]
    pub fn MemoryReportingSundriesThreshold() -> usize;
    #[link_name =
          "_ZN2JS19CollectRuntimeStatsEP9JSRuntimePNS_12RuntimeStatsEPNS_20ObjectPrivateVisitorEb"]
    pub fn CollectRuntimeStats(rt: *mut JSRuntime, rtStats: *mut RuntimeStats,
                               opv: *mut ObjectPrivateVisitor,
                               anonymize: bool) -> bool;
    #[link_name = "_ZN2JS22SystemCompartmentCountEP9JSRuntime"]
    pub fn SystemCompartmentCount(rt: *mut JSRuntime) -> usize;
    #[link_name = "_ZN2JS20UserCompartmentCountEP9JSRuntime"]
    pub fn UserCompartmentCount(rt: *mut JSRuntime) -> usize;
    #[link_name = "_ZN2JS19PeakSizeOfTemporaryEPK9JSRuntime"]
    pub fn PeakSizeOfTemporary(rt: *const JSRuntime) -> usize;
    #[link_name =
          "_ZN2JS12AddSizeOfTabEP9JSRuntimeNS_6HandleIP8JSObjectEEPFyPKvEPNS_20ObjectPrivateVisitorEPNS_8TabSizesE"]
    pub fn AddSizeOfTab(rt: *mut JSRuntime, obj: HandleObject,
                        mallocSizeOf: MallocSizeOf,
                        opv: *mut ObjectPrivateVisitor, sizes: *mut TabSizes)
     -> bool;
    #[link_name =
          "_ZN2JS14AddServoSizeOfEP9JSRuntimePFyPKvEPNS_20ObjectPrivateVisitorEPNS_10ServoSizesE"]
    pub fn AddServoSizeOf(rt: *mut JSRuntime, mallocSizeOf: MallocSizeOf,
                          opv: *mut ObjectPrivateVisitor,
                          sizes: *mut ServoSizes) -> bool;
}
